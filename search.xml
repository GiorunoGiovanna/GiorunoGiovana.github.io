<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bolb和FormData之间的区别</title>
    <url>/2021/06/26/Bolb%E5%92%8CFormData%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>​     问题背景：参与了学校大佬的一个开源项目，基于Apache Pulsar的Function Stream。具体内容看<a href="https://github.com/FunctionStream/function-stream">这里</a>。我在项目中负责某几个接口的对接，其中有一个接口接受一个文件和一个对象，由于后端是基于Apache Pulsar开发的，接口是其他人做的，修改接口不太现实，只好从前端入手了。</p>
<p>​    首先在postman上尝试，能够正常上传。跑去看了看上传成功的数据格式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/20210910080004594.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>​    Content-Type是form-data，所以很自然地使用FormData去构造数据，将funcConfig和data分别append进参数中，然后上传，结果是不出意料地失败了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1624179110.png" alt="1624179110"></p>
<p>​    网上的说法有：</p>
<ol>
<li>把对象直接append进data里。</li>
<li>是把对象序列化后append进data里</li>
</ol>
<p>​    试过之后发现都不行，要么报错说参数缺失，要么参数格式有误。</p>
<p>​    最后在博客看到有一个说法是用Blob去构造对象。</p>
<p>​    找到一个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> debug = &#123;<span class="attr">hello</span>: <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(debug, <span class="literal">null</span>, <span class="number">2</span>)], &#123;<span class="attr">type</span> : <span class="string">&#x27;application/json&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>​    试了一下，结果成功了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data.append(<span class="string">&#x27;functionConfig&#x27;</span>, <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(functionConfig)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;))</span><br></pre></td></tr></table></figure>



<h4 id="MDN上对Blob的描述："><a href="#MDN上对Blob的描述：" class="headerlink" title="MDN上对Blob的描述："></a>MDN上对Blob的描述：</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。 </p>
<p>Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<h4 id="MDN上对File的描述："><a href="#MDN上对File的描述：" class="headerlink" title="MDN上对File的描述："></a>MDN上对File的描述：</h4><p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。比如说， FileReader, URL.createObjectURL(), createImageBitmap() (en-US), 及 XMLHttpRequest.send() 都能处理 Blob 和File。</p>
<h4 id="MDN上对FormData的描述："><a href="#MDN上对FormData的描述：" class="headerlink" title="MDN上对FormData的描述："></a>MDN上对FormData的描述：</h4><p>FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 “multipart/form-data”，它会使用和表单一样的格式。</p>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>回头再看发生的错误，正是’functionConfig’这个参数没有被识别出来，那么问题就明确了，后端接收参数的时候确实是使用FormData格式，只是出于某种原因，在本来直接按键值对方式就可以取出的对象参数’functionConfig’,后端默认当成二进制文件一并处理了，处理完成后才去找这个参数。</p>
<p>所以要在上传的时候将这个参数用二进制文件的格式包装起来，才能在后台解析的时候正确获取到对应的值。</p>
]]></content>
      <categories>
        <category>FuntcionStream</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记01</title>
    <url>/2021/12/04/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><p>从原理上来讲vue是利用了Object的defineProperty的属性，它把我们放进去的data中每一个属性都设置了getter和setter，这样当data的属性值更新后，我们就会收到通知，并可以通知那些需要更新的地方去进行更新。</p>
<h3 id="getter-amp-amp-setter简单实现"><a href="#getter-amp-amp-setter简单实现" class="headerlink" title="getter&amp;&amp;setter简单实现"></a>getter&amp;&amp;setter简单实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查是否为对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">        &amp;&amp; !<span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">        &amp;&amp; obj !==<span class="literal">null</span></span><br><span class="line">        &amp;&amp; obj !==<span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">convert</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isObject(obj))&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为每个对象的键值对添加getter和setter</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//提供变量存储键对应的值</span></span><br><span class="line">            <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`getting key &quot;<span class="subst">$&#123;key&#125;</span>&quot;: <span class="subst">$&#123;internalValue&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">return</span> internalValue</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`setting key &quot;<span class="subst">$&#123;key&#125;</span>&quot; to: <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">                    internalValue = newValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="依赖跟踪"><a href="#依赖跟踪" class="headerlink" title="依赖跟踪"></a>依赖跟踪</h3><p>使用上面的getter和setter我们模拟了对象的响应式，那么问题来了，假设我们有一个对象，其中有个属性added：233，我们在一个函数中使用了这个added做一个加法，得到了一个结果，但是我们修改了added的值，并期望函数的结果也会随之改变，这要怎么实现呢？、</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a class representing a dependency</span></span><br><span class="line"><span class="comment">// exposing it on window is necessary for testing</span></span><br><span class="line"><span class="built_in">window</span>.Dep = <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//设置一个变量存储</span></span><br><span class="line">      <span class="built_in">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跟踪函数依赖，类似于在此处插眼</span></span><br><span class="line">    depend () &#123;</span><br><span class="line">      <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">        <span class="comment">// register the current active update as a subscriber</span></span><br><span class="line">          <span class="comment">//将跟踪的函数加入到set表中</span></span><br><span class="line">        <span class="built_in">this</span>.subscribers.add(activeUpdate)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新执行函数，在刚刚插眼的函数中重新执行该函数，达到更新的效果</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">      <span class="comment">// run all subscriber functions</span></span><br><span class="line">        <span class="comment">//set列表中的每一个函数都重新执行</span></span><br><span class="line">      <span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">subscriber</span> =&gt;</span> subscriber())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用一个全局变量储存函数（重点！）,这样可以让类实例在外部访问这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrappedUpdate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    activeUpdate = wrappedUpdate</span><br><span class="line">    update()</span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>简单来讲，就是创建一个类，它提供一种类似“插眼”的功能（depend ()），我们在需要跟踪的函数中插入这个眼，当我们需要它更新时，再调用这个眼（notify ()）重新执行一遍函数，达到更新结果的目的。</p>
<h3 id="迷你观察者"><a href="#迷你观察者" class="headerlink" title="迷你观察者"></a>迷你观察者</h3><p>我们把依赖追踪和getter&amp;&amp;setter结合起来，就可以完成我们需要的功能了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">      &amp;&amp; !<span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">      &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">      &amp;&amp; obj !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(obj))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">        <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">            get () &#123;</span><br><span class="line">                <span class="comment">//插眼</span></span><br><span class="line">                dep.depend()</span><br><span class="line">                <span class="keyword">return</span> internalValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> ifValueChange = v !==internalValue</span><br><span class="line">                <span class="keyword">if</span>(ifValueChange)&#123;</span><br><span class="line">                    internalValue = v</span><br><span class="line">                    <span class="comment">//检测到数值变化重新调用该函数</span></span><br><span class="line">                    dep.notify()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.Dep = <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="comment">// register the current active update as a subscriber</span></span><br><span class="line">      <span class="built_in">this</span>.subscribers.add(activeUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// run all subscriber functions</span></span><br><span class="line">    <span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">subscriber</span> =&gt;</span> subscriber())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrappedUpdate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    activeUpdate = wrappedUpdate</span><br><span class="line">    update()</span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>可以看到我们把插眼这个动作放到了getter里面，把重新调用放到了setter里面，这样我们就可以监听对象的变化，一旦它的属性值发生改变，就会触发重新调用，这样就达到了监听对象，并实时更新与他有关的值，即Vue响应式的简单原理。</p>
<p>参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p>参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记02</title>
    <url>/2021/12/04/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B002/</url>
    <content><![CDATA[<h2 id="编写一个简单插件"><a href="#编写一个简单插件" class="headerlink" title="编写一个简单插件"></a>编写一个简单插件</h2><p>Vue中有一个强大的功能就是提供插件的使用:</p>
<h3 id="Vue-use-Plugin"><a href="#Vue-use-Plugin" class="headerlink" title="Vue.use(Plugin)"></a>Vue.use(Plugin)</h3><p>通过简单的use命令就可以调用各种各样的插件，极大方便了我们的日常开发。那么如何编写一个插件呢？</p>
<p>插件（Plugin）本质上就是一个函数，它接受一个参数是Vue构造器，另一个参数是可选的选项对象options。<br>另一个需要了解的技术是Vue.mixin:</p>
<h3 id="Vue-mixin-options"><a href="#Vue-mixin-options" class="headerlink" title="Vue.mixin(options)"></a>Vue.mixin(options)</h3><p>mixins本质上是一段可重复利用的代码段，Vue.mixin(options)是一个全局的api，所以它可以应用到所有实例之中。注意！因为它可以混入到所有实例中，所以我们在使用它的时候要格外的小心。</p>
<p>如果你想使用一些全局上的功能，可能会用到mixin，但是如果你需要反复调用mixin，最好的办法是将其用插件接口包装，这样插件会防止被反复应用。<br>最后一个知识点是$options:</p>
<h3 id="options"><a href="#options" class="headerlink" title="$options"></a>$options</h3><p>$options是一个对象，他会收集包括</p>
<p>1.全局mixins</p>
<p>2.组件自定义的mixin</p>
<p>3.你传递给他的选项（options）</p>
<p>4.你添加到组件的任何自定义项<br>利用上面说到的知识，就可以编写一个简单的插件了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RulesPlugin = &#123;</span><br><span class="line">    <span class="comment">//加载vue插件，稍后使用Vue.use注册它</span></span><br><span class="line">  install (Vue) &#123;</span><br><span class="line">      <span class="comment">//全局混入，注意，它将影响之后创建的每一个vue实例！</span></span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        <span class="comment">//在created生命周期钩子处注册函数</span></span><br><span class="line">      created () &#123;</span><br><span class="line">          <span class="comment">//在data外定义的属性和方法可以用$options调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.hasOwnProperty(<span class="string">&#x27;rules&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">const</span> rules = <span class="built_in">this</span>.$options.rules</span><br><span class="line">          <span class="built_in">Object</span>.keys(rules).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> rule = rules[key]</span><br><span class="line">              <span class="comment">//监听rules对象中的每一个属性变化</span></span><br><span class="line">            <span class="built_in">this</span>.$watch(key, <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> result = rule.validate(newValue)</span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(rule.message)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.use(RulesPlugin)</span><br></pre></td></tr></table></figure>

<p>这个插件的作用是监听一个Vue实例中data的属性值，当其中的属性值发生改变的时候，就会检查对应的规则，并进行校验。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">foo</span>: <span class="number">10</span>,<span class="attr">bar</span> :<span class="number">10</span> &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">1</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;foo must be greater than one&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bar</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">1</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;gun yuan dian&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">vm.foo = <span class="number">1</span> <span class="comment">// should log: &quot;foo must be greater than one&quot;</span></span><br></pre></td></tr></table></figure>

<p> 参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p>参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记03</title>
    <url>/2021/12/04/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B003/</url>
    <content><![CDATA[<h3 id="Render-Function"><a href="#Render-Function" class="headerlink" title="Render Function"></a>Render Function</h3><p>渲染函数是组成完整的响应性渲染系统的另外一半，Vue的template实际上是通过渲染函数渲染出来的。</p>
<p>在Vue上下文中，当我们第一次渲染一个Vue应用时，会将template放到渲染函数进行编译。Render函数实际上是一个返回虚拟DOM的函数，然后Vue基于虚拟DOM生成真实DOM。</p>
<p>在后续的产生虚拟DOM的过程本质上是调用渲染函数，因为渲染函数和所有的data属性有依赖关系，在Vue中，这些data属性是具有响应性的，所有这些data属性会帮助这个组件的渲染函数收集依赖，如果这些依赖关系中的任何一个发生变化，将会再次调用渲染函数，它会返回一个新的虚拟DOM，新的虚拟DOM会和旧的虚拟DOM进行比较，最后，把最少量的更改应用到真实DOM中。</p>
<h3 id="Render-Function-API"><a href="#Render-Function-API" class="headerlink" title="Render Function API"></a>Render Function API</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [...])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> render函数接收一个参数h（hyper script超文本脚本），h需要三个参数，第一个参数是元素类型，第二个参数是数据对象（可选），第三个参数是一个数组表示子节点。它会返回这个虚拟DOM树的顶层元素，以便返回整个树。</p>
<h3 id="虚拟DOM（Virtual-DOM）"><a href="#虚拟DOM（Virtual-DOM）" class="headerlink" title="虚拟DOM（Virtual DOM）"></a>虚拟DOM（Virtual DOM）</h3><p> 通常情况下，调用真实DOM的开销十分的大，因为真实DOM具有非常多的属性，并且它在底层实现也十分的复杂。所以很多时候我们会说直接修改DOM是比较缓慢的。虚拟DOM的结构十分简单，因此它的开销会比真实DOM小很多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Virtual DOM</span><br><span class="line"></span><br><span class="line"><span class="comment">//tag标签名；data数据对象，如果没有数据对象可以忽略</span></span><br><span class="line"><span class="comment">//children可以拥有子虚拟节点，这样就构成了一个虚拟DOM树</span></span><br><span class="line">&#123; <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>, <span class="attr">data</span>:&#123; <span class="attr">attrs</span>:&#123;&#125;, ...&#125;, <span class="attr">children</span>:[] &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>虚拟DOM的本质是用轻量的Javascript数据格式来表示真实DOM在特定时间的外在表现，我们每次更新信息，先构造一个新的虚拟DOM，我们先计算差异，然后将这些更改应用到DOM上。</p>
<h3 id="响应性和Render-Function整合"><a href="#响应性和Render-Function整合" class="headerlink" title="响应性和Render Function整合"></a>响应性和Render Function整合</h3><p><img src="https://img-blog.csdnimg.cn/82151c8e6d0d47058fd61a0cc8a9d6e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAam9rZXJfMjE=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 每一个组件都有一个渲染函数，它实际上包装在我们之前实现的autorun函数（笔记1）中，当数据发生变化的时候，观察者（wathcer）通过调用data属性中的getter收集依赖项，并监听setter，将收集到的改变通知到渲染函数，渲染函数再生成一个新的虚拟DOM。只要我们依赖的渲染属性发生变化，就会不断循环上述步骤。</p>
<p>每个组件都有自己的自动循环渲染，组件树有许多组件构成，每个组件都只负责自己的依赖。</p>
<p>由于你可以更改数据依赖关系，你的数据可以再任何地方发生改变，但是因为么个组件都只负责自己的依赖，再整个组件树中我们确切的知道哪些组件受到哪些数据的影响，所以，它有一个精确的依赖跟踪系统，不会造成过多的组件发生不必要的重新渲染。</p>
<p>相比于React自上而下的渲染模型，Vue可以说省去了一部分优化的工作。但是也付出了一部分将数据转换为getter和setter的开销。因此有了React上限高（优化做得好的话），下限低（优化不好），而Vue下限高（一部分优化工作自动完成），上限低（相比React开销更大一些）。但是在实际应用中，两者的差距其实很小，只有在极端情况下才会出现较大偏差。</p>
<h3 id="动态渲染标签"><a href="#动态渲染标签" class="headerlink" title="动态渲染标签"></a>动态渲染标签</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">example</span> <span class="attr">:tags</span>=<span class="string">&quot;[&#x27;h1&#x27;, &#x27;h2&#x27;, &#x27;h3&#x27;]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个新的Vue组件，组件就是自定义元素，</span></span><br><span class="line"><span class="comment">//第一个参数为组件名，第二个参数为可选的函数部分，第三个参数为template写组件内容</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//表示组件是纯函数式组件，只根据props计算渲染输出，本身不包含不改变仍和state</span></span><br><span class="line">  <span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">tags</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="comment">//自定义验证函数</span></span><br><span class="line">      validator (arr) &#123;<span class="keyword">return</span> !!arr.length &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//渲染函数</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tags = context.props.tags</span><br><span class="line">    <span class="comment">//hyper script，接受第一个参数为tagname标签名</span></span><br><span class="line">    <span class="comment">//第二个参数为数据对象（可选），第三个参数为子节点</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, context.data, tags.map(<span class="function">(<span class="params">tag, index</span>) =&gt;</span> h(tag, index)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="更进一步，动态渲染组件"><a href="#更进一步，动态渲染组件" class="headerlink" title="更进一步，动态渲染组件"></a>更进一步，动态渲染组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">example</span> <span class="attr">:ok</span>=<span class="string">&quot;ok&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;ok = !ok&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> Foo = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">functional</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> Bar = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">functional</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">functional</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">ok</span>: <span class="built_in">Boolean</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//由于函数式组件中没有this，参数需要靠context来传递;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">render</span>: <span class="function">(<span class="params">h, context</span>) =&gt;</span> h(context.props.ok ? Foo : Bar)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">ok</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>context 参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props：提供所有 prop 的对象</span><br><span class="line">children: VNode 子节点的数组</span><br><span class="line">slots: 一个函数，返回了包含所有插槽的对象</span><br><span class="line">scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</span><br><span class="line">data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</span><br><span class="line">parent：对父组件的引用</span><br><span class="line">listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是data.on 的一个别名。</span><br><span class="line">injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p>参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记04</title>
    <url>/2021/12/05/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B004/</url>
    <content><![CDATA[<h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>简单来说，就是一个封装了一个或多个具体功能的组件，它与外界的联系只有简单的props，这样可以保证这个组件与其他组件的耦合度最低，可复用性强，并且不容易污染其他组件。</p>
<h3 id="高阶函数和Mixins"><a href="#高阶函数和Mixins" class="headerlink" title="高阶函数和Mixins"></a>高阶函数和Mixins</h3><p>高阶函数不会污染外部函数，可以在其他组件中被复用。如果确定组件只用在这个项目中，他只处理非常具体的任务，那么使用mixin也是可以的。</p>
<p>由于高阶函数与其他组件耦合度低，也使得它更好的进行测试，可以分别测试增强组件和内部组件，相反，使用Mixin时，你只能测试一个组件。</p>
<p>然而，有时候Mixin比高阶函数更容易掌握，当你使用了太多的高阶组件时，组件的层级会变得复杂，使得难以定位错误，还有搞清楚它们的层级关系，和他们之间的影响。而且，当你多层嵌套时，你需要注意属性需要经过多层传递，嵌套多层组件也会带来一些性能开销，使用mixin的话往往能节省这些开销，所以要视情况使用。</p>
<h3 id="高阶函数的实现"><a href="#高阶函数的实现" class="headerlink" title="高阶函数的实现"></a>高阶函数的实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">smart-avatar</span> <span class="attr">username</span>=<span class="string">&quot;vuejs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">smart-avatar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// mock API</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fetchURL</span> (<span class="params">username, cb</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// hard coded, bonus: exercise: make it fetch from gravatar!</span></span></span><br><span class="line"><span class="javascript">            cb(<span class="string">&#x27;https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="number">500</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> Avatar = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: [<span class="string">&#x27;src&#x27;</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;img :src=&quot;src&quot;&gt;`</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//高阶组件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">withAvatarURL</span> (<span class="params">InnerComponent</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">username</span>: <span class="built_in">String</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            data () &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">url</span>: <span class="string">&#x27;http://via.placeholder.com/200x200&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            created () &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//在这里进行请求</span></span></span><br><span class="line"><span class="javascript">                fetchURL(<span class="built_in">this</span>.username, <span class="function">(<span class="params">url</span>) =&gt;</span> &#123; <span class="built_in">this</span>.url = url &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            render (h) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//渲染一个image标签，第二个参数给src传值</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> h(InnerComponent, &#123; <span class="attr">props</span>: &#123; <span class="attr">src</span>: <span class="built_in">this</span>.url &#125; &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> SmartAvatar = withAvatarURL(Avatar)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123; SmartAvatar &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p> 参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记05</title>
    <url>/2021/12/06/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B005/</url>
    <content><![CDATA[<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><p>在以前，前端没有状态管理的概念。人们试图把MVC这个概念引入到前端中，把状态叫做模型。在很多场景下，这是一中很好的抽象。但是主要问题是我们缺乏一种以声明的方式将模型与渲染结合。</p>
<p>在Vue等前端框架中，优势是状态已经透明到链接的Vue中，当然这也有问题，因为它太容易将状态传播到任何地方，并在任何地方进行修改。随着项目规模的增大，跟踪储存状态的位置立即改变状态的位置会变得越来越困难。</p>
<p>总体而言，很多问题实际上是查明问题的来源并且没有适当的模式让你管理和状态有关的代码。这会导致你的应用变得越来越不可预测。因此，状态管理只是前端开发人员试图找出一种科学方法解决代码如何存放和状态如何管理的问题。从而当问题出现的时候可以更轻松地查明问题。</p>
<p>Flux就是第一个关于单向数据流的想法。</p>
<p>在Vue中一切都很直接，只需要将状态放入组件中即可。实际上，很多简单场景已经够用。状态管理库或状态管理模式不一定在每种情况下都需要。</p>
<h1 id="VueX——Vue的状态管理模式"><a href="#VueX——Vue的状态管理模式" class="headerlink" title="VueX——Vue的状态管理模式"></a>VueX——Vue的状态管理模式</h1><p>如果有多个组件需要访问同一个状态，问题会变得复杂。如果数据是应用中多个组件共享的，那么数据应该提取出来集中管理，而不是放到某个组件中。所以这就提出了使用库或者是一个模式的必要性。</p>
<p>VueX的本质就是Vue的生态系统，当然，历经多次迭代，处理基础概念，他还带来了其他工具，例如模块系统，插件系统。</p>
<h1 id="Props传递"><a href="#Props传递" class="headerlink" title="Props传递"></a>Props传递</h1><p>最基本的状态管理，将数据和视图分离，counter本身只负责接受一些属性和渲染它。这些实例都有共同的父组件。在很多情况下，最坏的情况下你可能需要管理所有状态。在根节点中，并通过Props传递下去。当组件树结构越来越大，这样的弊端会逐渐显现出来，就是需要手动地将props一层层传递下去。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// requirement: a counter component rendered 3 times</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// the component takes the current count via props</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// and a button that increments all 3 counters at once</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//状态</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">Counter</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">count</span>: <span class="built_in">Number</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//视图</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>我们可以将一个对象独立出来作为共享对象作为我们的状态，这样就避免了参数在组件中的传递。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// create a counter component (that doesn&#x27;t take any props)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// all instances of it should share the same count state</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// and a button that increments all counters at the same time</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//定义一个独立状态</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> state = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Counter = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Convert state into reactive object</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//用data返回这个状态，这样Vue就可以给他加上响应式</span></span></span><br><span class="line"><span class="javascript">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> state</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">//渲染函数</span></span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// Proxy the object</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.count)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//注册组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Counter</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      state.count++</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="共享实例"><a href="#共享实例" class="headerlink" title="共享实例"></a>共享实例</h1><p>上一个思路是共享对象，那么我们能不能更近一步，使用实例进行状态共享。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// copy and modify the first exercise to use a Vue instance as</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// a shared store instead.</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//把数据和方法直接在vue中定义，这样他们就会带上响应式</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> state = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.count++</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//渲染组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Counter = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, state.count)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//注册组件和方法</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Counter</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//这里有点绕，用这个函数包装state的函数，使得数据交换被隐藏了起来,会更为安全</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      state.inc()</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h1><p>在上一个例子中我们成功将实例抽象出来进行共享。那么使用Vue实例去封装一些使用方法，最后导出不同的API又该怎么实现呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//定义一个函数，它返回Vue实例</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">&#123; state, mutations &#125;</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//使其具有响应性</span></span></span><br><span class="line"><span class="javascript">      state</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      commit (mutation) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!mutations.hasOwnProperty(mutation)) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown mutation&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">		<span class="comment">//解构mutations获取内部所有方法，给他们赋予状态</span></span></span><br><span class="line"><span class="javascript">        mutations[mutation](state)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> store = createStore(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">mutations</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc (state) &#123;</span></span><br><span class="line"><span class="javascript">      state.count++</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Counter = &#123;</span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, store.state.count)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123; Counter &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      store.commit(<span class="string">&#x27;inc&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="最后一步，模拟VueX"><a href="#最后一步，模拟VueX" class="headerlink" title="最后一步，模拟VueX"></a>最后一步，模拟VueX</h1><p>当完成了前面的练习时，模拟VueX已经呼之欲出了，通过封装一个app函数，在函数内实现挂载节点，共享状态，视图和数据。之后只需要调用这个函数，传入必要参数就可以模拟VueX的行为了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//Vuex简单模拟</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//el:Vue实例挂载的元素节点，model共享的数据，view视图，action动作函数</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">app</span> (<span class="params">&#123; el, model, view, actions &#125;</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> wrappedActions = &#123;&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//给动作函数中的所有函数传入实例的响应式数据，直接传入函数的话，函数内部的值将不具有响应式</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> originalAction = actions[key]</span></span><br><span class="line"><span class="javascript">    wrappedActions[key] = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      vm.model = originalAction(vm.model)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建vue实例对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//挂载节点</span></span></span><br><span class="line"><span class="javascript">    el,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//数据</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//给它带上响应式</span></span></span><br><span class="line"><span class="javascript">      model</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//渲染函数（视图）</span></span></span><br><span class="line"><span class="javascript">    render (h) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> view(h, <span class="built_in">this</span>.model, wrappedActions)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//动作函数</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: actions</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// voila</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//这里就可以进行类似Vue创建实例的方法了</span></span></span><br><span class="line"><span class="javascript">app(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">model</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">actions</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">inc</span>: <span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> (&#123; <span class="attr">count</span>: count + <span class="number">1</span> &#125;),</span></span><br><span class="line"><span class="javascript">    <span class="attr">dec</span>: <span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> (&#123; <span class="attr">count</span>: count - <span class="number">1</span> &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">view</span>: <span class="function">(<span class="params">h, model, actions</span>) =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;&#125;, [</span></span><br><span class="line"><span class="javascript">    model.count, <span class="string">&#x27; &#x27;</span>,</span></span><br><span class="line"><span class="javascript">    h(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: actions.inc &#125;&#125;, <span class="string">&#x27;+&#x27;</span>),</span></span><br><span class="line"><span class="javascript">    h(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: actions.dec &#125;&#125;, <span class="string">&#x27;-&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  ])</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上面的这些例子只是非常简单的vue实例，只是为了演示VueX的实现方式。事实上VueX具有更多的功能。例如VueX有action，getter，模块等概念。当然VueX的核心仍然是基于Vue实例实现响应性。</p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记06</title>
    <url>/2021/12/08/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B006/</url>
    <content><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>vue-router是Vue框架的另一个强大工具。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
<h1 id="哈希路由"><a href="#哈希路由" class="headerlink" title="哈希路由"></a>哈希路由</h1><p>单页应用路由，我们有一些url，想把他们映射到组件。即使组件和这些url有一一对应的关系，并能够实现跳转。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;routeTo(&#x27;#foo&#x27;)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;routeTo(&#x27;#bar&#x27;)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="comment">//一个基于哈希的路由解决方案</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">		浏览器有两种方式进行路由，可以使用哈希，也可以使用HTML5 History API。</span></span></span><br><span class="line"><span class="comment"><span class="javascript">		从某种意义上说，Html5 History APi更好，它支持弹出状态，你的URL看起来会更好，但是他需要某种服务器配置</span></span></span><br><span class="line"><span class="comment"><span class="javascript">		为了更方便的展示，这里使用哈希方式访问。</span></span></span><br><span class="line"><span class="comment"><span class="javascript">	*/</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">url</span>: <span class="string">&#x27;foo&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">foo</span>: &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo&lt;/div&gt;`</span>&#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">bar</span>: &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span>&#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    routeTo (route) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.location.hash = route</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h1><p>完成了基础路由跳转的实现，那么我们能不能把基础路由和组件的对应关系维护起来，形成一张表，这样当我们需要跳转的时候查询路由表再跳转对应组件就好了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;matchedComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/foo&#x27; -&gt; Foo</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/bar&#x27; -&gt; Bar</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/404&#x27; -&gt; NotFound</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//路由表，维护组件和路径的对应关系</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> routeTable = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">foo</span>: Foo,</span></span><br><span class="line"><span class="javascript">  <span class="attr">bar</span>: Bar</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">url</span>: <span class="string">&#x27;foo&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//两种视图实现方式,render渲染函数和html模板</span></span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">	  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span></span><br><span class="line"><span class="javascript">		  h(routeTable[<span class="built_in">this</span>.url] || NotFound),</span></span><br><span class="line"><span class="javascript">		  h(<span class="string">&#x27;a&#x27;</span>,&#123; <span class="attr">attrs</span>:&#123; <span class="attr">href</span>:<span class="string">&#x27;#foo&#x27;</span>&#125;&#125;, <span class="string">&#x27;foo&#x27;</span>),</span></span><br><span class="line"><span class="javascript">		  <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">		  h(<span class="string">&#x27;a&#x27;</span>,&#123; <span class="attr">attrs</span>:&#123; <span class="attr">href</span>:<span class="string">&#x27;#bar&#x27;</span>&#125;&#125;, <span class="string">&#x27;bar&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	  ])</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// computed: &#123;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//   matchedComponent () &#123;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//     return routeTable[this.url] || NotFound</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="正则匹配动态路由"><a href="#正则匹配动态路由" class="headerlink" title="正则匹配动态路由"></a>正则匹配动态路由</h2><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>使用path-to-regexp工具库中的pathToRegexp函数处理url中的地址和参数</p>
<h3 id="动态路由的匹配"><a href="#动态路由的匹配" class="headerlink" title="动态路由的匹配"></a>动态路由的匹配</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/foo/123&#x27; -&gt; foo with id: 123</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/bar&#x27; -&gt; Bar</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/404&#x27; -&gt; NotFound</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// path-to-regexp usage:</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// const regex = pathToRegexp(pattern)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// const match = regex.exec(path)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//根据路由展现的组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Foo = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">props</span>: [<span class="string">&#x27;id&#x27;</span>],</span></span><br><span class="line"><span class="javascript">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo with id: &#123;&#123; id &#125;&#125;&lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//正则捕获的路由表</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> routeTable = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="string">&#x27;/foo/:id&#x27;</span>: Foo,</span></span><br><span class="line"><span class="javascript">  <span class="string">&#x27;/bar&#x27;</span>: Bar</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//编译完成后的数组，就是经过正则匹配后的数组</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> compiledRoutes = []</span></span><br><span class="line"><span class="javascript"><span class="comment">//取出路由表中的所有匹配规则</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.keys(routeTable).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> dynamicSegments = []</span></span><br><span class="line"><span class="javascript">  <span class="comment">//工具库函数pathToRegexp，用于处理url中的地址和参数</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> regex = pathToRegexp(key, dynamicSegments)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> component = routeTable[key]</span></span><br><span class="line"><span class="javascript">  compiledRoutes.push(&#123;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//对应规则映射组件</span></span></span><br><span class="line"><span class="javascript">    component,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//匹配规则</span></span></span><br><span class="line"><span class="javascript">    regex,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//解析动态匹配部分</span></span></span><br><span class="line"><span class="javascript">    dynamicSegments</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">url</span>: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> path = <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.url</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> componentToRender</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> props = &#123;&#125;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//检查是否有匹配上的路由</span></span></span><br><span class="line"><span class="javascript">    compiledRoutes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> match = route.regex.exec(path)</span></span><br><span class="line"><span class="javascript">      componentToRender = NotFound</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//判断匹配是否成功</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (match) &#123;</span></span><br><span class="line"><span class="javascript">        componentToRender = route.component</span></span><br><span class="line"><span class="javascript">        route.dynamicSegments.forEach(<span class="function">(<span class="params">segment, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          props[segment.name] = match[index + <span class="number">1</span>]</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span></span><br><span class="line"><span class="javascript">      h(componentToRender, &#123; props &#125;),</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/123&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 123&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/234&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 234&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#bar&#x27;</span> &#125;&#125;, <span class="string">&#x27;bar&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#garbage&#x27;</span> &#125;&#125;, <span class="string">&#x27;garbage&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    ])</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack学习笔记02</title>
    <url>/2021/12/06/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="Css文件优化操作"><a href="#Css文件优化操作" class="headerlink" title="Css文件优化操作"></a>Css文件优化操作</h1><h2 id="提取css文件"><a href="#提取css文件" class="headerlink" title="提取css文件"></a>提取css文件</h2><ol>
<li><p>默认情况下webpack打包会把css文件压缩到目的js文件中</p>
</li>
<li><p>如果要提取出js中的文件需要加载插件mini-css-extract-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D	//加载依赖</span><br><span class="line"></span><br><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.css$/,</span><br><span class="line">				use:[</span><br><span class="line">					//创建style标签，将样式放入</span><br><span class="line">					// &#x27;style-loader&#x27;,</span><br><span class="line">					//取代&#x27;style-loader&#x27;。作用，提取被打包js中的css代码成为单独的文件</span><br><span class="line">					MiniCssExtractPlugin.loader,</span><br><span class="line">					//将css文件整合到js文件中</span><br><span class="line">					&#x27;css-loader&#x27;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		new MiniCssExtractPlugin(&#123;</span><br><span class="line">			//对输出的css文件重命名</span><br><span class="line">			filename:&#x27;css/built.css&#x27;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="压缩css文件"><a href="#压缩css文件" class="headerlink" title="压缩css文件"></a>压缩css文件</h2><ol>
<li>使用插件提取出来的css文件是按照正常格式输出的，这样的文件比较大，需要压缩</li>
<li>使用optimize-css-assets-webpack-plugin插件进行压缩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i optimize-css-assets-webpack-plugin -D	//加载依赖</span><br><span class="line"></span><br><span class="line">const OptimizeCssAssetsWebpackPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">	plugins:[</span><br><span class="line">		//压缩css</span><br><span class="line">		new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">	],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="css兼容性处理"><a href="#css兼容性处理" class="headerlink" title="css兼容性处理"></a>css兼容性处理</h2><p>1.在开发环境中对兼容性的要求很高，因为不同的浏览器之间css实现方式可能不同，可能会有冲突。这个时候就需要兼容性处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i postcss-preset-env -D	//加载依赖</span><br><span class="line"></span><br><span class="line">// 设置nodejs环境变量</span><br><span class="line">process.env.NODE_ENV = &#x27;development&#x27;;</span><br><span class="line"></span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#x27;css-loader&#x27;,</span><br><span class="line">          /*</span><br><span class="line">            css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env</span><br><span class="line"></span><br><span class="line">            帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</span><br><span class="line"></span><br><span class="line">            &quot;browserslist&quot;: &#123;</span><br><span class="line">              // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span><br><span class="line">              &quot;development&quot;: [</span><br><span class="line">                &quot;last 1 chrome version&quot;,</span><br><span class="line">                &quot;last 1 firefox version&quot;,</span><br><span class="line">                &quot;last 1 safari version&quot;</span><br><span class="line">              ],</span><br><span class="line">              // 生产环境：默认是看生产环境</span><br><span class="line">              &quot;production&quot;: [</span><br><span class="line">                &quot;&gt;0.2%&quot;,</span><br><span class="line">                &quot;not dead&quot;,</span><br><span class="line">                &quot;not op_mini all&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          */</span><br><span class="line">          // 使用loader的默认配置</span><br><span class="line">          // &#x27;postcss-loader&#x27;,</span><br><span class="line">          // 修改loader的配置</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &#x27;postcss&#x27;,</span><br><span class="line">              plugins: () =&gt; [</span><br><span class="line">                // postcss的插件</span><br><span class="line">                require(&#x27;postcss-preset-env&#x27;)()</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack学习笔记01</title>
    <url>/2021/12/05/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h1><p>webpack是一种前端资源构建工具，一个静态的模块打包器（module bundler）。在webpack看来，前端的所有资源文件（js/json/css/img/less）都会作为模块处理。</p>
<p>五个核心概念<br>   Entry<br>     入口：提示webpack以哪一个文件为入口起点打包，分析构建内部依赖图。<br>   Output<br>     输出：提示webpack打包后的资源bundles输出到哪里去，以及如何命名<br>   Loader<br>     Loader：相当于翻译官，让webpack能够取处理哪些非JavaScript文件（webpack本身只能理解JavaScript）<br>   Plugins<br>     插件：可以用于执行范围更广的任务。插件的范围包括从打包优化和压缩，一直到重新定义环境中的变量。<br>   Mode<br>     development<br>       会将DefinePlugin中process.env.NODE_ENV的值设置为development。<br>         能让代码本地调试运行的环境<br>     production<br>       会将DefinePlugin中process.env.NODE_ENV的值设置为production<br>         能让代码优化上线运行的环境</p>
<h1 id="搭建一个基础开发环境"><a href="#搭建一个基础开发环境" class="headerlink" title="搭建一个基础开发环境"></a>搭建一个基础开发环境</h1><p>webpack.config.js<br>   webpack配置文件，webpack开发环境配置基本都在这里写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  开发环境配置：能让代码运行</span><br><span class="line">    运行项目指令：</span><br><span class="line">      webpack 会将打包结果输出出去</span><br><span class="line">      npx webpack-dev-server 只会在内存中编译打包，没有输出</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const &#123; resolve &#125; = require(&#x27;path&#x27;);</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/js/index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;js/built.js&#x27;,</span><br><span class="line">    path: resolve(__dirname, &#x27;build&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // loader的配置</span><br><span class="line">      &#123;</span><br><span class="line">        // 处理less资源</span><br><span class="line">        test: /\.less$/,</span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 处理css资源</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 处理图片资源</span><br><span class="line">        test: /\.(jpg|png|gif)$/,</span><br><span class="line">        loader: &#x27;url-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 8 * 1024,</span><br><span class="line">          name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">          // 关闭es6模块化</span><br><span class="line">          esModule: false,</span><br><span class="line">          outputPath: &#x27;imgs&#x27;</span><br><span class="line">        &#125;，</span><br><span class="line">        type: &#x27;javascript/auto&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 处理html中img资源</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        loader: &#x27;html-loader&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        // 处理其他资源</span><br><span class="line">        exclude: /\.(html|js|css|less|jpg|png|gif)/,</span><br><span class="line">        loader: &#x27;file-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: &#x27;[hash:10].[ext]&#x27;,</span><br><span class="line">          outputPath: &#x27;media&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // plugins的配置</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: &#x27;./src/index.html&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    static: resolve(__dirname, &#x27;build&#x27;),</span><br><span class="line">    //启动gzip压缩</span><br><span class="line">    compress: true,</span><br><span class="line">    port: 3000,</span><br><span class="line">    open: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>webpack5踩得坑<br>   在devServer配置中出口文件配置要使用static而不是contextBase<br>   使用devServer之后打包命令在Webpack5要用npx webpack serve而不是npx webpack-dev-server<br>   处理图片资源的时候要在rules的具体规则中加一句type: ‘javascript/auto’来阻止Webpack5自动打包</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记01快速上手、选择器</title>
    <url>/2021/12/25/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1、css优势："><a href="#1、css优势：" class="headerlink" title="1、css优势："></a>1、css优势：</h2><ul>
<li>内容和表现分离</li>
<li>可以实现复用，网页结构表现统一</li>
<li>样式十分丰富</li>
<li>建议使用独立于html的css文件</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ul>
<h2 id="2、css的3中导入方式："><a href="#2、css的3中导入方式：" class="headerlink" title="2、css的3中导入方式："></a>2、css的3中导入方式：</h2><ol>
<li><p>内联样式</p>
<ul>
<li>写在本网页中的style标签中</li>
</ul>
</li>
<li><p>外联样式</p>
<ul>
<li>写在外部文件中，通过link标签引入（推荐，因为便于维护和管理）</li>
</ul>
</li>
<li><p>行内样式</p>
<ul>
<li>写在html标签的内部，用style=“”写</li>
</ul>
<p>优先级排序</p>
<p>行内&gt;内联&gt;外联</p>
</li>
<li><p>拓展：外联样式的两种写法</p>
<ol>
<li><p>连接式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 连接式 --&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/index.css&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>导入式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入式 --&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="keyword">@import</span> url(<span class="string">&quot;./css/index.css&quot;</span>);</span></span></span><br><span class="line"><span class="css"><span class="xml">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>两者区别</p>
<ul>
<li>link标签是html标签，只能放在html中使用。</li>
<li>@import在html中使用的时候外面要加style标签，但是也可以直接在css文件中使用用以引入其他css文件</li>
<li>本质上区别不大，推荐使用link</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h2><blockquote>
<p>作用：选择页面中的某一个元素</p>
</blockquote>
<ol>
<li>标签选择器</li>
<li>类选择器 class（可多对一）</li>
<li>id选择器（仅一对一，权重高）</li>
</ol>
<p>优先级：id&gt;class&lt;标签</p>
<h2 id="3-1、层次选择器"><a href="#3-1、层次选择器" class="headerlink" title="3.1、层次选择器"></a>3.1、层次选择器</h2><ol>
<li><p>后代选择器： 在某个元素后面</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*后代选择器 */</span></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子选择器，一代，儿子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 子选择器 */</span></span><br><span class="line"><span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>相邻兄弟选择器（只有一个，而且是向下相邻）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 相邻兄弟选择器 */</span></span><br><span class="line"><span class="selector-class">.p1</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通用兄弟选择器（下面所有统一层次的选择器）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通用选择器 */</span></span><br><span class="line"><span class="selector-class">.p1</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: chartreuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-2、结构伪类选择器"><a href="#3-2、结构伪类选择器" class="headerlink" title="3.2、结构伪类选择器"></a>3.2、结构伪类选择器</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ul的第一个子元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ul的最后一个子元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中p1 </span></span><br><span class="line"><span class="comment">选择当前p元素的父级元素，选中父级元素的第nth个，并且是当前元素的同类元素才生效*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#008000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择当前p元素的父级元素，选中父级元素的第nth个子类同类元素*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类，鼠标悬停 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、属性选择器"><a href="#3-3、属性选择器" class="headerlink" title="3.3、属性选择器"></a>3.3、属性选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-class">.demo</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">				<span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">				<span class="attribute">color</span>: aliceblue;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">				<span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">50px</span> Arial;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 存在id的元素，把他选中 a[]&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">				属性名，属性名 = 属性值(正则)</span></span></span><br><span class="line"><span class="comment"><span class="css">				= 为绝对等于</span></span></span><br><span class="line"><span class="comment"><span class="css">				*= 为包含此元素 </span></span></span><br><span class="line"><span class="comment"><span class="css">				^= 为以此开头的</span></span></span><br><span class="line"><span class="comment"><span class="css">				￥= 为以此结尾的</span></span></span><br><span class="line"><span class="comment"><span class="css">							*/</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[id]</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">color</span>: <span class="number">#0000FF</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[id=first]</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[class*=<span class="string">&quot;links&quot;</span>]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#FFE4C4</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 选中herf中以http开头的元素 */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[href^=http]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#FF0000</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[href$=pdf]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item active&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.png&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.jpg&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/a.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abcd.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item last&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>= 为绝对等于</li>
<li>*= 为包含此元素 </li>
<li>^= 为以此开头的</li>
<li>￥= 为以此结尾的</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记02样式</title>
    <url>/2021/12/26/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="美化网页元素"><a href="#美化网页元素" class="headerlink" title="美化网页元素"></a>美化网页元素</h1><ol>
<li><p>为什么要美化网页</p>
<ol>
<li>有效传递页面信息</li>
<li>美化网页、页面漂亮、才能吸引用户</li>
<li>凸显页面的主题</li>
<li>提高用户体验</li>
</ol>
</li>
<li><p>span</p>
<p>约定俗成的标记重点语句用的标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">		<span class="attribute">color</span>: <span class="number">#FF0000</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">	&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>word!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>字体样式</p>
<ul>
<li>font-family:”Arial Black”(字体)</li>
<li>font-size（字体大小）</li>
<li>font-weight:bolder(字体粗细)</li>
</ul>
</li>
<li><p>文本样式</p>
<ol>
<li>颜色    color    rgb    rgba</li>
<li>文本对齐方式   text-align = center</li>
<li>首行缩进 text-indent:2em</li>
<li>下划线（装饰） text-decoration</li>
<li>行高 line-height</li>
<li>文本图片水平对齐 vertical-align:middle</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">		<span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 居中 */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.p1</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 首行缩进 */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">text-indent</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.p2</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			<span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 行高，可以用于上下居中 */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 划线（上下中） */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">text-decoration</span>: line-through;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="comment">/* 水平对齐	参照物	a,b */</span></span></span><br><span class="line"><span class="css">		<span class="selector-tag">img</span>,<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>故事简介<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span></span><br><span class="line">		从故事中可看出，JOJO每一代故事发生的背景舞台是不同的。</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">			作为主角的新一代JOJO，拥有诸多“萌点”。因帽子上的手型标志被网友指为平行世界的空条承太郎。赤身裸体从地底爬出的出场方式也十分“惊艳”。以异于常人的生理特点而被人称为“四蛋男”。现名为“东方定助”，事实上是吉良吉影与空条仗世文的融合。</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>jojo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>超链接伪类</p>
<p>一般情况下，使用:hover或:active足够了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;style&gt;</span><br><span class="line">		<span class="comment">/* 默认颜色 */</span></span><br><span class="line">		<span class="selector-tag">a</span>&#123;</span><br><span class="line">			<span class="attribute">text-decoration</span>: none;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 鼠标悬停 */</span></span><br><span class="line">		<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#7FFF00</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 鼠标点击 */</span></span><br><span class="line">		<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">			<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-id">#price</span>&#123;</span><br><span class="line">			<span class="attribute">text-shadow</span>: <span class="number">#7FFF00</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">3px</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">	&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">a</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;image<span class="selector-class">.png</span>&quot; /&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;ex&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;yue&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">p</span> id=&quot;price&quot;&gt;</span><br><span class="line">			￥<span class="number">99</span></span><br><span class="line">		&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">	&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2021/12/04/hello-world/</url>
    <content><![CDATA[<h2 id="博客搭建指南"><a href="#博客搭建指南" class="headerlink" title="博客搭建指南"></a>博客搭建指南</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodejs</span><br></pre></td></tr></table></figure>

<p>安装软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure>

<p>准备一个github账号</p>
<h3 id="第一步：绑定github（2021-8-14之后github取消了账号密码登录，只能使用shh登录了"><a href="#第一步：绑定github（2021-8-14之后github取消了账号密码登录，只能使用shh登录了" class="headerlink" title="第一步：绑定github（2021/8/14之后github取消了账号密码登录，只能使用shh登录了)"></a>第一步：绑定github（2021/8/14之后github取消了账号密码登录，只能使用shh登录了)</h3><h3 id="第二步：安装hexo"><a href="#第二步：安装hexo" class="headerlink" title="第二步：安装hexo"></a>第二步：安装hexo</h3><p>首先在D盘建立一个文件夹 Blog，点开 Blog 文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入 hexo init 命令初始化博客；</p>
<p>然后输入 hexo g 静态部署；</p>
<p>这时网页已经部署完成，输入 hexo s 命令可以查看；</p>
<h3 id="第三步：将Hexo部署到GitHub"><a href="#第三步：将Hexo部署到GitHub" class="headerlink" title="第三步：将Hexo部署到GitHub"></a>第三步：将Hexo部署到GitHub</h3><p>现在回到我们的 Blog 文件夹，用笔记本打开 _config.yml 文件，在最后输入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:GiorunoGiovanna/GiorunoGiovana.github.io.git  <span class="comment">#你的仓库地址(注意，由于GitHub登录规则的改变，最好使用git地址而不是http)</span></span><br><span class="line">  branch: master	<span class="comment">#要和你项目的分支名称一致</span></span><br></pre></td></tr></table></figure>

<p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件</p>
<p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后分别输入以下三条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>完成以后就可以访问你的博客啦！</p>
<p>踩坑：</p>
<h4 id="1-不知道是不是因为登录方式的改变，我一开始在deploy中rep地址使用的是http地址，一直报错说部署失败。"><a href="#1-不知道是不是因为登录方式的改变，我一开始在deploy中rep地址使用的是http地址，一直报错说部署失败。" class="headerlink" title="1.不知道是不是因为登录方式的改变，我一开始在deploy中rep地址使用的是http地址，一直报错说部署失败。"></a>1.不知道是不是因为登录方式的改变，我一开始在deploy中rep地址使用的是http地址，一直报错说部署失败。</h4><h5 id="把http地址改成shh的地址之后就可以正常部署了。"><a href="#把http地址改成shh的地址之后就可以正常部署了。" class="headerlink" title="把http地址改成shh的地址之后就可以正常部署了。"></a>把http地址改成shh的地址之后就可以正常部署了。</h5><h4 id="2-部署到github上面之后开心地打开后发现没有样式，我直接？"><a href="#2-部署到github上面之后开心地打开后发现没有样式，我直接？" class="headerlink" title="2.部署到github上面之后开心地打开后发现没有样式，我直接？"></a>2.部署到github上面之后开心地打开后发现没有样式，我直接？</h4><h5 id="上网查找后发现在deploy中把url：那一行改一下就行了"><a href="#上网查找后发现在deploy中把url：那一行改一下就行了" class="headerlink" title="上网查找后发现在deploy中把url：那一行改一下就行了"></a>上网查找后发现在deploy中把url：那一行改一下就行了</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://giorunogiovanna.github.io/GiorunoGiovana.github.io	#你的博客网址</span><br><span class="line">root: /GiorunoGiovana.github.io/	#你的博客网址最后一段后缀</span><br></pre></td></tr></table></figure>

<h4 id="3-最近上传的时候总是报错说链接已经重置，找了好久没发现问题，后来发现是网络不好"><a href="#3-最近上传的时候总是报错说链接已经重置，找了好久没发现问题，后来发现是网络不好" class="headerlink" title="3.最近上传的时候总是报错说链接已经重置，找了好久没发现问题，后来发现是网络不好"></a>3.最近上传的时候总是报错说链接已经重置，找了好久没发现问题，后来发现是网络不好</h4><p>本博客只是用于学习笔记和踩坑记录，具体操作可以看大神的<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></p>
]]></content>
  </entry>
  <entry>
    <title>js事件冒泡和捕获</title>
    <url>/2022/03/19/js%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<h1 id="javaScript事件"><a href="#javaScript事件" class="headerlink" title="javaScript事件"></a>javaScript事件</h1><h2 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h2><p>事件是文档和浏览器窗口中发生交互的瞬间，当我们对web页面进行某些类型的交互的时候，就发生了事件。</p>
<h2 id="什么是事件流？"><a href="#什么是事件流？" class="headerlink" title="什么是事件流？"></a>什么是事件流？</h2><p>事件流是从页面中接收事件的顺序，有IE提出的事件冒泡流，也有网景提出的事件捕获流。</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onclick</span>=<span class="string">&quot;bodyClick()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;divClick()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;btn()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;p()&quot;</span>&gt;</span>点击冒泡<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;p标签被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">btn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;button被点击&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">divClick</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;div被点击&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">bodyClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;body被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件发生顺序</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319094655872.png" alt="image-20220319094655872"></p>
<p>可以看出冒泡流就是事件由最底层的文档先触发，再一步步向上触发，就像是冒泡一样从水底到水面。<strong>p=&gt;button=&gt;div=&gt;body</strong></p>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击捕获<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oP=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oB=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oD=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oBody=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oP.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;p标签被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oB.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;button被点击&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oD.addEventListener(<span class="string">&#x27;click&#x27;</span>,  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;div被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oBody.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;body被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件发生顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319095041637.png" alt="image-20220319095041637"></p>
<p>可以看出，事件捕获是从最顶层的文档流开始向下触发，直到底层。</p>
<p><strong>body=&gt;div=&gt;button=&gt;p</strong></p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定事件流为三个阶段：“事件捕获阶段”，“处于目标阶段”，“事件冒泡阶段”。首先发生的事件捕获为获取事件提供机会，然后是事件的目标接受事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>DOM事件流<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="javascript">    btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;div 处于目标阶段&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;event bubble 事件冒泡&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">false</span>);<span class="comment">//最后的这个布尔值决定此事件是在捕获阶段触发（true）还是冒泡阶段触发（false）</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;event catch 事件捕获&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件触发顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319100130996.png" alt="image-20220319100130996"></p>
<p>可以得出DOM事件流就是事件捕获和事件冒泡的结合</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1174211-20171201225153933-1205737719.png" alt="1174211-20171201225153933-1205737719"></p>
<p>关于DOM2级事件处理程序：</p>
<p>DOM 2级事件定义了两个方法：用于添加事件（addEventListener()）和删除事件（removeEventListiener()）</p>
<p>所有DOM节点都包含这两个事件，同时接收三个参数</p>
<ol>
<li>要处理的事件方式（click，mouseover，dbclick）</li>
<li>事件处理的函数，可以是命名函数，也可以是匿名函数，但是匿名函数无法被删除</li>
<li>一个布尔值，决定是在事件捕获阶段触发（true）还是在事件冒泡阶段触发（false），默认为false</li>
</ol>
<p>使用DOM2级事件的好处是可以定义多个触发函数，可以在不同阶段触发，也可以决定它们的顺序。</p>
<p>DOM2级事件和DOM0级事件的对比</p>
<p>DOM2级事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">         <span class="comment">//第一个事件</span></span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,foo,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;我是按钮&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//第二个事件</span></span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,newFoo,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">newFoo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;我是新按钮&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319101149877.png" alt="image-20220319101149877"></p>
<p>DOM0级事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;foo()&quot;</span>  <span class="attr">onclick</span>=<span class="string">&quot;newFoo()&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="number">2</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">newFoo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="number">9</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319101256058.png" alt="image-20220319101256058"></p>
<p>可以看出，DOM0级事件重复定义的话是会只执行最早定义的，其他的会被忽略，而DOM2级事件不会覆盖，而是按照一定顺序执行。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记01Html中的JavaScript</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001Html%E4%B8%AD%E7%9A%84JavaScript/</url>
    <content><![CDATA[<h1 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h1><p>script元素是用于引入JavaScript的html元素。</p>
<p>1.可选属性有：</p>
<p>async：</p>
<p>​    表示应该立即下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效（不保证顺序执行）</p>
<p>defer：</p>
<p>​    表示脚本可以延迟到文档完全被解析后再执行。只对外部脚本有效。</p>
<p>2.scrpit标签中引用外部脚本的时候不受浏览器同源策略限制，就是可以跨域（jsonp方案的原理）</p>
<p>3.在script元素中的代码被计算完成之前，在这段代码之后的页面的其余内容不会被加载，也不会被显示。</p>
<p>4.不该在已经引用了外部脚本的script标签中包含JavaScript代码，会被忽略。</p>
<h3 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h3><p>1.放在head标签内</p>
<p>意味着必须把所有JavaScript代码都下载，解析和解释完成后才能渲染画面。（可能导致白屏幕时间过长）</p>
<p>2.放在body标签中页面内容的后面（通常做法）</p>
<p>会优先加载内容页面，再加载脚本。（白屏时间短，用户体验好）</p>
<h3 id="行内代码与外部文件"><a href="#行内代码与外部文件" class="headerlink" title="行内代码与外部文件"></a>行内代码与外部文件</h3><p>1.推荐将js代码放在外部文件，然后按需引入</p>
<p>​    理由：1.可维护性强，js代码过于分散维护难度会非常高，放到统一的文件下可维护性更高。</p>
<p>​                2.缓存性能，如果多个页面用到同一个脚本，只加载一次就够了。</p>
<p>​                3.外部脚本语法在HTML和XHTML中是一致的。</p>
<h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><p>使用DOM API（不太支持，就不展开了，红宝书P15）</p>
<h3 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a>noscript元素</h3><p>用于指定在浏览器不支持脚本时候显示的内容。如果浏览器支持js脚本，则此元素内的任何内容都不会被渲染。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记03变量、作用域与内存</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h1><ol>
<li>原始值：最简单的数据</li>
<li>引用值：由多个值构成的对象</li>
<li>JavaScript不允许直接访问内存的位置，在操作对象的时候实际操作的时对该对象的引用，为此，保存引用值的变量是按引用访问的</li>
</ol>
<h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><ol>
<li>原始值：原始值不能拥有属性，但尝试给它添加属性不会报错</li>
<li>引用值：引用值可以动态添加属性</li>
<li>原始值的初始化：<ol>
<li>只使用原始字面量形式，如var a = 1</li>
<li>使用new初始化，这会创建一个object类型的实例，但是行为上类似于原始值</li>
</ol>
</li>
</ol>
<h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><ol>
<li><p>原始值：复制原始值得到的是一个相互独立的副本</p>
</li>
<li><p>引用值：引用值持有的其实是对堆内存中实际值的一个引用，复制引用值实际上是复制了指向堆内存的指针，所以原始引用值和复制的引用值是会互相影响的。（浅复制）</p>
</li>
<li><p>深复制：复制一份独立的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//借用JSON方法：stringify和parse实现深复制</span><br><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj),</span><br><span class="line">        objClone = JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;    </span><br><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><ol>
<li>ECMAScript中所有函数都是按值传递的。</li>
<li>原始值：和复制值行为一样</li>
<li>引用值：注意！传递参数的时候不是按引用传递，而是按值传递。<ol>
<li>区别在于，如果你在函数内重新定义传入的参数，修改它的属性。</li>
<li>如果是按引用传递，在函数外查看参数的属性应该是会变的。</li>
<li>但是按值传递，函数外的对象属性不会发生变化，对对象的引用没有发生改变。</li>
</ol>
</li>
</ol>
<h2 id="如何确定类型"><a href="#如何确定类型" class="headerlink" title="如何确定类型"></a>如何确定类型</h2><ol>
<li>原始值用typeof确定类型比较好</li>
<li>引用值使用instanceof操作符确定类型，例如：person instanceof Object</li>
</ol>
<h2 id="表示符查找"><a href="#表示符查找" class="headerlink" title="表示符查找"></a>表示符查找</h2><p>当在特定上下文中为读取或写入而引用一个标识符的时候，必须通过搜索确定这个标识符表示什么。搜索从作用域顶端开始，一直查找到全局上下文对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记02语言基础</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol>
<li><h6 id="JavaScript中的一切都区分大小写"><a href="#JavaScript中的一切都区分大小写" class="headerlink" title="JavaScript中的一切都区分大小写"></a>JavaScript中的一切都区分大小写</h6></li>
<li><h6 id="变量标识符"><a href="#变量标识符" class="headerlink" title="变量标识符"></a>变量标识符</h6><ol>
<li>第一个字符必须是字母、下划线或美元符号</li>
<li>后面的字符必须是字母、下划线、美元符号或者数字</li>
<li>惯例上按照驼峰命名法</li>
</ol>
</li>
<li><h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><ol>
<li>单行注释使用    //</li>
<li>多行注释使用/*    */</li>
</ol>
</li>
<li><h6 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h6><ol>
<li>代码块{}</li>
<li>最好在控制语句中使用代码块</li>
</ol>
</li>
</ol>
<h1 id="Var关键字"><a href="#Var关键字" class="headerlink" title="Var关键字"></a>Var关键字</h1><ol>
<li><h6 id="var声明提升"><a href="#var声明提升" class="headerlink" title="var声明提升"></a>var声明提升</h6><ol>
<li>使用var声明变量还会自动提升到函数作用域顶部</li>
<li>也就是说可以先使用变量再声明它</li>
</ol>
</li>
<li><h6 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h6><ol>
<li>在函数内定义var变量，会成为函数中的局部变量</li>
<li>使用var声明，变量会自动被添加到最近的上下文</li>
<li>在函数内省略var关键字，如name=“gyp”。会创建全局变量（不推荐）</li>
</ol>
</li>
</ol>
<h1 id="Let关键字"><a href="#Let关键字" class="headerlink" title="Let关键字"></a>Let关键字</h1><ol>
<li><h6 id="和var的区别"><a href="#和var的区别" class="headerlink" title="和var的区别"></a>和var的区别</h6><ol>
<li>使用let在全局作用域中声明变量不会成为window对象的属性，而var会</li>
<li>var声明的是函数作用域，let声明的是块作用域</li>
<li>let声明不会提升，如果在定义let之前使用它会出现临时性死区</li>
<li>let在同一作用域下不能被声明两次</li>
</ol>
</li>
<li><h6 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h6><ol>
<li>在let之前，使用var定义for循环的迭代变量会渗透到循环体外。</li>
<li>使用let做for循环的迭代变量不会泄露，因为是块级作用域。</li>
<li>之前使用var，在循环中var变量中始终都是头一个变量，所以在循环体内访问var变量始终都是同一个值</li>
<li>使用let，每个循环都会创建新的迭代变量，所以在循环体内访问let变量是不同的。</li>
</ol>
</li>
</ol>
<h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><ol>
<li>与let基本一致，唯一一个重要区别是const必须在命名变量时赋值，且在后续使用中无法修改其值（定义常量）。</li>
<li>只应用到顶级原语或者对象，如果为const初始化一个对象，那么虽然无法改变const的引用值，但是对象内的键值是可以更改的</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><ol>
<li>对一个值使用typeof返回值</li>
<li>undefined，尚未初始化的变量——undefined</li>
<li>boolean——boolean</li>
<li>string——string</li>
<li>number——number</li>
<li>object，array，null——object</li>
<li>function——function</li>
<li>symbol——symbol</li>
</ol>
<h2 id="undefined（假值）"><a href="#undefined（假值）" class="headerlink" title="undefined（假值）"></a>undefined（假值）</h2><ol>
<li>默认情况下，任何未经初始化的变量都会取得undefined</li>
<li>undefined和未定义是有区别的，但是用typeof调用的话，得到的值都是undefined</li>
</ol>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><ol>
<li>从逻辑上讲，null表示一个空对象指针，这也是给typeof传一个null会返回“object”的原因</li>
<li>undefined是由null派生而来的，所以null==undefined为true</li>
<li>如果确定一个变量将来要保存对象，但是现在没有对象可以保存，最好用null填充它，这样以后查看它是否保存了对象，只要看他是不是null就行了</li>
</ol>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><ol>
<li><p>布尔值只有两个字面值，true和false（区分大小写）</p>
</li>
<li><p>不同类型转换为布尔值转换规则</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>非空字符串</td>
<td>“”（空字符串）</td>
</tr>
<tr>
<td>number</td>
<td>非零数值</td>
<td>0，NaN</td>
</tr>
<tr>
<td>object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>undefined</td>
<td>无</td>
<td>undefined</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Number（使用IEEE754格式）"><a href="#Number（使用IEEE754格式）" class="headerlink" title="Number（使用IEEE754格式）"></a>Number（使用IEEE754格式）</h2><ol>
<li><h6 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h6><ol>
<li>默认为十进制</li>
<li>以0开头会被认为是八进制，但不能超出表示范围，否则会被认为是十进制（例如0175被承认为八进制，089不被承认为八进制）</li>
<li>以Ox（区分大小写）开头会被认为是16进制</li>
<li>在数学操作中都被视为十进制</li>
</ol>
</li>
<li><h6 id="浮点值"><a href="#浮点值" class="headerlink" title="浮点值"></a>浮点值</h6><ol>
<li>要定义浮点值，数值必须包含小数点，小数点至少一位数字</li>
<li>浮点值空间是整数值两倍</li>
<li>浮点值精度为17位小数，但是不如整数精确（IEEE754格式导致的问题）</li>
</ol>
</li>
<li><h6 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h6><ol>
<li>number（）<ol>
<li>布尔值，true为1，false为0</li>
<li>数值，直接返回</li>
<li>null，返回0</li>
<li>undefined，返回NaN</li>
<li>字符串<ol>
<li>如果字符串只包含数值字符，包括前面+-符号，转换为十进制数。（忽略前导0，即不能转换八进制）</li>
<li>如果字符串包含有效浮点格式如“1.1”，转换为对应浮点数</li>
<li>如果字符串包含有效十六进制格式，则会转换为相应的十六进制的十进制格式。</li>
<li>其余情况，返回NaN</li>
</ol>
</li>
<li>对象，调用valueOf（）方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用toString（）方法，再按字符串规则转换。</li>
</ol>
</li>
<li>parseInt（）在需要得到整数时优先使用<ol>
<li>从第一个非空格字符开始转换。如果第一个字符不是数值，+，-符号，则立即返回NaN。所以空字符串也返回NaN。接下来会持续检测，返回一个整数。</li>
<li>可以识别不同的进制格式，包括十六进制，八进制。</li>
<li>可以接受第二个参数，作为底数，进制数，如parseInt（“AF”，16）//175</li>
</ol>
</li>
<li>parseFloat（）<ol>
<li>跟parseInt（）类似，不过会识别浮点数，并且不能识别十进制以外的进制。</li>
</ol>
</li>
</ol>
</li>
<li><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><ol>
<li>表示本来要返回数值的操作失败了</li>
<li>任何涉及NaN操作始终返回NaN</li>
<li>NaN不等于任何值，包括它本身</li>
</ol>
</li>
</ol>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ol>
<li><h6 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h6><table>
<thead>
<tr>
<th>\n</th>
<th>换行</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制表示的字符</td>
</tr>
<tr>
<td>\unnn</td>
<td>以十六进制表示的Unicode字符</td>
</tr>
</tbody></table>
</li>
<li><h6 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h6><ol>
<li>模板字面量会保持反引号内的空格</li>
</ol>
</li>
<li><h6 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h6><ol>
<li>从技术上来讲，模板字面量不是字符串，是一种特殊的JavaScript语法</li>
<li>通过在${}中使用js表达式实现</li>
</ol>
</li>
<li><h6 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h6><ol>
<li>toString（）<ol>
<li>可用于数组、布尔值、对象和字符串值；null和undefined没有toString方法</li>
<li>当转换为数值类型时，可以接受一个参数作为底数，就是作为几进制输出</li>
</ol>
</li>
<li>String（）<ol>
<li>当传入参数为null或undefined时，返回“null”或“undefined”</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ol>
<li>对象其实就是一组数据和功能的集合</li>
<li>几个重要的属性和方法<ol>
<li>constrictor:用于创建当前对象的函数。</li>
<li>hasOwnProperty(propertyName):用于判断当前对象实例（不是原型）上是否存在给定属性。</li>
<li>defineProperty(obj，key，{…}):用于给对象的属性添加方法，Vue响应性原理。</li>
<li>valueOf():返回对象对应的数值，字符串，或布尔值</li>
</ol>
</li>
</ol>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><ol>
<li><h6 id=""><a href="#" class="headerlink" title="++"></a>++</h6><ol>
<li>在变量前如++a，在语句求值之前改变，+1</li>
<li>在变量后如a++，在语句求值之后改变，+1</li>
</ol>
</li>
<li><h6 id="–（同上）"><a href="#–（同上）" class="headerlink" title="–（同上）"></a>–（同上）</h6></li>
<li><h6 id="一元加和减"><a href="#一元加和减" class="headerlink" title="一元加和减"></a>一元加和减</h6><ol>
<li>和数学上用途一致</li>
<li>隐式转换加到不同类型中会试图将他们转换为数值类型，如+a</li>
</ol>
</li>
</ol>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><ol>
<li>按位非（~）作用是返回数值的一补数，最终结果时对数值取反再减一</li>
<li>按位与（&amp;）本质上是两个数的每一位对齐</li>
<li>按位或（|）有一则一，没一则零</li>
<li>有符号右移（&gt;&gt;&gt;）所有数值向右移指定位数，符号位也移动</li>
<li>有符号左移（&lt;&lt;&lt;）所有数值向左移指定位数，符号位不变</li>
<li>左移（&lt;&lt;）所有数值向左移指定位数，符号位不变</li>
</ol>
<h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><ol>
<li><h6 id="逻辑非（-）"><a href="#逻辑非（-）" class="headerlink" title="逻辑非（!）"></a>逻辑非（!）</h6></li>
</ol>
<table>
<thead>
<tr>
<th>操作数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>false</td>
</tr>
<tr>
<td>空字符串</td>
<td>true</td>
</tr>
<tr>
<td>非空字符串</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>true</td>
</tr>
<tr>
<td>非0数值</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>true</td>
</tr>
<tr>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>undefined</td>
<td>true</td>
</tr>
</tbody></table>
<p>双非！！，可以求出变量真正对应的布尔值</p>
<h6 id="2-逻辑与（-amp-amp-）"><a href="#2-逻辑与（-amp-amp-）" class="headerlink" title="2.逻辑与（&amp;&amp;）"></a>2.逻辑与（&amp;&amp;）</h6><table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>任意</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>布尔值为true</td>
<td>对象</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>对象</td>
<td>对象</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>null</td>
<td>——</td>
<td>null</td>
</tr>
<tr>
<td>NaN</td>
<td>——</td>
<td>NaN</td>
</tr>
<tr>
<td>undefined</td>
<td>——</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>短路操作符，第一个操作数为false，则第二个操作数被忽略</p>
<h6 id="3-逻辑或（-）"><a href="#3-逻辑或（-）" class="headerlink" title="3.逻辑或（||）"></a>3.逻辑或（||）</h6><table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>任意</td>
<td>返回第一个操作数</td>
</tr>
<tr>
<td>布尔值为false</td>
<td>对象</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>对象</td>
<td>对象</td>
<td>返回第一个操作数</td>
</tr>
<tr>
<td>null</td>
<td>——</td>
<td>null</td>
</tr>
<tr>
<td>NaN</td>
<td>——</td>
<td>NaN</td>
</tr>
<tr>
<td>undefined</td>
<td>——</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>短路操作符，第一个操作数为true，则第二个操作数被忽略。</p>
<h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>乘法（*），除法（/），取模（%）</p>
<h2 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h2><ol>
<li>3**2等价于3的平方</li>
<li>a**等价于a的平方</li>
</ol>
<h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><ol>
<li><h6 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h6><ol>
<li><p>优先级最高：<br>如果有任意一个操作数为字符串，则将所有操作数转换为字符串再拼接。</p>
<p>Infinity加-Infinity=NaN</p>
</li>
</ol>
</li>
<li><h6 id="减法操作符"><a href="#减法操作符" class="headerlink" title="减法操作符"></a>减法操作符</h6></li>
</ol>
<h2 id="比较操作符-gt-lt-lt-gt"><a href="#比较操作符-gt-lt-lt-gt" class="headerlink" title="比较操作符(&gt;,&lt;,&lt;=,&gt;=)"></a>比较操作符(&gt;,&lt;,&lt;=,&gt;=)</h2><ol>
<li>非数值转换为数值比较</li>
<li>都是字符串，则逐个比较字符串对应字符编码</li>
</ol>
<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><ol>
<li>等于和不等于(==/!==)<ol>
<li>两个操作数会先进行强制类型转换</li>
<li>null==undefined(true)</li>
</ol>
</li>
<li>全等和不全等(===/!==)<ol>
<li>不进行强制类型转换，比较值和类型</li>
<li>null===undefined（false）</li>
</ol>
</li>
</ol>
<h2 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h2><ol>
<li><h6 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h6><ol>
<li>格式如a?b:c，a为真则执行b，为假则执行c</li>
<li>可以嵌套如:a?(b?c:d):e</li>
<li>方式简洁优雅，但是不便于阅读</li>
</ol>
</li>
<li><h6 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符(=)"></a>赋值操作符(=)</h6><ol>
<li>将右边的值赋值给左边</li>
<li>乘后赋值（*=）<br>除后赋值（/=）<br>取模后赋值（%=）<br>加后赋值（+=）<br>减后赋值（-=）<br>左移后赋值（&lt;&lt;=）</li>
</ol>
</li>
<li><h6 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h6><ol>
<li>可以用来在一条语句中执行多个操作，如:let num = 1，num1 = 2</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记03变量、作用域与内存</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="RegExp正则"><a href="#RegExp正则" class="headerlink" title="RegExp正则"></a>RegExp正则</h1><ol>
<li><p>支持直接使用let patten = /a/g的方式定义正则表达式</p>
</li>
<li><p>支持使用构造函数let patten = new RegExp(“a”,”i”)定义正则表达式，第一个参数使匹配字符串，第二个参数使模式选择。</p>
<p>注意：因为在构造函数中参数使字符串，所以某些情况下需要二次转义，可以看作每一个”\“前面都要加多一个”\”来转义它本身，才可以正常使用。</p>
</li>
<li><p>模式：</p>
<ol>
<li>i：忽略大小写</li>
<li>g：全局查找</li>
<li>m：多行查找</li>
</ol>
</li>
<li><p>实例方法</p>
<ol>
<li><p>主要方法使exec()</p>
<ol>
<li><p>如果找到了匹配项，则返包含第一个匹配信息的数组。</p>
<p>注意：返回的数组虽然是Array实例，但是包含两个额外的属性，index和input，index是字符串匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素则是与表达式中捕获组匹配的字符串。</p>
</li>
<li><p>没找到则返回null</p>
</li>
<li><p>如果模式设置了全局标记（g），则每次调用exec（）都会在字符串中向前搜索下一个匹配项。</p>
</li>
<li><p>如果没有设置全局标记，则每次都只会返回第一个匹配字符串。</p>
</li>
<li><p>如果设置了黏附标记y，则每一次调用exec（）就只会在lastIndex的位置上寻找匹配项。会覆盖全局标记。通过向前设置lastindex可以查找下一个匹配项。</p>
</li>
</ol>
</li>
<li><p>还有一个是text（）</p>
<ol>
<li>只检测是否匹配，不关心为什么。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="原始包装类型"><a href="#原始包装类型" class="headerlink" title="原始包装类型"></a>原始包装类型</h2><ol>
<li>每当用到某个原始值的方法或者属性时，后台都会创建一个相应的原始值包装数据类型，从而暴露出操作原始值的各种方法。</li>
</ol>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><ol>
<li>要创建一个Boolean对象，就要使用构造函数并传入true或者false</li>
<li>Boolean实例会重写valueOf（）方法，返回一个原始值true或者false</li>
<li>创建一个值为false的Boolean对象，在一个布尔表达式中用&amp;&amp;将这个对象和一个原始值true结合起来，返回的结果是true，因为Boolean对象在被转换的时候被当成了对象，而所有对象转化为Boolean值时都为true。</li>
</ol>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ol>
<li>创建方法直接使用数值赋值即可</li>
<li>实例方法<ol>
<li>toFixed()可以将数值格式化为字符串，接受参数为这个字符串有多少位小数。</li>
<li>toExponential()可以返回以科学技术法表示的数值字符串</li>
<li>isInteger()用于鉴别一个数组的值是否是整数</li>
<li>isSafeInteger()检查是否安全整数，即在IEEE754编码中可以表示</li>
</ol>
</li>
</ol>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol>
<li><p>JavaScript字符</p>
<ol>
<li>JavaScript字符串有16位码元组成。字符串的length属性表示字符串包含多少位16位码元。</li>
<li>chartAt()查找指定索引位置的16位码元，并返回码元对应的字符。</li>
<li>chartCodeAt()方法可以查看指定码元的字符编码（局限：有些字符需要不止16位码元表示，但是这个方法只会每16位解析）</li>
<li>fromChartCode()方法用于根据给定的UTF-16码元船舰字符串中的字符古。接受任意多的数值，并返回所有数值对应的字符凭借起来的字符串。</li>
<li>codePointAt()方法可以突破16位码元的限制</li>
</ol>
</li>
<li><p>字符串操作方法</p>
<ol>
<li>字符串截取<ol>
<li>slice()接受一到两个参数，第一个参数表示起始位置，第二个参数表示结束位置。如果是负数，则当成是倒数。</li>
<li>substr()接受一到两个参数，第一个参数表示起始位置，第二个参数表示从起始位置往后截取多少个字符。如果是负数，第一个参数当成倒数，第二个参数转换为零。</li>
<li>subString()接受一到两个参数，第一个参数表示其实位置，第二个参数表示从起始位置往后截取多少个字符。如果为负数，全部转为0</li>
</ol>
</li>
</ol>
</li>
<li><p>字符串位置方法</p>
<ol>
<li>indexOf()从前往后搜索字符串，返回第一个匹配的字符串索引。</li>
<li>lastIndexOf()从后往前第一个匹配的字符串索引。</li>
</ol>
<p>都接受第二个参数表示开始搜索的位置。</p>
</li>
<li><p>字符串包含方法</p>
<ol>
<li>startWith()    开始于索引0的匹配项</li>
<li>endWith()      结束于字符串末尾的匹配项</li>
<li>includes()      任意位置的匹配项</li>
</ol>
</li>
<li><p>trim()创建一个副本删除最前面和最后面的所有空格。</p>
</li>
<li><p>repeat()接受一个参数，表示要将字符串重复几次。</p>
</li>
<li><p>padStart()和padEnd()</p>
<ol>
<li>接受两个参数，从开头或者结尾填充第二个参数直到字符串长度达到第一个参数的长度。</li>
</ol>
</li>
<li><p>字符串迭代与解构，for-of迭代</p>
</li>
<li><p>字符串大小写转换，toLowerCase(),toUpperCase()</p>
</li>
<li><p>字符串模式匹配方法</p>
<ol>
<li>查找匹配match：pattern.exec(text)等价于text.match(pattern)</li>
<li>查找替换replace:接受两个参数，第一个参数如果是字符串，只会替换一次，如果是正则表达式，则会替换左右被匹配的字符串。</li>
</ol>
</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记05集合引用类型Object</title>
    <url>/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ol>
<li><h5 id="两种创建方式"><a href="#两种创建方式" class="headerlink" title="两种创建方式"></a>两种创建方式</h5><ol>
<li>new Object</li>
<li>使用对象字面量{name:’a’}</li>
</ol>
</li>
<li><h5 id="关于定义对象的“-”出现的地方"><a href="#关于定义对象的“-”出现的地方" class="headerlink" title="关于定义对象的“{”出现的地方"></a>关于定义对象的“{”出现的地方</h5><ol>
<li>出现在表达式上下文中（期待返回值的上下文中），赋值操作符表示后面要期待一个值，因此在左大括号表达一个表达式的开始。</li>
<li>出现在语句上下文中，比如if语句的条件后面，则表示一个语句块的开始</li>
</ol>
</li>
<li><h5 id="属性一般是使用点语法来存取的，例如obj-name-“pa”"><a href="#属性一般是使用点语法来存取的，例如obj-name-“pa”" class="headerlink" title="属性一般是使用点语法来存取的，例如obj.name=“pa”"></a>属性一般是使用点语法来存取的，例如obj.name=“pa”</h5><p>注意：也可以使用中括号存取，例如obj[“name”]=”pa”使用中括号的优点在于如果属性名中包含会导致语法错误的字符，只用中括号可以避免这一点。（fs优化对象值的存取）</p>
</li>
<li><h5 id="属性值可以是字符串或数值-数值会自动转为字符串"><a href="#属性值可以是字符串或数值-数值会自动转为字符串" class="headerlink" title="属性值可以是字符串或数值(数值会自动转为字符串)"></a>属性值可以是字符串或数值(数值会自动转为字符串)</h5></li>
</ol>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ol>
<li><h5 id="两种创建方式-1"><a href="#两种创建方式-1" class="headerlink" title="两种创建方式"></a>两种创建方式</h5><ol>
<li>使用new Array()来创建<ol>
<li>可以传入一个数值，然后length属性就会自动设置成这个值。配合fill函数可以创建一个全部为某一个数的数组</li>
<li>也可以传入要保存的元素</li>
</ol>
</li>
<li>使用数组字面量</li>
</ol>
</li>
<li><h5 id="es6新增的创建数组的方法。"><a href="#es6新增的创建数组的方法。" class="headerlink" title="es6新增的创建数组的方法。"></a>es6新增的创建数组的方法。</h5><ol>
<li>from()用于将类数组结构转化为数组<ol>
<li>第一个参数但是任何可迭代结构</li>
<li>第二个参数可以选择映射函数的参数，这个函数可以直接增强新数组的值</li>
<li>第三个参数用于指定映射函数中this的值</li>
</ol>
</li>
<li>of()用于将一组参数转换为数组实例</li>
</ol>
</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ol>
<li><h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li><p>使用new Map()创建一个空映射</p>
<p>可以给这个构造函数传入一个可迭代对象。需要包含键值对数组。可迭代对象中的每一个键值对都会按照迭代顺序插入到新实例对象中</p>
</li>
</ol>
</li>
<li><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ol>
<li>set()添加键值对</li>
<li>get()查找键对应的值</li>
<li>has()查询是否有这个键</li>
<li>delete()删除某个键值对</li>
<li>clear()删除所有键值对</li>
</ol>
</li>
<li><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ol>
<li>Object只能使用数值。字符串或者符号作为键。</li>
<li>Map可以使用任何JavaScript对象数据类型作为键</li>
<li>在映射中作为键和值对象或其他集合类型，在自己的内容被修改时，映射关系不会改变。</li>
</ol>
</li>
<li><h5 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h5><ol>
<li>映射（map）实例可以提供一个迭代器(Iterator)可以通过entries()方法或者Symbol.iterator属性取得这个迭代器。<ol>
<li>for(let pair of m.entries())</li>
<li>for(let pair of m[Symbol.iterator])</li>
<li>键和值在迭代器遍历的时候是可以修改的，但在映射内部是不可修改的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h1><ol>
<li><h5 id="创建方式-1"><a href="#创建方式-1" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li>使用new WeakMap()关键字实例化一个空的弱映射</li>
</ol>
</li>
<li><h5 id="弱映射中的键只能是object或者继承自object的类型，值没有限制"><a href="#弱映射中的键只能是object或者继承自object的类型，值没有限制" class="headerlink" title="弱映射中的键只能是object或者继承自object的类型，值没有限制"></a>弱映射中的键只能是object或者继承自object的类型，值没有限制</h5></li>
<li><h5 id="操作和Map基本一致，除了没有clear，set-方法返回弱映射实例，因此可以串联设置"><a href="#操作和Map基本一致，除了没有clear，set-方法返回弱映射实例，因此可以串联设置" class="headerlink" title="操作和Map基本一致，除了没有clear，set()方法返回弱映射实例，因此可以串联设置"></a>操作和Map基本一致，除了没有clear，set()方法返回弱映射实例，因此可以串联设置</h5></li>
<li><h5 id="使用弱映射"><a href="#使用弱映射" class="headerlink" title="使用弱映射"></a>使用弱映射</h5><ol>
<li>私有变量<ol>
<li>私有变量会储存在弱映射中，以对象实例为键，以私有成员的字段为值</li>
</ol>
</li>
<li>DOM节点元数据<ol>
<li>因为WeakMap实例不会妨碍垃圾回收机制，所以非常适合保存关联元数据。</li>
<li>当节点从DOM树种被删除后，垃圾回收程序会立即释放内存。（假设没有其他地方引用这个对象）</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。"><a href="#因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。" class="headerlink" title="因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。"></a>因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。</h5></li>
<li><h5 id="弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。"><a href="#弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。" class="headerlink" title="弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。"></a>弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。</h5></li>
</ol>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol>
<li><h5 id="创建方式-2"><a href="#创建方式-2" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li>使用new Set()关键字实例化一个空的集合<ol>
<li>可以传入一个可迭代对象，其中包含需要插入到集合的元素。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h5><ol>
<li>add()增加一个值</li>
<li>has()查询一个值</li>
<li>size()取得元素数量</li>
<li>delete()/clear()删除值</li>
</ol>
</li>
<li><h5 id="Set可以包含任何JavaScript数据类型作为值"><a href="#Set可以包含任何JavaScript数据类型作为值" class="headerlink" title="Set可以包含任何JavaScript数据类型作为值"></a>Set可以包含任何JavaScript数据类型作为值</h5><ol>
<li>用作值的对象和其他集合类型在自身改变时不会影响。</li>
</ol>
</li>
<li><h5 id="顺序与迭代-1"><a href="#顺序与迭代-1" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h5><ol>
<li><p>Set会维护值插入时的顺序，因此支持顺序迭代</p>
</li>
<li><p>set实例可以提供一个迭代器(Iterator)，能以插入顺序生成集合内容。</p>
</li>
<li><p>可以通过values()方法以及其别名方法keys()</p>
<p>for(let v of s.values())</p>
</li>
<li><p>或者Symbol.ietrator属性，他引用values()取得这个迭代器</p>
<p>for(let v of s[Symbol.iterator])</p>
</li>
<li><p>set的entires()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现。</p>
</li>
</ol>
</li>
</ol>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><ol>
<li><h5 id="创建方式-3"><a href="#创建方式-3" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li>使用new WeakSet()关键字实例化一个空的弱集合<ol>
<li>可以接受一个可迭代的对象，其中需要包含有效的值</li>
<li>弱集合中的值只能是object或继承自object类型</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h5><ol>
<li>add()增加一个值</li>
<li>has()查询一个值</li>
<li>delete()删除一个值</li>
</ol>
</li>
<li><h5 id="弱集合中的值不属于正式引用，不会阻止垃圾回收"><a href="#弱集合中的值不属于正式引用，不会阻止垃圾回收" class="headerlink" title="弱集合中的值不属于正式引用，不会阻止垃圾回收"></a>弱集合中的值不属于正式引用，不会阻止垃圾回收</h5></li>
<li><h5 id="使用弱集合"><a href="#使用弱集合" class="headerlink" title="使用弱集合"></a>使用弱集合</h5><ol>
<li>给对象打标签<ol>
<li>创建WeakSet实例，将需要被打上标签的值放进去，如果这个值的引用被删除了，那么weakSet中对应的值也会被回收。</li>
</ol>
</li>
</ol>
</li>
<li><p>不可迭代值</p>
<ol>
<li>weakSet中的值可以随时销毁，因此没有必要迭代。</li>
</ol>
</li>
</ol>
<h1 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h1><ol>
<li><h5 id="有4中原生集合类型定义了默认迭代器"><a href="#有4中原生集合类型定义了默认迭代器" class="headerlink" title="有4中原生集合类型定义了默认迭代器"></a>有4中原生集合类型定义了默认迭代器</h5><ol>
<li>Array</li>
<li>所有定型数组</li>
<li>Map</li>
<li>Set</li>
</ol>
</li>
<li><h5 id="这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。"><a href="#这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。" class="headerlink" title="这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。"></a>这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。</h5></li>
<li><h5 id="对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。"><a href="#对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。" class="headerlink" title="对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。"></a>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。</h5></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记06迭代器与生成器</title>
    <url>/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ol>
<li><h5 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h5><ol>
<li>迭代是循环的一种，可以指定迭代次数，以及迭代要执行的操作，顺序也是事先定好的。</li>
</ol>
</li>
<li><p>可迭代协议</p>
<ol>
<li>实现Iterrable接口（可迭代协议）要求支持迭代的自我识别能力和创建实现Iterable接口的对象能力。在ECMAScript中，这意味着必须暴露一个属性作为默认的迭代器，而这个属性必须使用特殊的Symbol.iterator作为键。这个默认的迭代器属性必须应用一个迭代器工厂函数，调用这个工厂函数必须返回一个迭代器。</li>
</ol>
</li>
<li><p>迭代器模式</p>
<ol>
<li>可迭代对象可以理解为数组或集合这样的集合类型对象。包含与有限元素，且有无歧义的遍历顺序。</li>
</ol>
</li>
<li><p>迭代器协议</p>
<ol>
<li>迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()都会返回一个包含迭代器返回的下一个值的对象。<ol>
<li>迭代器并不知道怎么从可迭代对象中获取下一个值，也不知道可迭代对象有多大。只要迭代器到达done:true状态，后续调用next()对象就一直返回这个值了。</li>
<li>每个迭代器都表示可迭代对象的一次性有序遍历。不同迭代器实例之间没有联系，只会独立第遍历可迭代对象。</li>
</ol>
</li>
</ol>
</li>
<li><p>提前终止迭代器</p>
<ol>
<li>可选的return()方法用于指定迭代器关闭时执行的逻辑。</li>
</ol>
</li>
</ol>
<h1 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h1><ol>
<li><p>生成器基础</p>
<ol>
<li>生成器的形式是一个函数，在函数名称前面加一个*号，例如:function *foo(){…},只要可以定义函数的地方，就可以定义生成器。</li>
<li>调用生成器函数会生成一个生成器对象，生成器对象一开始处于暂停执行的状态。与迭代器相似，生成器对象也实现了Iterator接口，因此具有next()方法。调用这个方法会让生成器开始或回复执行。</li>
<li>next()方法的返回值有一个done和value属性<ol>
<li>函数体为空的函数调用一遍next()就返回done:true状态</li>
</ol>
</li>
<li>生成器对象实现了Iterable接口，他们的默认迭代器是自引用的。</li>
</ol>
</li>
<li><p>通过yield中断执行（重点）</p>
<ol>
<li><p>这是生成器最有用的地方</p>
<ol>
<li>生成器在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行。</li>
<li>yield关键字只能在生成器函数内部使用，用在其他地方会抛出错误。</li>
</ol>
</li>
<li><p>生成器对象作为可迭代对象</p>
<ol>
<li><p>如果把生成器对象当成可迭代对象，那么使用起来会很方便。也可以自定义迭代对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *foo（）&#123;</span><br><span class="line">	yield 1;</span><br><span class="line">	yield 2;</span><br><span class="line">	yield 3</span><br><span class="line">&#125;</span><br><span class="line">for (const x of foo())&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义迭代对象</span><br><span class="line">function *foo（n）&#123;</span><br><span class="line">	while（n--）&#123;</span><br><span class="line">		yield；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (const x of foo(3))&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">//0</span><br><span class="line">//1</span><br><span class="line">//2</span><br></pre></td></tr></table></figure></li>
<li><p>使用yield实现输入和输出</p>
<ol>
<li>yield可以作为函数的中间参数使用。上一次生成器暂停的yield关键字会接收到传给next（）方法的第一个值。（第一次调用next()传入的值不会被使用，因为第一次是开始执行生成器函数）（可以同时用于输入和输出）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *foo（）&#123;</span><br><span class="line">	return yield &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line">let bar = foo()</span><br><span class="line">console.log(bar.next());		//&#123;done:false, value:&#x27;foo&#x27;&#125;</span><br><span class="line">console.log(bar.next(&quot;bar&quot;))	//&#123;done:true, value:&#x27;bar&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>产生可迭代对象</p>
<ol>
<li>yield的值是关联迭代器返回done:true时的value属性。对于普通迭代器来说，这个值时undefined，对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值。</li>
<li>可以使用*增强yield的行为，让它能够迭代一个可迭代对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *foo()&#123;</span><br><span class="line">	yield *[1,2]</span><br><span class="line">	yield *[3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(const x of foo())&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br><span class="line">//4</span><br></pre></td></tr></table></figure></li>
<li><p>使用yield实现递归算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *nTimes(n)&#123;</span><br><span class="line">	if(n&gt;0)&#123;</span><br><span class="line">		yield *nTimes(n-1)</span><br><span class="line">		yield n-1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(const x of nTimes(5))&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩展：async、await原理</p>
<p>async函数返回一个Promise对象，当函数执行的时候，一旦遇到awiat就会先返回，等到触发的异步操作完成，才会接着执行函数体后面的的语句。async函数就是Generator函数的语法糖。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记07对象</title>
    <url>/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><ol>
<li><h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><ol>
<li><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><ol>
<li>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。</li>
<li>要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接受3个参数（要个其添加属性的对象，属性的名称和一个描述对象）<ol>
<li>最后一个参数，即描述符对象上的属性可以包含:configurable、enumerable、wirtable和value</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ol>
<li>访问器属性不包含数据值，包含一个获取(getter)函数和一个(setter)函数，不过这两个函数不是必须的。</li>
<li>在读取访问器属性时，会调用获取函数，这个函数的责任是返回一个有效的值。再写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。（Vue响应式原理）</li>
</ol>
</li>
<li><h5 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h5><ol>
<li>Object.defineProperties()可以通过多个描述符一次性定义多个属性。它接受两个参数（要为之添加或修改属性的对象和另一个描述符对象，其属性与一一对应）</li>
</ol>
</li>
<li><h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><ol>
<li>使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。<ol>
<li>这个方法接受两个参数:属性所在的对象和要去的其描述符的属性名。返回值是一个对象，包含访问器属性</li>
</ol>
</li>
<li>ES7新增了Object.getOwnPropertyDescriptors()静态方法<ol>
<li>接受一个对象，并返回这个对象每个属性的特性</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><ol>
<li>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个复制动作。可以简写<ol>
<li>解构赋值不一定与对象属性匹配，赋值的时候可以忽略某些属性，如果引用的属性不存在，则该变量的值为undefined，也可以定义默认值，适用于属性不存在的情况。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><ol>
<li><h5 id="属性值的简写"><a href="#属性值的简写" class="headerlink" title="属性值的简写"></a>属性值的简写</h5><ol>
<li>简写的属性名只要使用变量名就会自动被解释为同名的属性键</li>
</ol>
</li>
<li><h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><ol>
<li>如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能再对象字面量中直接动态命名属性<ol>
<li>中括号包围的对象属性键告诉运行时将其作为JavaScript表达式而不是字符串来求值。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><ol>
<li><p>再给对象定义方法时，通常要写一个方法名、冒号，然后再引用一个匿名函数表达式。</p>
<ol>
<li>新的简写方法可以直接声明函数，例如sayName(){…}，与可计算属性键相互兼容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const methodKey = &quot;foo&quot;</span><br><span class="line">let person = &#123;</span><br><span class="line">	[methodKey](name)&#123;</span><br><span class="line">		alert(&quot;aaa &quot;+name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName(&quot;john&quot;)		//aaa john</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h4><ol>
<li>ES6新增了Object.assign()方法用于合并对象。接受一个目标对象和一个多源对象作为参数，然后将每个源对象中可枚举和自由属性赋值到目标函数。<ol>
<li>这是一种浅拷贝，如果多个源对象有相同的属性，则使用最后一个。此外，从源对象访问器属性中取得的值，比如获取函数，会作为一个静态值赋值给目标对象。如果赋值期间出错，则操作会终止并退出，同时抛出错误。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>前提：使用Object构造函数创建多个有相同接口的对象会比较麻烦。ES6开始正式支持类和继承。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单来说，就是把创建Object对象的过程封装到函数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 	createPerson（name,age,job）&#123;</span><br><span class="line">	let 0 = new Object</span><br><span class="line">	o.name = name</span><br><span class="line">	o.age = age</span><br><span class="line">	o.job = job</span><br><span class="line">	o.sayName = function()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">	return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = cretePerson(&quot;jianhuo&quot;,19,&quot;geiyepa&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ol>
<li><h5 id="跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。"><a href="#跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。" class="headerlink" title="跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。"></a>跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。</h5><ol>
<li>没有显示地创建对象</li>
<li>属性和方法直接赋值给this</li>
<li>没有return</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 	createPerson（name,age,job）&#123;</span><br><span class="line">	this.name = name</span><br><span class="line">	this.age = age</span><br><span class="line">	this.job = job</span><br><span class="line">	this.sayName = function()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = cretePerson(&quot;jianhuo&quot;,19,&quot;geiyepa&quot;)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的"><a href="#按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的" class="headerlink" title="按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的"></a>按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的</h5></li>
<li><h5 id="要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作"><a href="#要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作" class="headerlink" title="要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作"></a>要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作</h5><ol>
<li>在内存中创建一个新对象</li>
<li>在这个新对象的内部的[[Prototype]]特性被赋值为构造函数的prototype属性</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则返回创建的新对象</li>
</ol>
</li>
<li><h5 id="构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数"><a href="#构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数" class="headerlink" title="构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数"></a>构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数</h5></li>
<li><h5 id="如果不想传参数，那么new的时候后面的括号可以不加。"><a href="#如果不想传参数，那么new的时候后面的括号可以不加。" class="headerlink" title="如果不想传参数，那么new的时候后面的括号可以不加。"></a>如果不想传参数，那么new的时候后面的括号可以不加。</h5></li>
<li><h5 id="构造函数也是函数，和普通函数的唯一区别是调用方式的不同。"><a href="#构造函数也是函数，和普通函数的唯一区别是调用方式的不同。" class="headerlink" title="构造函数也是函数，和普通函数的唯一区别是调用方式的不同。"></a>构造函数也是函数，和普通函数的唯一区别是调用方式的不同。</h5><ol>
<li>使用new操作符调用就是构造函数，不使用new操作符调用就是普通函数</li>
</ol>
</li>
<li><h5 id="构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。"><a href="#构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。" class="headerlink" title="构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。"></a>构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。</h5><ol>
<li>要解决这个问题，可以把函数定义转移到构造函数外面。</li>
</ol>
</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ol>
<li><h4 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h4><ol>
<li>可以看成JavaScript版的继承</li>
<li>只要创建函数，就会为其创建一个prototype属性（指向原型对象）</li>
<li>默认情况下，所有原型对象自动获得一个名为constructor的属性，只会函数本身。</li>
</ol>
</li>
<li><h4 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h4><ol>
<li>再通过对象访问属性是，会按照这个属性的名称开始搜索。顺着原型链一直向上查找，直到object’原型，也就是null。</li>
<li>这就是原型用于多个对象实例间共享属性和方法的原理。</li>
<li>虽然可以通过实例读取原型对象的值，但是不可以通过实例重写这些值。</li>
<li>如果在实例上添加一个与原型对象中同名的属性，那就会再实例上创建这个属性，这个属性会遮住原型对象上的对应属性。（优先级比原型链上的同名属性高）<ol>
<li>即时实例上的属性设置为null，依然会屏蔽，但是使用delete操作符删除属性可以回复。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h4><ol>
<li>有两种方式使用in操作符<ol>
<li>使用for。。。in循环</li>
<li>单独使用<ol>
<li>in操作符会在可以通过对象访问到指定属性时候返回true（包括原型链上的同名属性）</li>
</ol>
</li>
<li>如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()</li>
<li>使用Object.keys()可以获取实例上的属性</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h4><ol>
<li>for-in循环和Object,keys()枚举顺序是不确定的。</li>
<li>Object.getOwnPropertyNames(), Object.getOwnPropertySymbols和Object.assign()的枚举顺序是确定的。</li>
</ol>
</li>
<li><p>每个函数都会创建一个prototype属性，包含应该有特定应用类型的实例共享的属性和方法。实际上这个对象就是通过调用构造函数创建对象的原型。</p>
<ol>
<li>使用原型对象的好处是，再它上面定义的属性和方法可以被对象实例共享。原来再构造函数中直接赋给对象实例的值，可以直接赋值给他们的原型。</li>
</ol>
</li>
<li><p>与构造函数模式不同，使用这种原型模式定义的属性和方法是有所有实例共享的。</p>
</li>
</ol>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><ol>
<li><h4 id="迭代对象属性是一个JavaScript存在已久的难题。"><a href="#迭代对象属性是一个JavaScript存在已久的难题。" class="headerlink" title="迭代对象属性是一个JavaScript存在已久的难题。"></a>迭代对象属性是一个JavaScript存在已久的难题。</h4></li>
<li><p>ES7新增了两个静态的方法，用于将对象内容转换为序列化的——更重要的是可迭代的格式。</p>
<ol>
<li>Object.values()接受一个对象，返回对象值的数组</li>
<li>Object,entires()接受一个对象，返回对象键值对的数组，如[[“aaa”,”bbb”],[“bbb”,”ccc”]]</li>
<li>非字符串会被转化为字符输出，符号属性（symbol）会被忽略</li>
</ol>
</li>
<li><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><ol>
<li>因为从原型上搜索值的过程是动态的，所以即时实例在修改原型前就已经存在，任何时候对原型的修改也会在实例上反映出来<ol>
<li>主要原因是实例和原型的松散联系，实例和原型之间的链接就是简单的指针，而不是保存副本。</li>
<li>虽然随时都能给原型添加属性和方法，并能够立即反映到所有对象实例上，但是这跟重写整个原型是不一样的。实例的[[prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用仍然时最初的原型。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h4><ol>
<li>弱化了想构造函数传递初始化参数的能力，会导致所有实例默认取得相同的属性值。</li>
<li>原型上所有属性都是在实例中共享的。如果这个属性是对象，那么某个实例上对于对象的修改会影响所有实例。</li>
</ol>
</li>
<li><h4 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h4><ol>
<li>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。</li>
</ol>
</li>
<li><h4 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h4><ol>
<li>为了减少代码冗余，也为了美观，直接通过一个包含所有属性和方法的对象字面量来重写原型。</li>
<li>但是这样重写原型会导致constructor属性丢失，从而默认指向Object构造函数<ol>
<li>解决办法一：<ol>
<li>重写时候添加一句constructor:xxx重新指定但是这种方法设置的constructor属性是可枚举的，而默认的此属性是不可枚举的。</li>
</ol>
</li>
<li>解决办法二：<ol>
<li>使用Object.defineProPerty()方法定义constructor属性</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name:&quot;jianhuo&quot;,</span><br><span class="line">	age:21,</span><br><span class="line">	job:&quot;geiyepa&quot;,</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(&quot;gunyuandian&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name:&quot;jianhuo&quot;,</span><br><span class="line">	age:21,</span><br><span class="line">	job:&quot;geiyepa&quot;,</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(&quot;gunyuandian&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//回复constructor属性</span><br><span class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;, &#123;</span><br><span class="line">	enumerable:false,</span><br><span class="line">	value:Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记08继承</title>
    <url>/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>很多面向对象语言都支持两种继承：接口继承和实现继承。JavaScript只支持实现继承，而且是通过原型链方式继承的。这里介绍JavaScript中实现继承的6中方式。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链继承的基本思想是通过原型继承多个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.far=<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.getFar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.far</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.child=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()	<span class="comment">//原型继承father实例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">alert(a.getFar())	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>本质：</p>
<ul>
<li>通过重写子类型的原型对象实现继承</li>
<li>注：原型对象中包含constructor属性一般指回子类型函数本身，重写子类型的原型对象会导致constructor属性丢失。</li>
<li>最终原型链为：a-&gt;child-&gt;father-&gt;Object（所有函数的默认原型）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>父级的实例属性会被子级共享</li>
<li>子级不能向父级传递参数</li>
</ul>
</li>
<li><p>原型与继承的关系</p>
<ol>
<li><p>使用instanceof操作符确定</p>
<ul>
<li><p>如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用isPrototypeOf()方法。</p>
<ul>
<li><p>只要原型链包含这个原型，就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>原型链的问题</p>
<ol>
<li>原型中包含的引用值会在所有实例间共享。在使用原型实现继承时，原型实际上变成了另一个类型实例。</li>
<li>重写子类型对象后，constructor属性会丢失。</li>
</ol>
</li>
<li><p>关于方法</p>
<ol>
<li>子类有些时候需要覆盖父类的方法，或者增设父类没有的方法。为此，有些方法必须在原型复制后再添加到原型上。</li>
<li>如果以对象字面量的方式创建原型会破坏原型链，因为这相当于重写了原型链。</li>
</ol>
</li>
</ol>
<h2 id="借用构造函数继承（经典继承）"><a href="#借用构造函数继承（经典继承）" class="headerlink" title="借用构造函数继承（经典继承）"></a>借用构造函数继承（经典继承）</h2><p>为了解决原型链继承中共享的问题，基本思路是：在子类构造函数中调用父类构造函数。因为函数就是特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新建的对象为上下文执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过call/apply方法，在子类型构造函数内部调用超类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">child</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;aa&quot;</span></span><br><span class="line">	<span class="comment">//打印来自子级的参数</span></span><br><span class="line">	<span class="built_in">console</span>.log(child.name)	<span class="comment">//jojo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	father.apply(<span class="built_in">this</span>,[&#123;<span class="attr">name</span>:<span class="string">&quot;jojo&quot;</span>&#125;])	<span class="comment">//继承，可以传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">alert(a.name)		<span class="comment">//aa</span></span><br></pre></td></tr></table></figure>

<ol>
<li>优点：<ul>
<li>解决了原型链继承中所有属性都会暴露和子级不能向父级传参的问题。</li>
<li>可以在子类构造函数中向父级构造函数传参</li>
</ul>
</li>
<li>缺点：<ul>
<li>必须在构造函数中定义方法，因此函数不能复用</li>
<li>父级的方法对于子级不可见</li>
</ul>
</li>
</ol>
<h1 id="组合继承-伪经典继承"><a href="#组合继承-伪经典继承" class="headerlink" title="组合继承(伪经典继承)"></a>组合继承(伪经典继承)</h1><p>JavaScript中最常见的继承模式，使用instanceof操作符和isPrototype()方法可用于识别基于组合继承的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借用构造函数继承实例属性，原型链继承来继承原型上的方法和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;jianhuo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">funciton <span class="function"><span class="title">child</span>(<span class="params"></span>)</span>&#123;		<span class="comment">//借用构造函数继承属性</span></span><br><span class="line">	father.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()	<span class="comment">//原型链继承，注意！重写原型导致constructors属性丢失</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">a.sayName()</span><br></pre></td></tr></table></figure>

<ol>
<li>本质：<ul>
<li>使用原型链继承来继承原型上的属性和方法，用组合继承来继承实例属性。这样既可以把方法定义在原型上实现复用，又可以让每个实例都有自己的属性。</li>
</ul>
</li>
<li>优点：<ul>
<li>综合了原型链和借用构造继承的优点</li>
</ul>
</li>
<li>缺点：<ul>
<li>必会调用两次超类型构造函数，一次在创建子类型的原型时，另一次在子类型构造函数内部。</li>
</ul>
</li>
</ol>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种实现方法</span></span><br><span class="line"><span class="comment">//1.自定义函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ob</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	f.prototype.name = <span class="string">&quot;jianhuo&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ob()</span><br><span class="line"><span class="built_in">console</span>.log(a.name)	<span class="comment">//jianhuo</span></span><br><span class="line"><span class="comment">//2.使用Object.create方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">		<span class="attr">value</span>:<span class="string">&quot;gun&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">alert(a.name)</span><br></pre></td></tr></table></figure>

<ol>
<li>本质：<ul>
<li>ob()式对传入的对象执行了一次浅复制。</li>
</ul>
</li>
<li>优点：<ul>
<li>原型式继承非常适合不需要单独创建构造函数，但是任然需要在对象间共享信息的场合。</li>
</ul>
</li>
<li>缺点：<ul>
<li>和原型链继承一样，属性中包含的引用值会始终在相关的对象间共享。</li>
</ul>
</li>
</ol>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(name)</span><br><span class="line">	clone.sayGood=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wiw = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span>,</span><br><span class="line">	<span class="attr">act</span>:<span class="string">&quot;pa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> final = father(wiw)	<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line">final.sayGood()</span><br></pre></td></tr></table></figure>

<ol>
<li>本质:<ul>
<li>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</li>
</ul>
</li>
<li>优点：<ul>
<li>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。</li>
</ul>
</li>
<li>缺点:<ul>
<li>通过寄生式继承给对象添加函数会导致函数难以重用。</li>
</ul>
</li>
</ol>
<h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>可以算是应用类型继承的最佳模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	father.call(<span class="built_in">this</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(father.prototype)</span><br><span class="line">a.constructor = child	<span class="comment">//重新赋值constructor</span></span><br><span class="line">child.prototype = a</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> child(<span class="string">&quot;jianhuo&quot;</span>)</span><br><span class="line">b.sayName()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>本质：</p>
<ul>
<li><p>这个函数实现了接受两个参数：子类构造函数和父类构造函数。</p>
<ul>
<li>在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype对象设置constructor属性，解决由于重写原型导致的默认constructor丢失问题。最后将新创建的对象赋值给子类型原型。</li>
</ul>
</li>
<li><p>寄生式组合继承通过借用构造函数继承属性，但是用混合式原型链继承方法。基本思路就是不通过调用父类构造函数给子类函数原型赋值，而是取得一个父类的副本。</p>
<ul>
<li>说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记09类</title>
    <url>/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li><h5 id="ES6支持单继承。使用extends关键字，就可以继承任何拥有-Construct-和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）"><a href="#ES6支持单继承。使用extends关键字，就可以继承任何拥有-Construct-和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）" class="headerlink" title="ES6支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）"></a>ES6支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承普通构造函数	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> ()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">let</span> <span class="title">e</span> </span>= <span class="keyword">new</span> Engineer ()</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类："><a href="#派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类：" class="headerlink" title="派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类："></a>派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">identifyPrototype</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(id,<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">identifyClass</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(id,<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vehicle()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus()</span><br><span class="line"></span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>)</span><br><span class="line">v.identifyPrototype(<span class="string">&#x27;vehicle&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>)</span><br><span class="line">Vehicle. identifyClass(<span class="string">&#x27;vehicle&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><ol>
<li><h5 id="定义类有两种方式"><a href="#定义类有两种方式" class="headerlink" title="定义类有两种方式"></a>定义类有两种方式</h5><ol>
<li>类声明<ul>
<li>class Person {} 类声明不能提升</li>
</ul>
</li>
<li>类表达式<ul>
<li>const a = class {}</li>
</ul>
</li>
<li>函数收到作用域限制，类收到块作用域限制。</li>
</ol>
</li>
<li><h5 id="JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）"><a href="#JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）" class="headerlink" title="JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）"></a>JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）</h5><ul>
<li>ES6引入了class关键字具有正式定义类的能力。类（class）是ES6中新的基础性语法糖结构。虽然这个类表面上支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。</li>
</ul>
</li>
<li><h5 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h5><ul>
<li>类可以包含构造函数方法、实例方法、获取函数、设置函数、静态类的方法。但是不是必须的，空类也是有效的。</li>
<li>类表达式的名称是可选的。在把类表达式赋值给变量之后，可以通过name属性访问类表达式的名称字符串。但是不能在类表达式作用域外部访问这个标识符。</li>
</ul>
</li>
</ol>
<h1 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h1><p>constructor关键字用于在类定义块内部创建类的构造函数。构造函数的定义不是必须的。</p>
<ol>
<li><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><ul>
<li>使用new操作符实例化Person的操作等于使用new调用其构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使用new和类意味着应该使用constructor函数进行实例化。</li>
<li>使用new调用类的构造函数会执行如下操作。(类实例化时传入的参数会用作构造函数的参数，如过不需要参数，则类名后面的括号也是可选的)<ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象的内部[[prototypr]]指针被赋值为constructor构造函数的prototypr属性。</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ol>
</li>
<li>默认情况下，类构造函数会在执行之后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有什么引用新创建的对象，那么这个对象就会被销毁。不过，如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针没有被修改。</li>
<li>类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，否则会报错。普通构造函数直接调用，则会以全局对象作为this。</li>
</ul>
</li>
<li><h5 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h5><ol>
<li>ECMAScript中没有正式的类这个类型，从各个方面来看，类就是一种特殊的函数</li>
<li>在类上下文中，类本身在使用new调用时就会被当作构造函数。重点在于，类定义中的constructor方法不会被当成构造函数，在对他使用instanceof操作符时会返回false。但是，如果在创建实例时直接将类构造函数方程普通构造函数来使用，那么instanceof操作符的返回值会反转。</li>
<li>可以向其他对象或者函数引用一样把类作为参数传递，也可以立即实例化。</li>
</ol>
</li>
</ol>
<h1 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h1><ol>
<li><h5 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h5><ol>
<li>每次通过new调用类识别符，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加自有属性。至于添加怎么样的属性，没有限制。另外，在构造函数执行完毕之后，仍然可以给实例添加新的成员。</li>
<li>所有成员都不会在原型上共享</li>
</ol>
</li>
<li><h5 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h5><ol>
<li>为了在实例间共享方法，类定义语法把类块中定义的方法作为原型方法。</li>
<li>可以把方法定义在类构造函数中或者类块中，但是不能在类块中给原型添加原始值或对象作为成员数据。</li>
<li>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键。</li>
<li>类定义也支持获取和设置访问器。语法与行为跟普通对象一样。</li>
</ol>
</li>
<li><h5 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h5><ol>
<li>类定义语法支持在原型和类本身上定义生成器的方法</li>
<li>因为支持生成器方法，所以可以通过添加一个默认的迭代器，八十例变成可迭代对象。</li>
<li>也可以只返回迭代器实例。</li>
</ol>
</li>
<li><h5 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h5><ul>
<li>虽然类定义不显示支持在原型或类上添加成员数据，但在类定义外部，可以手动添加。</li>
</ul>
</li>
<li><h5 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h5><ol>
<li>可以在类上定义静态方法。这些方法通常用于执行不特定与实例的操作，也不要求存在类的实例。</li>
<li>类静态成员每一个类上只能有一个</li>
<li>静态类成员在类定义中使用static关键字作为前缀。在静态成员中，this引用类自身。其他所有约定和原型成员一样。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记10代理与反射</title>
    <url>/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><ol>
<li><h4 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h4><ul>
<li>代理是目标对象的抽象。目标对象既可以直接被操作，也可以通过代理来操作。但是直接操作会绕过代理施予的行为。</li>
</ul>
</li>
<li><h4 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h4><ul>
<li>在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</li>
</ul>
</li>
<li><h4 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h4><ul>
<li>使用代理的主要原因是可以定义捕获器。每个处理程序对象都可以包含多个捕获器，每个捕获器对应一种基本操作，可以直接或间接在代理对象上调用。</li>
<li>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前像调用捕获器函数，从而实现拦截并修改相应的行为。</li>
<li>例如，可以定一一个get()捕获器，JavaScript操作以某种形式调用get()时触发。所有这些操作只要发生在代理对象上，就会触发get()捕获器</li>
<li>注意，只有在代理对象上，就会触发。</li>
</ul>
</li>
<li><h4 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h4><ul>
<li>所有捕获器都可以访问响应的参数面积与这些参数可以重建被捕获的方法的原始行为。</li>
<li>通过调用全局Reflect对象上（封装了原始行为）的同名方法来轻松重建。</li>
</ul>
</li>
<li><h4 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h4><ul>
<li>代理可以捕获13种不同的基本操作</li>
</ul>
</li>
<li><h4 id="代理的问题和不足"><a href="#代理的问题和不足" class="headerlink" title="代理的问题和不足"></a>代理的问题和不足</h4></li>
<li><h4 id="使用反射API"><a href="#使用反射API" class="headerlink" title="使用反射API"></a>使用反射API</h4><ul>
<li>某些情况下应该优先使用反射API，这些是有一些理由的。</li>
<li>反射API与对象API<ul>
<li>反射API并不限于捕获处理程序</li>
<li>大多数反射API方法在Object类型上对应的方法</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h4><ul>
<li>有时候可能需要中断代理对象与目标对象的联系。对于使用new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一致存在。</li>
<li>Proxy也暴露了revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数是幂等的，调用多少次结构都是一样的。</li>
</ul>
</li>
<li><h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><ul>
<li>目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时会报错。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记11函数</title>
    <url>/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定余函数本身紧密绑定</li>
<li>创建函数的方式和区别<ul>
<li>函数表达式 var foo = function() {…}<ul>
<li>只有在JavaScript语句执行到这句话的之后才会创建函数。在这之前调用函数会报错。（没有提升）</li>
</ul>
</li>
<li>函数声明 function foo() {…}<ul>
<li>在JavaScript编译的时候函数声明会被提前，也就是说可以先调用函数再在下面声明函数</li>
</ul>
</li>
</ul>
</li>
<li>箭头函数<ul>
<li>箭头函数是使用胖箭头(=&gt;)语法定义函数表达式的能力。</li>
<li>标准写法是 let a = (x) =&gt; {…}</li>
<li>如果函数只有一条语句的话，可以不要大括号，但是函数会默认将这一句话当成返回值；只有一个参数的时候也可以没有前一个括号</li>
</ul>
</li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ol>
<li><p>闭包是指哪些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparison</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> val1 = obj1[name]</span><br><span class="line">		<span class="keyword">let</span> val2 = obj2[name]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(val1&gt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compare  = createComparison(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123;<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;pa&quot;</span>&#125;)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个例子中的val1和val2引用了来自函数外的变量，在这个内部的匿名函数被返回并在其他的地方使用后，它仍然引用着那个变量。这是因为内部函数的作用域包含createComparison()函数的作用域。</li>
</ul>
</li>
<li><p>在调用一个函数的时候，会为这个函数创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动独享。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域一直向外串起了所有包含函数的活动对象，直到全局上下文才终止。</p>
</li>
<li><p>函数执行的时候，每个执行上下文都会有一个包含其中变量的对象。全局上下文中的叫变量对象，他会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，指在函数执行期间存在。</p>
<ul>
<li>函数内部的代码在访问变量时，就会使用给定的名称从作用域中查找变量。函数执行完毕后，局部活动对象会被摧毁。只剩下全局作用域。但是在闭包中就不一样了。</li>
</ul>
</li>
<li><p>注意：因为闭包会保留他们包含的函数作用域，因此会比其他函数更占用内存，所以要谨慎使用。</p>
</li>
<li><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到子自己的作用域链中。导致在外部函数被销毁时外部函数的活动对象由于仍然被引用，所以不能销毁。就产生了闭包。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记12异步编程</title>
    <url>/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Promise-期约"><a href="#Promise-期约" class="headerlink" title="Promise(期约)"></a>Promise(期约)</h1><ol>
<li><h4 id="promise基础"><a href="#promise基础" class="headerlink" title="promise基础"></a>promise基础</h4><ul>
<li>可以通过new 操作符来实例化一个promise对象。创建新期约的时候需要传入执行器（executor）函数作为参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p)	<span class="comment">//Promise&lt;pending&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="期约状态机"><a href="#期约状态机" class="headerlink" title="期约状态机"></a>期约状态机</h4><ol>
<li>Peomise是一个有状态的对象，可能处于三种状态<ul>
<li>待定（pedding）</li>
<li>兑现（fulfilled），有时也叫解决，（resolved）</li>
<li>拒绝（rejected）</li>
</ul>
</li>
<li>待定（pending）是promise的初始状态，可以转换为另外两种状态，并且一旦转换就不可逆。</li>
<li>另外，promise的状态也不能不被外部的JavaScript代码修改，也不能被外界读取（私有）。</li>
</ol>
</li>
<li><h4 id="解决值、拒绝理由及期约用例"><a href="#解决值、拒绝理由及期约用例" class="headerlink" title="解决值、拒绝理由及期约用例"></a>解决值、拒绝理由及期约用例</h4><ul>
<li>promise的用途是，抽象的标识一个异步操作，并且通知这个操作是否完成</li>
<li>一些情况下，promise封装的异步操作会实际生成某个值，而程序期待promise状态改变的时候可以访问这个值。例如，如果请求范围为200-299的状态码，让promise状态转化为resolved，并且内部可以接受到一个JSON字符串。拒绝同理，只是接受的变成一个拒绝理由。</li>
<li>为了支持这种用例，promise每次转换状态，就会有一个私有的内部值或理由。二者都是可选的，并且默认为undefined。</li>
</ul>
</li>
<li><h4 id="同步-异步执行的二元性"><a href="#同步-异步执行的二元性" class="headerlink" title="同步/异步执行的二元性"></a>同步/异步执行的二元性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)	<span class="comment">//Error:foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Uncaught (in Promise) Error:bar</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子报错的原因是：try。。。catch捕获的是哦同步执行时抛出的错误，因此第一个错误可以捕获，但是第二个Promise中抛出的异常是以异步模式进行的，因此没有捕获。</li>
<li>这个例子中可以看出promise的真正异步特性:他们时同步对象（在同步中执行使用），但是也是异步执行的媒介</li>
<li>代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体的说，就是promise方法。</li>
</ul>
</li>
<li><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><ul>
<li>通过调用一个Promise.resolve()方法，可以实例化一个已处于解决状态的promise。</li>
<li>使用这个方法实际上可以把任何值转化为一个promise</li>
<li>这是一个幂等的方法，即嵌套调用多少次结果都一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p===<span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)))		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，这样会把抛出的错误都包装到已解决的promise中。</li>
</ul>
</li>
<li><h4 id="Promise-rejected"><a href="#Promise-rejected" class="headerlink" title="Promise.rejected()"></a>Promise.rejected()</h4><ul>
<li>和resolved类似，但是不是幂等的，给他传入一个resolve会把这个promise包装成拒绝理由。</li>
</ul>
</li>
<li><h4 id="通过执行函数控制promise状态"><a href="#通过执行函数控制promise状态" class="headerlink" title="通过执行函数控制promise状态"></a>通过执行函数控制promise状态</h4><ul>
<li>由于promise状态是私有的，所以只能在内部进行操作。内部操作在promise的执行器函数中完成。</li>
<li>执行器的两个职责<ul>
<li>初始化promise的异步行为</li>
<li>控制状态的最终转换<ul>
<li>转换是通过调用它的两个函数参数实现的<ul>
<li>reslove()</li>
<li>reject()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>执行器函数是同步执行的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//executor</span></span><br><span class="line"><span class="comment">//promise initialized</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加setTimeout可以推迟切换状态：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve,<span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p)</span><br></pre></td></tr></table></figure>

<ul>
<li>再次强调，promise的状态只能改变一次，且不可逆。任何在状态改变后视图再次改变状态的操作都会无效。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记13JSON</title>
    <url>/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013JSON/</url>
    <content><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ol>
<li>理解JSON最关键的一点就是要把它当成一种数据格式而不是编程语言</li>
<li>语法<ol>
<li>JSON语法支持三种类型的值<ul>
<li>简单值（字符串，数值，布尔值，null，都可以在JSON中出现，undefined不可以）</li>
<li>对象</li>
<li>数组</li>
</ul>
</li>
<li>JSON没有变量、函数或对象实例的概念。JSON的所有记号都只为标识结构化数据，虽然它借用了JavaScript的语法。</li>
</ol>
</li>
<li>解析与序列化<ul>
<li>JSON可以直接被解析为可用的JavaScript对象，与解析为DOM文档的XML相比，这个优势非常明显。为此，JavaScript开发者可以非常方便第使用JSON数据。</li>
</ul>
</li>
<li>序列化选项<ul>
<li>stringify()<ul>
<li>过滤结果<ul>
<li>如果第二个参数是一个数组，那么JSON.stringify()返回的结果只会包含该数组中列出的对象属性</li>
<li>如果第二个参数是一个函数，提供的函数接受两个参数：属性名(key)和属性值(value)，可以根据这个key决定要对应属性做什么。<ul>
<li>函数过滤器会应用到要序列化对象所包含的全部对象。</li>
</ul>
</li>
</ul>
</li>
<li>字符串缩进<ul>
<li>第三个参数可以控制缩进和空格<ul>
<li>是数值是，表示缩进空格数</li>
<li>是字符串时，表示要填充到每一行开头的字符串</li>
<li>无论时那种，最大不超过10个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>简单值<ul>
<li>JavaScript字符串与JSON字符串的主要区别就是JSON字符串必须使用双引号（单引号会导致语法错误）</li>
</ul>
</li>
<li>对象<ul>
<li>有两处不同<ul>
<li>JSON没有变量声明（JSON没有变量）</li>
<li>最后没有分号（不需要，因为不是JavaScript语句）</li>
</ul>
</li>
<li>同样，用引号将属性名包围起来才是有效的JSON。</li>
</ul>
</li>
<li>数组<ul>
<li>和对象差不多</li>
</ul>
</li>
<li>JSON对象<ol>
<li>因为JSON时JavaScript语法的子集，所以eval()可以解析、解释并将其作为JavaScript对象和数组返回。</li>
<li>JSON对象<ul>
<li>Stringify()<ul>
<li>将JavaScript序列化为JSON字符串</li>
</ul>
</li>
<li>parse()<ul>
<li>将JSON解析为原生JavaScript值</li>
</ul>
</li>
</ul>
</li>
<li>扩展<ul>
<li>JSON.Stringify(JSON.parse(str))可以实现深复制对象。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2022/03/19/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><blockquote>
<p>维基百科上说柯里化（Currying）是将一个接收多个参数的函数转换为只接受一个参数（最初函数的第一个参数），并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<h2 id="通过一个例子解释"><a href="#通过一个例子解释" class="headerlink" title="通过一个例子解释"></a>通过一个例子解释</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个 sum 方法，当使用下面的语法调用时，能正常工作</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Outputs 5</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// Outputs 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//正常写法</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//函数柯里化写法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，函数柯里化将这个函数拆分成为多段的函数，每一个阶段都只接受一个参数，逐步得出最终答案。那么为什么需要这样做呢，这样做有什么好处吗？</p>
<h2 id="柯里化的优点"><a href="#柯里化的优点" class="headerlink" title="柯里化的优点"></a>柯里化的优点</h2><ol>
<li><p><strong>参数复用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面的这种做法，正常来说直接调用check进行校验就可以了，但是如果我需要多次校验不同的规则就需要每次都定义规则，使用柯里化之后可以解决复用问题。</p>
</li>
<li><p><strong>提前确认</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//就是把isSupport这个参数给先确定下来了，避免每次都要判断</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">isSupport, element, event, handler</span>) </span>&#123;</span><br><span class="line">    isSupport = isSupport || <span class="built_in">document</span>.addEventListener;</span><br><span class="line">    <span class="keyword">if</span> (isSupport) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>延迟运行</strong></p>
<p>最常见的就是bind，实现的机制就是利用柯里化的延迟运行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thisArg = thisArg || <span class="built_in">window</span></span><br><span class="line">    <span class="keyword">var</span> thisFunc = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thisFunc.apply(thisArg, arg)</span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记14网络请求</title>
    <url>/2021/12/23/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p>Fetch API能够执行XHR对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等陷害Web工具中使用。不同之处在于XHR可以选择同步或异步，但是Fetch API只能选择异步。</p>
<ul>
<li><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>fetch()方法是暴露在全局作用域中的</li>
</ul>
</li>
<li><h4 id="分派请求"><a href="#分派请求" class="headerlink" title="分派请求"></a>分派请求</h4><ul>
<li>fetch()只有一个必须参数input，作为请求URL，这个方法返回一个promise，这个对象是API的封装，可以通过他获取响应的资源。<ul>
<li>在只有一个参数的情况下，默认执行get方法</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="读取响应"><a href="#读取响应" class="headerlink" title="读取响应"></a>读取响应</h4><ul>
<li>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。这个方法返回一个promise，会决议为取得资源的完整内容。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://api.it120.cc/MartinGarrixForTest/mock/data/getMsg&#x27;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><h4 id="处理状态码和请求失败"><a href="#处理状态码和请求失败" class="headerlink" title="处理状态码和请求失败"></a>处理状态码和请求失败</h4><ul>
<li>Fetch API支持通过Response的状态码和状态文本属性检查响应状态。<ul>
<li>由于无论返回的响应式多少，只要返回了响应，那么promise都会决议为resolved状态，这在逻辑上是合理的，所以我们还要在已决议的promise中再去判断状态码，从而执行不同的操作。</li>
<li>注意，如果服务器未响应导致浏览器超时，不符合的跨域请求都会导致fetch（）失败，从而导致promise决议为rejected。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h4><ol>
<li>body<ul>
<li>用于指定使用请求体的内容</li>
</ul>
</li>
<li>credentials<ul>
<li>用于指定在外发请求中包含cookie</li>
</ul>
</li>
<li>method<ul>
<li>用于指定HTTP请求方法</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h4><ul>
<li>顾名思义，Request对象就是获取资源请求接口</li>
<li>创建Request对象<ol>
<li>可以通过构造函数初始化Requset对象，为此需要传入一个input，一般是URL</li>
<li>已接受第二个参数，和fetch()一样</li>
<li>复制request对象，使用clone方法复制，这样不会请求标记为已使用。</li>
<li>在fetch()中使用Request对象，在调用fetch()时，可以传入一创建好的Request实例。</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h4><ul>
<li>headers对象时所有外法请求和入栈响应头部的容器。每个外发的Request实例都包含一个空的Header实例，可以通过Request.prototype.headers访问，每一个入栈的Respone实例也一样。</li>
<li>Headers对象与Map的相似之处<ul>
<li>都有get，set，has和delete</li>
</ul>
</li>
<li>Headers的独特之处<ul>
<li>可以使用键值对的形式初始化Headers对象，Map不行。</li>
</ul>
</li>
<li>头部护卫<ul>
<li>不是所有头部都可以被客户端修改</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="常见的Fetch请求模式"><a href="#常见的Fetch请求模式" class="headerlink" title="常见的Fetch请求模式"></a>常见的Fetch请求模式</h4><ul>
<li><p>发送JSON数据</p>
</li>
<li><p>在请求体中发送参数</p>
<ul>
<li>因为请求体支持任意字符串值，所以可以通过它发送请求参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> param = <span class="string">&#x27;username=admin&amp;pwd=admin&amp;deviceId=1&amp;deviceName=1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> paramHearders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">		<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">fetch(<span class="string">&#x27;https://api.it120.cc/MartinGarrixForTest/user/username/login&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">	<span class="attr">body</span>:param,</span><br><span class="line">	<span class="attr">headers</span>:paramHearders</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>发送文件</p>
<ul>
<li>因为请求体支持FormData实现，所以fetch()也可以序列化并发送文件字段中的文字件。</li>
</ul>
</li>
<li><p>加载blob文件（重点！！）</p>
<ul>
<li>Fetch API也能提供Blob类型的响应，而blob又可以兼容多种浏览器API</li>
</ul>
</li>
<li><p>发送跨域请求</p>
<ul>
<li>从不同的源请求资源，响应要包含CORS头部才能保证浏览器收到响应。没有这些头部，跨域请求会失败。</li>
</ul>
</li>
<li><p>中断请求</p>
<ul>
<li>调用AbortController.abort()会中断所有网络传输。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><ul>
<li><p>Web Socket的目标是通过一个长时间链接实现与服务器全双工、双向的通信（持久化推送消息）。在JavaScript中创建WebSocket时，一个HTTP请求会发送到服务器以初始化链接。服务器响应后，链接使用HTTP的Upgrade头部从HTTP协议切换到web Socket协议。这意味着web Socket不能通过标准的HTTP服务器实现，而必须使用支持该协议的服务器。</p>
</li>
<li><p>因为WebSocket使用自定义协议，所以URL方案稍有变化：不能再使用http://或者https://,而要使用ws://或wss://。前者是不安全链接，后者是安全链接</p>
</li>
<li><p>发送和接收数据，使用send（）方法并传入一个字符串、ArrayBuffer或Blob</p>
</li>
<li><p>API</p>
<ul>
<li>要创建一个新的Web Socket，就要实例化一个WebSocket对象并传入提供链接的URL</li>
<li>注意：必须个WebSocket构造函数传入一个绝对URL。同源策略不适用于Web Socket。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>定义web socket协议的时间比定义JavaScript API时间药厂。Web Socket得到了所有主流浏览器的支持。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>使用自定义协议而非HTTP协议的好处是，客户端与服务器之间可以发送十分少量的数据，不会对HTTP造成负担。</li>
<li>非常适合带宽和延迟比较明显的移动端。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微搭低代码搭建简易扫码系统</title>
    <url>/2022/01/03/%E5%BE%AE%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%89%AB%E7%A0%81%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="搭建前提"><a href="#搭建前提" class="headerlink" title="搭建前提"></a>搭建前提</h2><ol>
<li>找陆哥分配一个团队子账号，后续用这个子账号在团队账号中进行开发。</li>
<li>对微搭平台搭建项目过程有一定了解</li>
</ol>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>通过微信扫码进入小程序或web端，同时能够获取对应的产品信息显示在页面上。</li>
<li>初步想法分为Web端搭建和小程序搭建<ul>
<li>Web端：优势是可以直接请求跳转对应的页面，同时携带请求信息。</li>
<li>小程序端。</li>
</ul>
</li>
</ol>
<h3 id="Web端搭建过程"><a href="#Web端搭建过程" class="headerlink" title="Web端搭建过程"></a>Web端搭建过程</h3><h5 id="技术前提："><a href="#技术前提：" class="headerlink" title="技术前提："></a>技术前提：</h5><ol>
<li>微信扫码的机制是，如果扫描出来的是一个网址，则会自动跳转到该网址</li>
<li>经过测试，扫码出来的url自带后缀如?id=xxx形式不影响跳转结果，同时会保留后缀</li>
</ol>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol>
<li>将二维码设置为网址+id的url形式如<a href="http://www.abc.com/?id=1">http://www.abc.com?id=1</a></li>
<li>扫码后在网址的生命周期内获取url并解析id，请求后台数据并进行显示</li>
</ol>
<h6 id="展示页面"><a href="#展示页面" class="headerlink" title="展示页面"></a>展示页面</h6><ol>
<li><p>创建空白应用</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103100613298.png" alt="image-20220103100613298"></p>
</li>
<li><p>搭建静态页面（根据具体需求进行搭建，这里仅展示本项目需求）</p>
<ol>
<li><p>在变量-变量管理中可以设置好需要绑定的变量，后面需要用到就自行设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101743365.png" alt="image-20220103101743365"></p>
</li>
<li><p>轮播图搭建</p>
<ol>
<li><p>在组件中选择轮播图组件</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101142993.png" alt="image-20220103101142993"></p>
</li>
<li><p>在大纲树中选择轮播图组件，在右侧栏中为每一个图片空位添加绑定的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101232512.png" alt="image-20220103101232512"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101340165.png" alt="image-20220103101340165"></p>
</li>
</ol>
</li>
<li><p>列表项搭建</p>
<ol>
<li><p>在组件中选择列表项添加到项目中</p>
</li>
<li><p>为列表项绑定对应数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103102301713.png" alt="image-20220103102301713"></p>
</li>
<li><p>设置列表项样式，最简单的方式就是两个宽度为50%，向左向右浮动</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103102009355.png" alt="image-20220103102009355"></p>
</li>
</ol>
</li>
<li><p>展示卡搭建</p>
<ol>
<li><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103102423465.png" alt="image-20220103102423465"></li>
<li>其他步骤同上</li>
</ol>
</li>
</ol>
</li>
<li><p>（核心）在首页页面的声明周期钩子onPageLoad/onPageShow处解析url，获取id</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103039110.png" alt="image-20220103103039110"></p>
</li>
<li><p>通过id请求数据并绑定对应数据显示在页面中</p>
<p>这里采用微搭自带数据源搭建方案，详情参考后面后端搭建部分</p>
</li>
<li><p>创建返回首页按钮</p>
</li>
</ol>
<h6 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h6><ol>
<li><p>创建新的空白页</p>
</li>
<li><p>可以选择区块模板快速搭建</p>
</li>
<li><p>设置输入框输入id查询</p>
<ol>
<li><p>一种实现方法</p>
<p>为输入框绑定一个变量，同时给他添加输入改变事件，执行变量赋值绑定变量</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103441767.png" alt="image-20220103103441767"></p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103426252.png" alt="image-20220103103426252"></p>
</li>
<li><p>为下面的按钮绑定自定义事件，让他进行url+前面输入的id跳转</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103752393.png" alt="image-20220103103752393"></p>
</li>
</ol>
</li>
<li><p>设置扫码按钮启用微信浏览器扫码功能</p>
<ol>
<li><p>设置按钮绑定启用扫码功能，关闭自动处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104128747.png" alt="image-20220103104128747"></p>
</li>
<li><p>为扫码成功绑定自定义事件实现跳转</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104154753.png" alt="image-20220103104154753"></p>
</li>
<li><p>扫码成功后绑定的方法中会自动在event参数中注入扫码信息，具体自己分析</p>
</li>
</ol>
</li>
</ol>
<h4 id="后端搭建"><a href="#后端搭建" class="headerlink" title="后端搭建"></a>后端搭建</h4><ol>
<li><p>在微搭控制台-数据源-新建自建数据源</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104754591.png" alt="image-20220103104754591"></p>
</li>
<li><p>在数据源字段添加对应数据（自建数据源有数个自带的字段无法删改，不过影响不大，可以忽略）</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104951906.png" alt="image-20220103104951906"></p>
</li>
<li><p>在方法模块中可以通过云函数操作数据库，本项目中自带的方法已经足够了，就不演示了</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103105153870.png" alt="image-20220103105153870"></p>
</li>
</ol>
<h4 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h4><ol>
<li><p>在前端中需要调用后端的地方调用数据源</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103110405307.png" alt="image-20220103110405307"></p>
</li>
<li><p>获取结果之后绑定到之前为前端页面绑定的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103110626633.png" alt="image-20220103110626633"></p>
</li>
</ol>
<p>最终结果（使用微信扫描）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103163153760.png" alt="image-20220103163153760"></p>
<p>记录一些细节问题：</p>
<ul>
<li>微搭自带扫码方法自动处理是会自动跳转的，但是如果跳转的目标页面有报错则会终止跳转，这个报错似乎是无法避免的，类似于React版本兼容性问题，这就造成了在模拟中能成功跳转，但是发布后无法成功跳转。所以后面采用自定义方法跳转的办法。</li>
<li>由于输入框绑定的值是在表单提交（submit）中生效的数据，对于只有一个输入框的表单来说有点麻烦，所以采用输入值改变绑定值的方法实现，理论上性能不如表单提交，但是更方便。</li>
<li>低代码编辑器中想要使用异步，必须要在生命周期钩子前加asyn异步</li>
</ul>
]]></content>
      <categories>
        <category>微搭低代码</category>
      </categories>
      <tags>
        <tag>团队工作</tag>
      </tags>
  </entry>
  <entry>
    <title>手写call、apply和bind</title>
    <url>/2022/02/22/%E6%89%8B%E5%86%99call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h2 id="手写Call"><a href="#手写Call" class="headerlink" title="手写Call"></a>手写Call</h2><h5 id="Call干了什么"><a href="#Call干了什么" class="headerlink" title="Call干了什么"></a>Call干了什么</h5><p>​    Call()是函数原型方法，Call获取一系列的参数，第一个参数被绑定为被调用函数的this。可以理解为call把函数放到了第一个参数对象里面然后进行调用。第二个及以后的参数是传进这个被执行函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在函数原型上定义一个方法，接收作为this的参数和后续的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context,...arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.判断context是否为空，为空则将this绑定为window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//因为这是函数原型的方法，所以在这个方法中的this就指向需要调用的函数本身</span></span><br><span class="line">    <span class="comment">//3.将函数放到context（this）中去</span></span><br><span class="line">    context.p = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//4.调用这个函数，根据this的默认指向规则，会指向这个context</span></span><br><span class="line">    <span class="keyword">const</span> result = context.p(...arg)</span><br><span class="line">    <span class="comment">//5.记得删除p，避免改变了这个对象</span></span><br><span class="line">    <span class="keyword">delete</span> context.p</span><br><span class="line">    <span class="comment">//6.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;whh&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name+b+c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callName.myCall(a,<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;ee&quot;</span>))		<span class="comment">//whhddee</span></span><br></pre></td></tr></table></figure>

<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><h5 id="apply干了什么"><a href="#apply干了什么" class="headerlink" title="apply干了什么"></a>apply干了什么</h5><p>​    apply（）和call（）一样是函数原型方法，作用与call（）类似，只是接收的参数换成了this的指向和一个参数数组，也就是说原来在call（）中需要一个个输入的函数参数可以整理成数组传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在函数原型上定义一个方法，接收作为this的参数和后续的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context,arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.判断context是否为空，为空则将this绑定为window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//因为这是函数原型的方法，所以在这个方法中的this就指向需要调用的函数本身</span></span><br><span class="line">    <span class="comment">//3.将函数放到context（this）中去</span></span><br><span class="line">    context.p = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//4.调用这个函数，根据this的默认指向规则，会指向这个context</span></span><br><span class="line">    <span class="keyword">const</span> result = context.p(...arg)</span><br><span class="line">    <span class="comment">//5.记得删除p，避免改变了这个对象</span></span><br><span class="line">    <span class="keyword">delete</span> context.p</span><br><span class="line">    <span class="comment">//6.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;whh&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyName</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name+b+c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(applyName.myApply(a,[<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;ee&quot;</span>]))		<span class="comment">//whhddee</span></span><br></pre></td></tr></table></figure>

<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><h5 id="bind干了什么？"><a href="#bind干了什么？" class="headerlink" title="bind干了什么？"></a>bind干了什么？</h5><p>​    bind（）和apply（），call（）的区别在于bind只为函数绑定了this，和传入参数，但是却没有立刻执行它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在函数原型上定义一个方法，接收作为this的参数和后续的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context,arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.判断context是否为空，为空则将this绑定为window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//3.因为这是函数原型的方法，所以在这个方法中的this就指向需要调用的函数本身</span></span><br><span class="line">    <span class="keyword">var</span> thisFunc = <span class="built_in">this</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.因为需要构造函数，所以不能用匿名函数</span></span><br><span class="line">    <span class="keyword">let</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thisFunc.apply(context,arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.需要将原函数的prototype赋值给绑定函数</span></span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="comment">//6.返回函数</span></span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">text</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a+b+<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = text.myBind(person,[<span class="string">&#x27;i &#x27;</span>,<span class="string">&#x27;am &#x27;</span>])</span><br><span class="line">func()				<span class="comment">//i am abc</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise.all、Promise.Race</title>
    <url>/2022/01/03/%E6%89%8B%E5%86%99Promise-all%E3%80%81Promise-Race/</url>
    <content><![CDATA[<h1 id="手写Promise-all"><a href="#手写Promise-all" class="headerlink" title="手写Promise.all()"></a>手写Promise.all()</h1><p>分析：原生Promise.all的作用，接收一个数组，数组内为Promise，Promise.all会自动执行所有数组内的Promise，返回一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Promise</span>.all([promise,promise2]).then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result.message)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103213459296.png" alt="image-20220103213459296"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//resolve(&#x27;1&#x27;)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Promise</span>.all([promise,promise2]).then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result.message)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103214542617.png" alt="image-20220103214542617"></p>
<p>思路：获取所有的Promise，都执行then，把结果放到数组，一起返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>._all = <span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [], promiseCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.map(<span class="function">(<span class="params">v,i</span>) =&gt;</span> &#123;</span><br><span class="line">            v.then(</span><br><span class="line">                <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    promiseCount++</span><br><span class="line">                    results[i] = res</span><br><span class="line">                    <span class="keyword">if</span>(promiseCount === promises.length)&#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(results)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="手写Promsie-race"><a href="#手写Promsie-race" class="headerlink" title="手写Promsie.race"></a>手写Promsie.race</h1><p>分析：race和all差不多，不过一个是获取所有结果，race是获取最早执行的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>._race = <span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">            promise.then(</span><br><span class="line">                <span class="function"><span class="params">res</span> =&gt;</span> resolve(res),</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> reject(err)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写fetch控制并发数</title>
    <url>/2022/03/10/%E6%89%8B%E5%86%99fetch%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="fecth控制并发数"><a href="#fecth控制并发数" class="headerlink" title="fecth控制并发数"></a>fecth控制并发数</h1><p>面试题，实现一个带并发数限制的fetch请求函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendResquest</span>(<span class="params">urls, max</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> pending_count = <span class="number">0</span>, <span class="comment">//并发数</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//当前请求的位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先把请求池填满</span></span><br><span class="line">    <span class="keyword">while</span> (pending_count &lt; max) &#123; </span><br><span class="line">        _fetch(urls[idx++])</span><br><span class="line">    &#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了实现并发，需要嵌套调用fetch</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">_fetch</span>(<span class="params">url</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (!url) <span class="keyword">return</span>; </span><br><span class="line">        pending_count++; </span><br><span class="line">		<span class="built_in">console</span>.log(url+<span class="string">&#x27;:start，并发数:&#x27;</span>+pending_count)</span><br><span class="line">		<span class="keyword">await</span> fetch(url)</span><br><span class="line">		pending_count--</span><br><span class="line">		<span class="built_in">console</span>.log(url+<span class="string">&#x27;:end，并发数:&#x27;</span>+pending_count)</span><br><span class="line">		<span class="comment">//此fetch执行完毕，切换下一个fetch</span></span><br><span class="line">		_fetch(urls[idx++])</span><br><span class="line">		<span class="keyword">if</span>(!pending_count)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;执行完毕&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证</span></span><br><span class="line"><span class="keyword">let</span> urls = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>:<span class="number">7</span>&#125;, <span class="function">(<span class="params">v, k</span>) =&gt;</span> k);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> fetch = <span class="function"><span class="keyword">function</span> (<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> timeout = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1e4</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(idx)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> max = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> callback = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;run callback&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">sendResquest(urls, max, callback)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写new</title>
    <url>/2022/01/11/%E6%89%8B%E5%86%99new/</url>
    <content><![CDATA[<h1 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h1><h3 id="new是什么"><a href="#new是什么" class="headerlink" title="new是什么"></a>new是什么</h3><p>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1)  <span class="comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span></span><br><span class="line">t.sayName() <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出</p>
<ul>
<li>new通过构造函数Person创建出来的实例可以访问到构造函数中的属性</li>
<li>new通过构造函数Person创建出来的实例可以访问到构造函数原型链中的属性（即实例于构造函数通过原型链连接了起来）</li>
</ul>
<p>现在在构建函数中显示加上返回值，并且这个返回值是一个原始类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p>
<p>下面在构造函数中返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// Test &#123; name: &#x27;xxx&#x27; &#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">26</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>从上面的演示中，我们可以看到new关键字主要做了一下工作：</p>
<ul>
<li>创建一个新的对象obj</li>
<li>将对象与构建函数中通过原型链连接起来</li>
<li>将构造函数中的this绑定到新建的对象obj上</li>
<li>根据构造函数返回值的类型做判断，如果是原始值则会忽略，如果是对象，则正常处理</li>
</ul>
<h3 id="手写new操作符"><a href="#手写new操作符" class="headerlink" title="手写new操作符"></a>手写new操作符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">Func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.新对象原型指向构造函数原型对象</span></span><br><span class="line">    obj.__proto__ = Func.prototype</span><br><span class="line">    <span class="comment">// 3.将构建函数的this指向新对象</span></span><br><span class="line">    <span class="keyword">let</span> result = Func.apply(obj, args)</span><br><span class="line">    <span class="comment">// 4.根据返回值判断</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    obj.__proto__ = func.prototype</span><br><span class="line">    <span class="keyword">let</span> result = func.apply(obj, args)</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p = mynew(Person, <span class="string">&quot;huihui&quot;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span></span><br><span class="line">p.say() <span class="comment">// huihui</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写promise</title>
    <url>/2022/01/02/%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>promise是ES6中非常重要的内容，可以说，promise终结了回调地狱的难题，在面试中经常会考Promise的相关原理，因此掌握Promise的底层原理十分重要。</p>
<h2 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h2><ol>
<li><p>正常情况下是通过new Promise方法来创建新的promise，因此手写Promise时可以使用class。</p>
</li>
<li><p>一个Promise接收一个参数，这个参数是一个函数</p>
</li>
<li><p>在这个函数内接收两个参数resolve，reject</p>
</li>
<li><p>状态转换</p>
<p>promise有三种状态，pending，fulfilled，rejected</p>
<ul>
<li>其中默认初始状态为pending</li>
<li>fulfilled和rejected只能通过pending转换过来，且不可逆</li>
</ul>
</li>
<li><p>结果参数</p>
<ul>
<li>当Promise完成执行函数后，会产生一个结果参数，我们需要根据这个结果参数来确定Promise接下来转换的状态</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//promise的基本结构</span></span><br><span class="line"><span class="comment">//原生的promise一般会用new来创建实例，所以这里采用class的方式模拟promise</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建静态属性</span></span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;待定&#x27;</span>; <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;成功&#x27;</span>; <span class="keyword">static</span> REJECTED = <span class="string">&#x27;拒绝&#x27;</span>;</span><br><span class="line">    <span class="comment">//new Promise对象是需要传入一个参数，这个参数是一个函数,所以需要在constructor接收一个函数参数并自动执行它。</span></span><br><span class="line">    <span class="comment">//接收的函数内也可以传入两个参数，resolve和reject</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//默认的状态为pending</span></span><br><span class="line">        <span class="built_in">this</span>.status = myPromise.PENDING</span><br><span class="line">        <span class="comment">//默认结果传参</span></span><br><span class="line">        <span class="built_in">this</span>.result = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//注意由于在执行构造函数中的this在类函数中会丢失，需要重新指定this</span></span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于在类内resolve和reject两个参数还没有定义，需要创造两个参数</span></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.FULFILLED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.REJECTED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在将结果参数传入给resolve和reject时，会发现this指向异常（调用this.status的时候并没有调用this.constructor里面的this.status）</p>
<p>原因：</p>
<ul>
<li>在创建新实例的时候确实创建了新的this.status</li>
<li>但是目前我们是在新实例被创建后再在外部环境下执行resolve方法，此时this就会丢失</li>
</ul>
<p>解决方法：</p>
<ul>
<li>在执行resolve，reject前为其绑定this</li>
</ul>
<h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>Promise.then是Promise中一个非常重要的功能，第一参数执行resolve方法，第二个参数执行reject方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">        onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">        onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行异常"><a href="#执行异常" class="headerlink" title="执行异常"></a>执行异常</h2><p>在Promise中报错是不会被直接抛出的，如果在执行过程中出现报错，则会直接转换状态为rejected并且在结果参数中输出报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.result = <span class="literal">null</span></span><br><span class="line"><span class="comment">//执行前判断生成的实例有没有报错，有就直接reject</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//注意由于在执行构造函数中的this在类函数中会丢失，需要重新指定this</span></span><br><span class="line">    func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Error</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.reject(<span class="built_in">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Promise.then中如果传入的参数不是函数是会被静默忽略掉的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断参数类型，非函数参数转换为函数</span></span><br><span class="line">    onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">        onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">        onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>Promise中的回调函数是异步执行的，并且执行顺序是同步&gt;微内核任务（Promsie）&gt;宏内核任务（SetTimeout）</p>
<p>在这里使用setTimeout模拟异步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="comment">//异步执行，注意Promise中的回调是异步执行的，并且是微内核，即执行顺序为同步&gt;Promise&gt;setTimeout</span></span><br><span class="line"><span class="comment">//then内部的函数应该使用一个数组保存起来，直到Promise完成响应之后再执行，否则then检测到此时状态为peding则会不执行</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断参数类型，非函数参数转换为函数</span></span><br><span class="line">        onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回调保存"><a href="#回调保存" class="headerlink" title="回调保存"></a>回调保存</h2><p>Promise在执行异步任务的时候由于then不是异步的，所以需要先用数组保存then中的函数，等待Promise决议完成之后再执行对应的函数</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>我们常常在Promise中使用Promise.then().then()，这就是链式调用，这是解决回调地狱的关键。</p>
<ol>
<li><p>通常来说，调用.then()返回的是一个新的Promise，对于这个返回值，有</p>
<ul>
<li>将这个新Promise传递到下一个then中</li>
<li>如果返回一个普通的值，则将这个普通的值传递到下一个then中</li>
</ul>
</li>
<li><p>当我们在第一个then()中return了一个参数（参数未知，需要判断）。这个return出来的新的promsie就是onFulfilled（）或者onRejected（）的值</p>
</li>
<li><p>为了满足上述的要求，就需要一个额外的函数用来判断返回值，并做出响应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//禁止循环引用，会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">        <span class="comment">//出现循环则直接抛出错误</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">//x为普通值，则直接返回解决；若x为对象或者函数且不为null，则判断是否仍然是promise</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//取得函数的下一个then</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="comment">//如果下一个then仍然是函数，则说明还有下一层，默认为Promise</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.call(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//由于结果依旧是promise,继续向下解析</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//拒绝之后后续的所有Promise都会被拒绝</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="完整的仿写Promise"><a href="#完整的仿写Promise" class="headerlink" title="完整的仿写Promise"></a>完整的仿写Promise</h2><p>功能：resolve，reject，then，异步执行，链式调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//promise的基本结构</span></span><br><span class="line"><span class="comment">//原生的promise一般会用new来创建实例，所以这里采用class的方式模拟promise</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建静态属性</span></span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;待定&#x27;</span>; <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;成功&#x27;</span>; <span class="keyword">static</span> REJECTED = <span class="string">&#x27;拒绝&#x27;</span>;</span><br><span class="line"><span class="comment">//new Promise对象是需要传入一个参数，这个参数是一个函数,所以需要在constructor接收一个函数参数并自动执行它。</span></span><br><span class="line"><span class="comment">//接收的函数内也可以传入两个参数，resolve和reject</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//默认的状态为pending</span></span><br><span class="line">    <span class="built_in">this</span>.status = myPromise.PENDING</span><br><span class="line">    <span class="comment">//默认结果传参</span></span><br><span class="line">    <span class="built_in">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//创建临时数组用于在Promise还没有决议前保存then中的待执行函数</span></span><br><span class="line">    <span class="built_in">this</span>.resolveCallbacks = []</span><br><span class="line">    <span class="built_in">this</span>.rejectCallbacks = []</span><br><span class="line">    <span class="comment">//执行前判断生成的实例有没有报错，有就直接reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意由于在执行构造函数中的this在类函数中会丢失，需要重新指定this</span></span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">Error</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.reject(<span class="built_in">Error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于在类内resolve和reject两个参数还没有定义，需要创造两个参数</span></span><br><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.FULFILLED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">            <span class="comment">//执行待执行的函数</span></span><br><span class="line">            <span class="built_in">this</span>.resolveCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.REJECTED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">            <span class="comment">//执行待执行的函数</span></span><br><span class="line">            <span class="built_in">this</span>.rejectCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="comment">//异步执行，注意Promise中的回调是异步执行的，并且是微内核，即执行顺序为同步&gt;Promise&gt;setTimeout</span></span><br><span class="line"><span class="comment">//then内部的函数应该使用一个数组保存起来，直到Promise完成响应之后再执行，否则then检测到此时状态为peding则会不执行</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断参数类型，非函数参数转换为函数</span></span><br><span class="line">        onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING)&#123;</span><br><span class="line">            <span class="built_in">this</span>.resolveCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//获取解决的结果</span></span><br><span class="line">                <span class="keyword">let</span> x = onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">                <span class="comment">//在这个函数中判断返回的值，并作不同处理</span></span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">this</span>.rejectCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//禁止循环引用，会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">        <span class="comment">//出现循环则直接抛出错误</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">//x为普通值，则直接返回解决；若x为对象或者函数且不为null，则判断是否仍然是promise</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//取得函数的下一个then</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="comment">//如果下一个then仍然是函数，则说明还有下一层，默认为Promise</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.call(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//由于结果依旧是promise,继续向下解析</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//拒绝之后后续的所有Promise都会被拒绝</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第一步&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二步&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第五步&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(<span class="string">&#x27;第四步&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result)),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result.message))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第三步&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码（原生Promise）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第一步&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二步&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第五步&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(<span class="string">&#x27;第四步&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result)),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result.message))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第三步&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>从测试代码中可以发现，异步调用中的微内核任务没有实现。同时还有Promise.all(),Promise.race(),Promise值穿透等等功能待实现，Promise是一个复杂但是十分有用的技术，多阅读源码可以有效提高自己的代码水平。</p>
]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写深复制</title>
    <url>/2022/01/10/%E6%89%8B%E5%86%99%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h1><p>在JavaScript中拷贝分为两种，浅拷贝和深拷贝。首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。</p>
<ul>
<li>浅拷贝：将b对象拷贝到a对象中，但是不包括b内的子对象</li>
<li>深拷贝：将b对象拷贝到a对象中，包括b内的子对象</li>
</ul>
<h3 id="实现深拷贝的两种方案"><a href="#实现深拷贝的两种方案" class="headerlink" title="实现深拷贝的两种方案"></a>实现深拷贝的两种方案</h3><h5 id="JSON转换"><a href="#JSON转换" class="headerlink" title="JSON转换"></a>JSON转换</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>

<p>缺点：如果对象里面有函数，函数无法被拷贝下来</p>
<h5 id="遍历函数深拷贝"><a href="#遍历函数深拷贝" class="headerlink" title="遍历函数深拷贝"></a>遍历函数深拷贝</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//检查参数类型,刨除数组和对象以外的数据类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="comment">//剔除原型链上的不相关属性</span></span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">            result[key] = deepCopy(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>to be continue…</p>
]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写reduce、用reduce实现map</title>
    <url>/2022/01/04/%E6%89%8B%E5%86%99reduce%E3%80%81%E7%94%A8reduce%E5%AE%9E%E7%8E%B0map/</url>
    <content><![CDATA[<h1 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h1><p>reduce是JavaScript原生的数组操作方法，功能强大</p>
<p><strong>reducer</strong> 函数接收4个参数:</p>
<ol>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
</ol>
<p>您的 <strong>reducer</strong> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reduce用法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.reduce(<span class="function">(<span class="params">acc,cur,idx,arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc+cur</span><br><span class="line">&#125;,<span class="number">1</span>))</span><br><span class="line"><span class="comment">//22</span></span><br></pre></td></tr></table></figure>

<p>原生实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最好不要使用箭头函数，因为this指向会不正确</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">func,init</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this指向调用reduce方法的数组</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//初始的累计器需要额外赋值，没有的话默认为数组的第一项</span></span><br><span class="line">    <span class="keyword">var</span> total = init!=<span class="literal">null</span>?init:arr[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//这里要注意如果没有指定初始值和指定初始值为0是不同的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = (init!=<span class="literal">null</span>?<span class="number">0</span>:<span class="number">1</span>);i&lt;arr.length;i++)&#123;</span><br><span class="line">        total = func(total, arr[i], i, arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用map实现reduce</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最好不要使用箭头函数，因为this指向会不正确</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">func,init</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this指向调用reduce方法的数组</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//初始的累计器需要额外赋值，没有的话默认为数组的第一项</span></span><br><span class="line">    <span class="keyword">var</span> total = init || arr[<span class="number">0</span>]</span><br><span class="line">    arr.map(<span class="function">(<span class="params">v,i</span>) =&gt;</span> &#123;</span><br><span class="line">        i!=init?total = func(total, v, i, arr):<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用reduce实现map</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用reduce实现map</span></span><br><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">func,thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">total,cur,idx,arr</span>) =&gt;</span> &#123;</span><br><span class="line">        result[idx] = func.call(thisArg,cur,idx,arr);\</span><br><span class="line">        <span class="comment">//这里并不关心累加器的值，但是为了让reduce从第一个元素开始遍历，为累加器赋初始值0</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _mapArr = arr._map(<span class="function"><span class="keyword">function</span>(<span class="params">v, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v+i+<span class="built_in">this</span>.length;</span><br><span class="line">&#125;, arr2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_mapArr);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统01-进程与线程</title>
    <url>/2022/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是具有独立功能的程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>一个进程由数据段，程序段和PCB组成</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的过程</li>
<li>并发性：内存中由多个进程实体，各进程可以并发地执行</li>
<li>独立性：进程是能独立运行、独立获取资源、独立接收调度的基本单位。进程是资源分配、接收调度的基本单位。</li>
<li>异步性：操作系统要提供“进程同步机制”来解决异步的问题</li>
<li>结构性：每个进程都会配置一个PCB。从结构上看，进程就是由程序段、数据段、PCB组成</li>
</ol>
<h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><p>进程是程序的一次执行过程，是一个动态地过程，所以需要有不同的状态来表示当前进程。</p>
<h4 id="状态（五状态模型）"><a href="#状态（五状态模型）" class="headerlink" title="状态（五状态模型）"></a>状态（五状态模型）</h4><ol>
<li>创建态</li>
<li>运行态：CPU √ 其他所需资源 √</li>
<li>就绪态：CPU X 其他所需资源 √</li>
<li>阻塞态：CPU X 其他所需资源 X</li>
<li>终止态</li>
</ol>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/bac75870ed8213f3c10f2ecc2f7cb9d.png" alt="bac75870ed8213f3c10f2ecc2f7cb9d"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制是用于实现进程状态的转换的</p>
<h4 id="进程控制使用原语实现"><a href="#进程控制使用原语实现" class="headerlink" title="进程控制使用原语实现"></a>进程控制使用原语实现</h4><ul>
<li>原语用关/开中断实现，即在原语执行过程中，不允许中断</li>
<li>原语是一种特殊的程序，只运行在核心态</li>
<li>原语的执行必须一气呵成，不可以中断</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>在多进程处理器中，不同的进程之间可能需要进行通信。下面提供了三种通信方式</p>
<h4 id="共享储存"><a href="#共享储存" class="headerlink" title="共享储存"></a>共享储存</h4><ul>
<li>设置一个共享空间</li>
<li>不同进程要互斥地访问共享空间</li>
<li>有两种方式，一种基于数据结构（低级），另一种基于存储去的共享（高级）</li>
</ul>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul>
<li>设置一个特殊的共享文件（管道，其实就是一个缓冲区域）</li>
<li>一个管道只能实现半双工通信，两个管道才能实现全双工</li>
<li>各个进程要互斥访问管道（p,v操作）</li>
<li>写满时候，不能再写。读空时，不能再读</li>
<li>没写满，不能读。没读空，不能写</li>
</ul>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><ul>
<li>传递结构化的消息（消息头/消息体，类似于计算机网络中的报文）</li>
<li>系统提供“发送/接收原语”</li>
<li>有两种方式，一种消息直接挂到接收方的消息队列里面，另一种消息先发到中间件（信箱）</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul>
<li>线程是处理及调度的单位</li>
<li>在多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程之间共享进程的资源</li>
<li>由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程的切换</li>
<li>不同进程中的线程切换，会引起进程的切换</li>
<li>切换同进程内的线程，系统开销会很小</li>
<li>切换进程，系统开销比较大</li>
</ul>
<h2 id="进程的同步和互斥"><a href="#进程的同步和互斥" class="headerlink" title="进程的同步和互斥"></a>进程的同步和互斥</h2><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程是并发进行的，这就带来了异步问题，例如，进程1需要获得进程2的计算结果，如何能保证进程1一定在进程2之后才执行呢？也就是说，各进程的工作推进需要遵循一定的先后顺序。</p>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>进程对于临界资源的访问，需要互斥地进程。即同一时间段内只允许一个进程访问该资源</p>
<p>需要遵循的原则：</p>
<ol>
<li>空闲让进：只要临界资源空闲，且有进程请求资源，则分配资源</li>
<li>忙则等待：如果临界资源已被占用，则将进程挂起，等待资源释放</li>
<li>有限等待：进程挂起时间不能太长，否则会造成进程饥饿</li>
<li>让权等待：优先级高的进程优先使用资源</li>
</ol>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>在实现进程的同步互斥中，人们找到一种比较理想的实现方式，就是信号量机制。</p>
<p>首先规定临界资源的可用数量，用一个公共信号量表示他，每个进程在请求资源的时候，都对该信号量减一（p操作），同时检测此时信号量是否为负（没有可用资源），为负则挂起，不为负数则请求成功。等待进程完成之后，再对信号量加一（v操作），从而实现进程的互斥。</p>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><ol>
<li>S.value表示某种资源数，S.L指向等待资源的队列</li>
<li>P操作中，一定是先S.value–，之后可能需要执行block原语</li>
<li>V操作中，一定是先S.value++，之后可能需要执行wakeup原语</li>
<li>注意：要能够自己推断在什么条件下需要执行block或者wakeup</li>
<li>可以用记录型信号量实现系统资源的“申请”和“释放”</li>
<li>可以用记录型信号量实现进程互斥、进程同步</li>
</ol>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>按某种算法选择一个进程将处理机分配给它</p>
<h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h3><p>高级调度（作业调度）<br>    从后备队列中选择合适的作业将其调入内存，并为其创建进程<br>中级调度（内存调度）<br>    从观其队列中选择合适的进程将其数据调回内存<br>低级调度（进程调度）<br>    从就绪队列中选择一个进程为其分配处理机器</p>
<h3 id="三层调度的联系、对比"><a href="#三层调度的联系、对比" class="headerlink" title="三层调度的联系、对比"></a>三层调度的联系、对比</h3><p>高级调度<br>    外存-&gt;内存（面向作业）<br>中级调度<br>    外存-&gt;内存（面向进程）<br>低级调度<br>    内存-&gt;CPU<br>补充知识<br>    为减轻系统负载，提高资源的利用率，暂时不执行的进程会被调到外存从而变成“挂起态”<br>    七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”，如图二</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/fd03e5db5a7015edaaa8b5248f74944.png" alt="fd03e5db5a7015edaaa8b5248f74944"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器跨域</title>
    <url>/2022/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="浏览器跨域"><a href="#浏览器跨域" class="headerlink" title="浏览器跨域"></a>浏览器跨域</h1><h3 id="跨域的定义"><a href="#跨域的定义" class="headerlink" title="跨域的定义"></a>跨域的定义</h3><p>跨域是指从一个域名的网页去请求另一个域名的资源，就会发生跨域。只要协议，域名，端口有任何一个不同就算做跨域。</p>
<p>浏览器执行JavaScript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</p>
<p>对于端口和协议的不同，只能通过后台来解决。</p>
<h3 id="浏览器为什么要限制跨域"><a href="#浏览器为什么要限制跨域" class="headerlink" title="浏览器为什么要限制跨域"></a>浏览器为什么要限制跨域</h3><p><strong>安全问题</strong>：如果一个网页可以随意的访问另外一个网站的资源，那么就有可能再客户完全不知情的情况下获取客户的个人资料从而出现安全问题</p>
<h3 id="为什么要进行跨域"><a href="#为什么要进行跨域" class="headerlink" title="为什么要进行跨域"></a>为什么要进行跨域</h3><p>设想一个场景，一个公司有很多的子域，这些子域之间进行访问资源的时候就需要进行跨域</p>
<h3 id="跨域的解决办法"><a href="#跨域的解决办法" class="headerlink" title="跨域的解决办法"></a><strong>跨域的解决办法</strong></h3><ol>
<li><h5 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h5><p>CORS允许浏览器向跨域的服务器发出XMLHttpRequest请求，克服了AJAX只能同源使用的限制。</p>
<p><strong>CORS需要服务器和浏览器都支持</strong>目前所有浏览器都支持CORS。整个CORS通信完全由浏览器自动进行，对于开发者来说，CORS通信与普通的AJAX通信没有任何区别，代码完全一致。浏览器一旦发现AJAX进行跨域请求，就会自动添加一些请求头，有时还会额外请求，但用户不会感知。因此，实现CORS通信的关键时服务器端要支持。</p>
</li>
<li><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p><strong>原理</strong>：通过script标签引入一个js文件（script标签不受跨域限制），这个js 文件载入成功后会执行我们在url中指定的函数，并且会把我们需要的json数据作为参数传入。JSONP需要服务器进行配合，返回一个可执行的js我呢见，其中包含所需数据。</p>
<p><strong>优点</strong>：兼容性好</p>
<p><strong>缺点</strong>：它只支持GET请求而不支持POST等其他类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何让进行Javascript调用的问题。</p>
<h6 id="手写一个简单的JSONP例子"><a href="#手写一个简单的JSONP例子" class="headerlink" title="手写一个简单的JSONP例子"></a>手写一个简单的JSONP例子</h6><p>服务端部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//	因为我们是利用script标签的src请求这个接口地址http://127.0.0.1:8081/，所以我们需要设置响应头为js格式</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/javascript&#x27;</span> &#125;);</span><br><span class="line">    <span class="comment">//然后返回js格式代码回去</span></span><br><span class="line">    response.end(<span class="string">&#x27;var a=1&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="number">8081</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><h5 id="通过修改document-domain来跨子域"><a href="#通过修改document-domain来跨子域" class="headerlink" title="通过修改document.domain来跨子域"></a>通过修改document.domain来跨子域</h5><p><strong>原理</strong>：通过修改域名设置成相同的主域就可以跨域</p>
<p>document.domain是有限制的，我们只能设置成高一级的域名或者自身，且主域必须相同。所以只适用不同子域的框架间交互</p>
</li>
<li><h5 id="使用window-name进行跨域"><a href="#使用window-name进行跨域" class="headerlink" title="使用window.name进行跨域"></a>使用window.name进行跨域</h5><p><strong>原理</strong>：Window对象的name属性有个特点：即在一个窗口的生命周期内，该窗口所有载入的网页共享一个window.name，且每个页面对window.name都有读写权限</p>
<p>在网页中使用一个隐藏的iframe来充当中间人，让这个iframe去请求数据，然后再网页中获取这个iframe的数据。还必须把这个iframe的src设成跟a.html页面同一个域才行，否则根据同源策略，获取不到iframe的数据。</p>
</li>
<li><h5 id="使用h5的window-postMessage进行跨域"><a href="#使用h5的window-postMessage进行跨域" class="headerlink" title="使用h5的window.postMessage进行跨域"></a>使用h5的window.postMessage进行跨域</h5><p><strong>原理</strong>：<strong>window.postMessage</strong>(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>
<p>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。</p>
<p>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。</p>
</li>
<li><h5 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h5><p><strong>原理</strong>：web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p>
<p>web sockets原理：在<a href="http://lib.csdn.net/base/javascript">js</a>创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划</title>
    <url>/2022/01/24/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划，简称DP，将问题分解为互相重叠的子问题，通过反复求解子问题解决原问题就是动态规划，如果某一问题有很多重叠子问题，使用动态规划来解决是比较有效的。</p>
<p>求接动态规划的核心问题就是穷举，但是这类问题穷举存在重叠子问题，直接求解效率回十分低下。动态规划问题一定回具备最优子结构，才能通过子问题的最值得到原问题的最值。另外，虽然动态规划的核心是穷举求最值，但是穷举所有可行解并不是一件容易的事，只有列出正确的”状态转移方程”，才能正确的穷举。重叠子问题、最有子结构、状态转移方程就是动态规划的三要素。</p>
<h4 id="动态规划和其他算法的区别："><a href="#动态规划和其他算法的区别：" class="headerlink" title="动态规划和其他算法的区别："></a>动态规划和其他算法的区别：</h4><ol>
<li>动态规划和分治的区别：动态规划和分治都有最优子结构 ，但是分治的子问题不重叠</li>
<li>动态规划和贪心的区别：动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优解，所以它永远是局部最优，但是全局的解不一定是最优的。</li>
<li>动态规划和递归的区别：递归和回溯可能存在非常多的重复计算，动态规划可以用递归加记忆化的方式减少不必要的重复计算</li>
</ol>
<h4 id="解动态规划题目的步骤"><a href="#解动态规划题目的步骤" class="headerlink" title="解动态规划题目的步骤"></a>解动态规划题目的步骤</h4><ol>
<li>根据重叠子问题定义状态</li>
<li>寻找最优子结构推导状态转移方程</li>
<li>确定dp初始状态</li>
<li>确定输出值</li>
</ol>
<h4 id="力扣509-斐波那契数"><a href="#力扣509-斐波那契数" class="headerlink" title="力扣509. 斐波那契数"></a>力扣<a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><ul>
<li>思路：对于除了第一二个数外的数，都是由前两个数求和而得出，因此有状态转移方程dp[i] = dp[i-1]+dp[i-2]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">const</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//自底向上计算每个状态</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="力扣62-不同路径"><a href="#力扣62-不同路径" class="headerlink" title="力扣62. 不同路径"></a>力扣<a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4><ul>
<li>思路:由于在每个位置只能向下或者向右， 所以每个坐标的路径和等于上一行相同位置和上一列相同位置不同路径的总和，状态转移方程：<code>f[i][j] = f[i - 1][j] + f[i][j - 1]</code>;</li>
<li>复杂度:时间复杂度<code>O(mn)</code>。空间复杂度<code>O(mn)</code>，优化后<code>O(n)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>)); <span class="comment">//初始dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">//初始化列</span></span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">//初始化行</span></span><br><span class="line">        f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态压缩</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">1</span>; r &lt; n; r++) &#123;</span><br><span class="line">            cur[r] = cur[r - <span class="number">1</span>] + cur[r];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h4><ul>
<li>思路：和62题一样，区别就是遇到障碍直接返回0</li>
<li>复杂度：时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>，状态压缩之后是o(n)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">const</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>(m)</span><br><span class="line">        .fill()</span><br><span class="line">        .map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>)); <span class="comment">//初始dp数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] === <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//初始列</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][i] === <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//初始行</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">//遇到障碍直接返回0</span></span><br><span class="line">            dp[i][j] = obstacleGrid[i][j] === <span class="number">1</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态压缩</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">let</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>(n).fill(<span class="number">0</span>); <span class="comment">//用0填充，因为现在有障碍物，当前dp数组元素的值还和obstacleGrid[i][j]有关</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//第一列 暂时用1填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//注意条件，遇到障碍物dp[j]就变成0，这里包含了第一列的情况</span></span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//只有当j&gt;0 不是第一列了才能取到j - 1</span></span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><ul>
<li>思路：<code>dp[i]</code> 表示<code>i</code>的完全平方和的最少数量，<code>dp[i - j * j] + 1</code>表示减去一个完全平方数<code>j</code>的完全平方之后的数量加1就等于<code>dp[i]</code>，只要在<code>dp[i]</code>, <code>dp[i - j * j] + 1</code>中寻找一个较少的就是最后<code>dp[i]</code>的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [...Array(n)].map(<span class="function">(<span class="params">_</span>) =&gt;</span> <span class="number">0</span>); <span class="comment">//初始化dp数组 当n为0的时候</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i; <span class="comment">// 最坏的情况就是每次+1 比如: dp[3]=1+1+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123;<span class="comment">//枚举前一个状态</span></span><br><span class="line">            dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// 动态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2022/03/19/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p>防抖和节流是JavaScript中经常遇到的性能优化问题。</p>
<p>在前端开发中我们经常需要绑定一些高频率触发的事件，例如滚动条滚动事件。但是这种事件触发频率实在太高了，如果每次触发都进行响应会极大地消耗浏览器的资源，为此，我们需要一种方法在一段时间内只触发一次事件，其余的触发事件进行忽略，这样就可以节省资源。</p>
<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>防抖是性能优化的一种思路，<strong>在第一次触发事件的时候，不立即执行函数，而是设定一个时间段，例如200ms，然后：</strong></p>
<ul>
<li>如果这段时间内没有再次触发事件，则倒计时结束执行此函数</li>
<li>如果这段时间内再次触发事件，则倒计时刷新并重复前面的步骤</li>
</ul>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p>
<p><strong>实现</strong>：需要计时的需求，就用setTimeout来实现，考虑维护全局纯净，可以使用闭包来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">//借助闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer) </span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn,delay) <span class="comment">// 简化写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个防抖函数，我们可以传入需要执行的函数和间隔时间，他会帮我们自动进行防抖</p>
<h2 id="节流（throrrle）"><a href="#节流（throrrle）" class="headerlink" title="节流（throrrle）"></a>节流（throrrle）</h2><p>节流是性能优化的另一种思路，<strong>设计一种类似阀门一样定期开放的函数，允许函数首先执行一次，然后再让它一段时间内失效，过了这段时间后再重新激活。</strong></p>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，<strong>在函数执行一次之后，该函数在指定的时间期限内不再工作</strong>，直至过了这段时间才重新生效。</p>
<p><strong>实现</strong>：同样借助setTimeout来做一个简单的实现，加上一个状态位来表示当前函数是否处于工作状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">           <span class="comment">//休息时间 暂不接客</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span></span><br><span class="line">        valid = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn()</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>面经摘抄01</title>
    <url>/2022/03/07/%E9%9D%A2%E7%BB%8F%E6%91%98%E6%8A%8401/</url>
    <content><![CDATA[<h1 id="面经摘抄"><a href="#面经摘抄" class="headerlink" title="面经摘抄"></a>面经摘抄</h1><p>从各大网站面经中学习到的不错的问题</p>
<ol>
<li><h5 id="讲了讲有哪些宏任务和微任务，以及它们的循环方式"><a href="#讲了讲有哪些宏任务和微任务，以及它们的循环方式" class="headerlink" title="讲了讲有哪些宏任务和微任务，以及它们的循环方式"></a>讲了讲有哪些宏任务和微任务，以及它们的循环方式</h5><p>宏任务：JavaScript大部分代码，SetTimeout，setInterval，setImmediate（Nodejs环境）</p>
<p>微任务：Promise.then，Promise,catch，Promise.finally，process.nextTick(Nodejs环境)</p>
<p>循环方式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/v2-e6dd78c74cb671dd9408c2273308a265_1440w.jpg" alt="v2-e6dd78c74cb671dd9408c2273308a265_1440w"></p>
<h6 id="思考：如何实现这种循环？"><a href="#思考：如何实现这种循环？" class="headerlink" title="思考：如何实现这种循环？"></a>思考：如何实现这种循环？</h6><p>考虑到事件循环是在一个队列中的顺序循环，所以可以考虑使用链表这种数据结构存储任务，既保证队列，又保证顺序，再将宏任务和微任务的规则用代码实现。</p>
</li>
<li><h5 id="垂直水平居中方式"><a href="#垂直水平居中方式" class="headerlink" title="垂直水平居中方式"></a>垂直水平居中方式</h5><ul>
<li><p>使用绝对定位脱离文档流的方法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220307201830955.png" alt="image-20220307201830955"></p>
</li>
<li><p>使用flex弹性定位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220307202159649.png" alt="image-20220307202159649"></p>
</li>
</ul>
</li>
<li><h5 id="Set、Map、WeakMap、WeakSet-区别（各自的-API，WeakMap-和-WeakSet-可迭代吗，JS-垃圾回收机制对-WeakMap-和-WeakSet-的影响）"><a href="#Set、Map、WeakMap、WeakSet-区别（各自的-API，WeakMap-和-WeakSet-可迭代吗，JS-垃圾回收机制对-WeakMap-和-WeakSet-的影响）" class="headerlink" title="Set、Map、WeakMap、WeakSet 区别（各自的 API，WeakMap 和 WeakSet 可迭代吗，JS 垃圾回收机制对 WeakMap 和 WeakSet 的影响）"></a>Set、Map、WeakMap、WeakSet 区别（各自的 API，WeakMap 和 WeakSet 可迭代吗，JS 垃圾回收机制对 WeakMap 和 WeakSet 的影响）</h5><p>WeakMap和WeakSet相比与Map和Set就像是低配版，它们对于键值对或值的关联性不够紧密，当键值对的值发生变化的时候，Weak的关联会断开。</p>
<p>WeakMap和WeakSet不可以迭代，因为它们的结构松散，随时可能发生改变，迭代没有意义。js垃圾回收机制也不受影响，如果是Map和Set会阻止垃圾回收，只要它们还保留着引用。</p>
</li>
<li><h5 id="Vue-组件间通信方式"><a href="#Vue-组件间通信方式" class="headerlink" title="Vue 组件间通信方式"></a>Vue 组件间通信方式</h5><ul>
<li><p>prop（父传子）</p>
</li>
<li><p>emit（子传父）</p>
</li>
<li><p>this.$parent（Vue3中被废弃）</p>
</li>
<li><p>事件总线bus</p>
<p>在项目创建一个额外的js文件作为通信中间件</p>
</li>
<li><p>VueX</p>
<p>Vue官方推荐使用的方式，不过如果项目不大没有必要。</p>
</li>
</ul>
</li>
<li><h5 id="Vue-中-key-的作用，为什么有高效性？"><a href="#Vue-中-key-的作用，为什么有高效性？" class="headerlink" title="Vue 中 key 的作用，为什么有高效性？"></a>Vue 中 key 的作用，为什么有高效性？</h5><p>Vue中的Key可以用来唯一确定一个DOM元素，从而使diff算法更加高效。</p>
<p>因为Vue实现了一套虚拟DOM系统，具体原理就是因为当页面做出变化的时候每次都直接修改真实DOM会比较浪费资源，所以Vue中每次页面发生变化的时候都是优先在虚拟DOM中产生变化，然后diff算法会去逐一比较同一层次的真实DOM和虚拟DOM，然后以最小量的方式去修改真实DOM，Key的作用就是在diff算法中使Vue更容易定位DOM。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/20191118120109728.png" alt="20191118120109728"></p>
</li>
<li><h5 id="单行文本省略，多行文本省略分情况实现"><a href="#单行文本省略，多行文本省略分情况实现" class="headerlink" title="单行文本省略，多行文本省略分情况实现"></a>单行文本省略，多行文本省略分情况实现</h5><p>单文本</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>; </span><br><span class="line">    <span class="comment">/*设置文字在一行显示，不能换行*/</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/*规定当文本溢出时，显示省略符号来代表被修剪的文本*/</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis; </span><br><span class="line">    <span class="comment">/*文字长度超出限定宽度，则隐藏超出的内容*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="async和await的原理"><a href="#async和await的原理" class="headerlink" title="async和await的原理"></a>async和await的原理</h5><p>async函数返回一个Promise对象，当函数执行的时候，一旦遇到awiat就会先返回，等到触发的异步操作完成，才会接着执行函数体后面的的语句。async函数就是Generator函数的语法糖。<a href="https://stoneocean.top/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/">详见</a></p>
</li>
<li><h5 id="Http0-9，Http1-0，Http2-0，Http3-0简介"><a href="#Http0-9，Http1-0，Http2-0，Http3-0简介" class="headerlink" title="Http0.9，Http1.0，Http2.0，Http3.0简介"></a>Http0.9，Http1.0，Http2.0，Http3.0简介</h5><p>Http0.9是一个初期基本协议，只有get请求，只用于获取html</p>
<p>Http1.0支持 HEAD，POST 方法，支持状态码，但是规定只能短链接，频繁请求会使网络负担大</p>
<p>Http1.1支持了TCP长连接，同时引入Cookie网络安全机制</p>
<p>Http2.0支持二进制传输，使用HPACK算法压缩头部，可以同时在一个连接中发送多个请求。</p>
<p>Http3.0添加QUIC协议，基于UDP协议，之前的版本都只支持TCP协议，如果网络不好或者频繁切换网络环境的话TCP会一直断开重连，UCP协议解决了</p>
<p>1.线头阻塞问题：TCP协议重如果又数据丢包，需要等待重传，浪费后续资源</p>
<p>2.切换网络是保持连接：从4g切换为5g时候，TCP协议会重连，但是UDP协议通过内建协议不必重连</p>
</li>
<li><h5 id="Nodejs使用Proxy代理跨域的原理"><a href="#Nodejs使用Proxy代理跨域的原理" class="headerlink" title="Nodejs使用Proxy代理跨域的原理"></a>Nodejs使用Proxy代理跨域的原理</h5><p>在浏览器中跨域访问是被禁止的，但是在服务器中没有这个限制，所以我们想要在前端实现跨域请求的话可以把请求发送到自己的服务端，再让服务端去请求目标服务器，这样就不会有跨域的限制。</p>
<h6 id="配置代码："><a href="#配置代码：" class="headerlink" title="配置代码："></a>配置代码：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dev&#123;</span><br><span class="line">    <span class="attr">proxyTable</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">            <span class="attr">target</span>:<span class="string">&#x27;http://192.168.0.1&#x27;</span>,<span class="comment">//要代理的域名</span></span><br><span class="line">            <span class="attr">changeOrigin</span>:<span class="literal">true</span>,<span class="comment">//允许跨域</span></span><br><span class="line">            pathRewrite：&#123;</span><br><span class="line">                ‘/api<span class="string">&#x27;:&#x27;</span><span class="string">&#x27;,//这个是定义要访问的路径</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：以这种写法，会将请求中所有带有/api字段替换掉，因此在代理数量比较多的时候容易出问题。</p>
</li>
<li><h5 id="JavaScript异步发展史"><a href="#JavaScript异步发展史" class="headerlink" title="JavaScript异步发展史"></a>JavaScript异步发展史</h5><p>JavaScript本身是单线程语言，也就是同步的，这意味着有可能会阻塞，当有一个任务需要的时间较长的时候，后面的代码会需要等待他完成后才能执行。而异步方式不会，异步代码不需要阻塞，可以优先让其他任务执行。</p>
<p>异步发展史有：回调函数——&gt;Promise——&gt;Generator——&gt;async/await</p>
<ol>
<li><p>回调函数：callback</p>
<p>就是在需要异步的地方用回调函数还函数的末尾调用其他函数。</p>
<p>优势：简单</p>
<p>缺点：回调地狱</p>
</li>
<li><p>Promise是ES6最重要的内容之一，他在一定程度上解决了回调地狱。</p>
<p>优势：状态只会改变一次，任何时候都可以得到结果</p>
<p>缺点：无法取消Promise，当处于pending状态时候，无法得知进展到哪一个阶段，错误不能够被try catch</p>
</li>
<li><p>Generator又称为生成器，就是使用function* func()这种方式去定义函数，这样生成的函数就是生成器，他的特点就是可以使用yield打断点，每次执行到yield的时候，函数都会暂停，并返回一个值，直到next（）命令才向下执行。</p>
</li>
<li><p>async/await其实就是Generator的一个语法糖。使用方式是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> readFile(A,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="手写jsonp（扩展）"><a href="#手写jsonp（扩展）" class="headerlink" title="手写jsonp（扩展）"></a>手写jsonp（扩展）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//	因为我们是利用script标签的src请求这个接口地址http://127.0.0.1:8081/，所以我们需要设置响应头为js格式</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/javascript&#x27;</span> &#125;);</span><br><span class="line">    <span class="comment">//然后返回js格式代码回去</span></span><br><span class="line">    response.end(<span class="string">&#x27;var a=1&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="number">8081</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><h5 id="观察者模式vs发布订阅模式"><a href="#观察者模式vs发布订阅模式" class="headerlink" title="观察者模式vs发布订阅模式"></a>观察者模式vs发布订阅模式</h5><p>在23中设计模式中并没有发布订阅模式，这个模式其实可以看成时观察者模式的变种。</p>
<p>总所周知，观察者模式中只要被观察的对象发生了改变，就会通知观察者发生变化（Vue采用了这种方式实现响应式原理）</p>
<p>而在发布订阅模式中，观察者和被观察者时不直接通信的。它们之间通过第三者进行间接通信，可以说观察者模式两者是松耦合的，而发布订阅模式是完全解耦的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/v2-540a78ba3127b0c6882adc668e7a3535_r.jpg" alt="v2-540a78ba3127b0c6882adc668e7a3535_r"></p>
</li>
<li><h5 id="为什么Vue不建议使用index或者随机数作为key？"><a href="#为什么Vue不建议使用index或者随机数作为key？" class="headerlink" title="为什么Vue不建议使用index或者随机数作为key？"></a>为什么Vue不建议使用index或者随机数作为key？</h5><p>用组件唯一的 <code>id</code>(一般由后端返回)作为它的 <code>key</code>，实在没有的情况下，可以在获取到列表的时候通过某种规则为它们创建一个 <code>key</code>，并保证这个 <code>key</code> 在组件整个生命周期中都保持稳定。</p>
<p>别用 <code>index</code> 作为 <code>key</code>，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 <code>0, 1, 2</code> 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>
<p>千万别用随机数作为 <code>key</code>，不然旧节点会被全部删掉，新节点重新创建</p>
</li>
<li><h5 id="webpack中loader和plugin的区别"><a href="#webpack中loader和plugin的区别" class="headerlink" title="webpack中loader和plugin的区别"></a>webpack中loader和plugin的区别</h5><p>loader是用于加载某些资源文件的，因为webpack本身只能打包commonjs规范的js文件，这就需要用到loader对其他类型的文件进行转化。</p>
<p>plugin是用于扩展webpack的功能的，loader也算是变相扩展了webpack的内容。plugin的功能更加的丰富，而不仅局限与资源的加载，并且整个编译周期都有用。</p>
</li>
<li><h5 id="webpack原理"><a href="#webpack原理" class="headerlink" title="webpack原理"></a>webpack原理</h5><p>webpack会以一个指定的文件作为入口，解析整个项目的依赖关系，最终打包成常见的静态文件。</p>
</li>
<li><h5 id="哈希表的原理和哈希算法的原理"><a href="#哈希表的原理和哈希算法的原理" class="headerlink" title="哈希表的原理和哈希算法的原理"></a>哈希表的原理和哈希算法的原理</h5><p>哈希表hash table(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>
<p>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 哈希表又叫做散列表，分为“开散列” 和“闭散列”。</p>
</li>
<li><h5 id="浏览器缓存-强缓存、协商缓存-为什么cache-control优先级更高"><a href="#浏览器缓存-强缓存、协商缓存-为什么cache-control优先级更高" class="headerlink" title="浏览器缓存,强缓存、协商缓存,为什么cache-control优先级更高"></a>浏览器缓存,强缓存、协商缓存,为什么cache-control优先级更高</h5><p>浏览器缓存分为强缓存和协商缓存，当存在缓存时，客户端第一次向服务器请求数据时，客户端会缓存到内存或者硬盘当中，当第二次获取相同的资源，强缓存和协商缓存的应对方式有所不同。</p>
<h6 id="强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存-硬盘中间读取"><a href="#强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存-硬盘中间读取" class="headerlink" title="强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取"></a>强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取</h6><h6 id="协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存-硬盘中读取"><a href="#协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存-硬盘中读取" class="headerlink" title="协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取"></a>协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取</h6><h6 id="强缓存由服务器的响应头里-cache-control-和-expires-两个字段决定，协商缓存由-last-modified-和-etag两个字段决定。"><a href="#强缓存由服务器的响应头里-cache-control-和-expires-两个字段决定，协商缓存由-last-modified-和-etag两个字段决定。" class="headerlink" title="强缓存由服务器的响应头里 cache-control 和 expires 两个字段决定，协商缓存由 last-modified 和 etag两个字段决定。"></a>强缓存由服务器的响应头里 cache-control 和 expires 两个字段决定，协商缓存由 last-modified 和 etag两个字段决定。</h6><p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/20200901103330879.jpg" alt="20200901103330879"></p>
</li>
<li><h5 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h5><h6 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h6><ul>
<li>200 OK，表示从客户端发来的请求被正确处理</li>
<li>204 No content，表示请求成功，但是响应报文不包含主体部分</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<h6 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h6><ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的URL</li>
<li>303 see other，表示资源存在着另一个URL，应使用get方法定向获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redrect，临时重定向，和302含义相同</li>
</ul>
<h6 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h6><ul>
<li>400 badrequest，请求报文存在语法错误</li>
<li>401 unauthorized，表示需要权限（token）</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
<li>105 请求行中指定的请求方法不能被用于请求相应的资源。</li>
</ul>
<h6 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h6><ul>
<li>500 internal sever error，表示服务器端在执行请求的时候发生了错误</li>
<li>503 service unavailable，表示服务器暂时处于超负荷或者在停机维护，无法处理请求</li>
</ul>
</li>
<li><h5 id="Vue的-nextTick用法"><a href="#Vue的-nextTick用法" class="headerlink" title="Vue的$nextTick用法"></a>Vue的$nextTick用法</h5><p>当在Vue中完成了赋值操作而视图更新没有完成时，是获取不到最新DOM的，这个时候如果想要操作DOM就要使用$nextTick去异步延迟到DOM更新完成后再操作。</p>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><p>Vue分了三种情况来延迟调用</p>
<ol>
<li><p>promise.then延迟调用</p>
<p>如果这个浏览器支持原生promise，那么使用Promise.then延迟函数</p>
</li>
<li><p>MutationObserver监听变化</p>
</li>
<li><p>setTimeout延迟器</p>
</li>
</ol>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>面经摘抄</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/2022/03/21/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h1><p>每个Vue的实例创建的时候都有一系列的阶段，比如创建Vue实例，数据装载，渲染DOM数，渲染CSS等等，这些不同阶段就被成为Vue的生命周期。理解生命周期的概念和各个生命周期钩子的作用有助于对Vue项目的提升。</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/11370083-f279314aef6741db.webp" alt="11370083-f279314aef6741db"></p>
<p>这是大佬博客的图，很直观的展示了Vue生命周期和生命周期钩子的作用。</p>
<ol>
<li><p>beforeCreate（创建前）</p>
<p>这个时候Vue对象刚刚创建，没有DOM和数据</p>
</li>
<li><p>created（已创建）</p>
<p>这个时候已经开始监控Data数据变化，这个时候就<strong>可以获取到Data的内容了</strong></p>
</li>
<li><p>beforeMount</p>
<p>这个阶段编译了虚拟DOM树，真实DOM树还没有渲染到页面上</p>
</li>
<li><p>mounted</p>
<p>这个阶段已经将虚拟DOM编译为真实DOM，此时一般可以进行一些ajax操作，mouted只会执行一次</p>
</li>
<li><p>beforeUpdate</p>
<p>这是响应式更新前的钩子，可以在虚拟DOM的基础上再次修改DOM</p>
</li>
<li><p>updated</p>
<p>这是响应式更新后的钩子，此时真实DOM已经更新完毕，最好不要在这里才再次修改DOM</p>
</li>
<li><p>beforeDestroy</p>
<p>实例销毁前的钩子，实例任然完全可用</p>
</li>
<li><p>destroyed</p>
<p>实例已经销毁</p>
</li>
</ol>
<p>参考原帖：<a href="https://www.jianshu.com/p/672e967e201c">https://www.jianshu.com/p/672e967e201c</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记03布局</title>
    <url>/2022/01/11/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>对于选择器的优先级：</p>
<ul>
<li>标签选择器、伪元素选择器：1</li>
<li>类选择器、伪类选择器、属性选择器：10</li>
<li>id选择器：100</li>
<li>内联样式：1000</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>!important声明的样式的优先级最高</li>
<li>如果优先级相同，则最后出现的样式生效</li>
<li>继承得到的样式优先级最低</li>
<li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值为0</li>
<li>样式表的来源不同，优先级顺序为：内联样式&gt;内部样式&gt;外部样式&gt;浏览器用户自定义样式&gt;浏览器默认样式</li>
</ul>
<h6 id="简单记住结论：-important-gt-行内样式-gt-id选择器-gt-class选择器-属性选择器-gt-标签选择器-gt-通配符"><a href="#简单记住结论：-important-gt-行内样式-gt-id选择器-gt-class选择器-属性选择器-gt-标签选择器-gt-通配符" class="headerlink" title="简单记住结论：!important&gt;行内样式&gt;id选择器&gt;class选择器/属性选择器&gt;标签选择器&gt;通配符*"></a>简单记住结论：!important&gt;行内样式&gt;id选择器&gt;class选择器/属性选择器&gt;标签选择器&gt;通配符*</h6><h5 id="覆盖原则："><a href="#覆盖原则：" class="headerlink" title="覆盖原则："></a>覆盖原则：</h5><ol>
<li>由于集成儿发生样式冲突时，最近祖先获胜</li>
<li>继承的样式和直接指定的样式冲突的时候，样式权值高者获胜</li>
<li>样式权值相同时，后者获胜</li>
<li>!important的样式属性不被覆盖</li>
</ol>
<h2 id="CSS3中有哪些新特性"><a href="#CSS3中有哪些新特性" class="headerlink" title="CSS3中有哪些新特性"></a>CSS3中有哪些新特性</h2><ul>
<li>新增各种CSS选择器（:not(.input):所有class不是“input”的节点）</li>
<li>圆角（border-radius:8px）</li>
<li>多列布局（multi-column layout）</li>
<li>阴影和反射（Shadoweflect）</li>
<li>文字特效（text-shadow）</li>
<li>文字渲染（Text-decoration）</li>
<li>线性渐变（gradient）</li>
<li>旋转（transform）</li>
<li>增加了旋转，缩放，定位，倾斜，动画，多背景。</li>
</ul>
<h2 id="CSS中可继承和不可继承的属性有哪些"><a href="#CSS中可继承和不可继承的属性有哪些" class="headerlink" title="CSS中可继承和不可继承的属性有哪些"></a>CSS中可继承和不可继承的属性有哪些</h2><h5 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h5><ul>
<li>display：规定元素应该生成的框的类型</li>
<li>文本属性<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
</li>
<li>盒子模型的属性：width,height,margin,border,padding</li>
<li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
</ul>
<h2 id="display的属性值及其作用"><a href="#display的属性值及其作用" class="headerlink" title="display的属性值及其作用"></a>display的属性值及其作用</h2><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承display属性的值。</td>
</tr>
</tbody></table>
<h6 id="display的block、inline和inline-block的区别"><a href="#display的block、inline和inline-block的区别" class="headerlink" title="display的block、inline和inline-block的区别"></a>display的block、inline和inline-block的区别</h6><ul>
<li>block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding</li>
<li>inline：不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不嫩设置垂直方向的padding和margin</li>
<li>inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。对于行内元素和块级元素，其特点如下：<ul>
<li>行内元素<ul>
<li>设置宽高无效</li>
<li>可以设置水平方向的margin和padding属性，但不嫩设置垂直方向的padding和margin</li>
<li>不会自动换行</li>
</ul>
</li>
<li>块级元素<ul>
<li>可以设置宽高</li>
<li>可以设置margin和padding</li>
<li>可以自动换行</li>
<li>多个块级元素，默认排列从上到下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="隐藏元素的方法有哪些"><a href="#隐藏元素的方法有哪些" class="headerlink" title="隐藏元素的方法有哪些"></a>隐藏元素的方法有哪些</h3><ul>
<li>display:none：在页面中不占据位置，也不会响应绑定的监听事件</li>
<li>visibility:hidden：在页面中占据位置，但不会响应监听事件</li>
<li>opacity:0：设置透明度来隐藏元素，在页面中占据位置，同时会响应监听事件</li>
<li>clip/clip-path：裁剪元素，在页面中占据位置，但不会响应监听事件</li>
<li>transform:scale(0,0)：缩放元素，在页面中占据位置，但不会响应监听事件</li>
</ul>
<h3 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h3><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p>
<h3 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><ul>
<li>伪类就是一个选择处于特定状态的元素的选择器，比如某一个 clsss 的第一个元素，某个被 hover 的元素等等，我们可以理解成一个特定的 CSS 类，但与普通的类不一样，它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</li>
<li>伪元素和伪类很像，但是伪元素类似于增添一个新的 DOM 节点到 DOM 树中，而不是改变元素的状态。注意了，这里是类似，而不是真的增加一个节点，这也是其被称为伪元素的原因（实质上，元素被创建在文档外）。</li>
<li>伪类是操作文档中已有的元素，而伪元素是创建了一个文档外的元素，两者最关键的区别就是这点。此外，为了书写 CSS 时进行区分，一般伪类是单冒号，如:hover，而伪元素是双冒号::before。</li>
</ul>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ul>
<li>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</li>
</ul>
<h3 id="CSS预处理器-后处理器是什么？为什么要使用他们？"><a href="#CSS预处理器-后处理器是什么？为什么要使用他们？" class="headerlink" title="CSS预处理器/后处理器是什么？为什么要使用他们？"></a>CSS预处理器/后处理器是什么？为什么要使用他们？</h3><p>预处理器，如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin，变量，循环，函数等对编写以及开发UI组件都极为方便。</p>
<p>后处理器，如：postCss，通常是在完成的样式表中根据css规范化处理css，让其更加有效。目前最常做的就是给css属性添加浏览器私有前缀，实现跨浏览器兼容性问题。</p>
<p>css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在css 中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简介，增加适应性以及可读性，可维护性等。</p>
<p>其他css预处理器语言Sass（Scss），Less，Stylus…</p>
<p>使用原因：</p>
<ul>
<li>结构清晰，便于扩展</li>
<li>可以很方便的屏蔽浏览器私有语法的差异</li>
<li>可以轻松实现多重继承</li>
<li>完美的兼容了CSS代码，可以应用到老项目中。</li>
</ul>
<h3 id="页面布局单位以及设计（重点）"><a href="#页面布局单位以及设计（重点）" class="headerlink" title="页面布局单位以及设计（重点）"></a>页面布局单位以及设计（重点）</h3><h5 id="css布局单位"><a href="#css布局单位" class="headerlink" title="css布局单位"></a>css布局单位</h5><p>常用的由包括像素（px），百分比（%），em，rem，vw/wh</p>
<ol>
<li>像素<ul>
<li>像素是页面布局的基础，一个像素标识终端屏幕所能显示的最小区域，像素分为两种类型：CSS像素和物理像素：</li>
<li>CSS像素：为web开发者提供，在CSS中使用的一个抽象单位</li>
<li>物理像素：设备实际的像素</li>
</ul>
</li>
<li>百分比（%）,当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</li>
<li>em和rem相对于px跟家灵活，他们都是相对长度单位，区别：em相对于父元素，rem相对于根元素<ul>
<li>em：文本相对长度单位，相对当前对象被文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（默认16px）。（相对父元素的字体大小倍数）</li>
<li>rem：rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏间的比值来设置font-size的值，一次实现当屏幕分辨率变化是让元素也随之变化。</li>
</ul>
</li>
<li>vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口的高度，除了vw和vh外，还有vmin和vmax。</li>
</ol>
<h3 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h3><ul>
<li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li>
</ul>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><p>首先，实现flex布局需要先指定一个容器，任何一个容器都可以被指定为flex布局，这样容器的内部元素就可以使用flex来进行布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex | inline-flex; <span class="comment">/*可以有两种取值方式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</p>
</blockquote>
<p>有下面六种属性可以设置在容器上，它们分别是：</p>
<p>1、flex-direction</p>
<p>2、flex-wrap</p>
<p>3、flex-flow</p>
<p>4、justify-content</p>
<p>5、align-items</p>
<p>6、align-content</p>
<ul>
<li><strong>flex-direction: 决定主轴的方向(即项目的排列方向)</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认值：row，主轴为水平方向，起点在左端。</p>
<ul>
<li><strong>flex-warp：决定换行方式</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>flex-flow：是flex-direction和flex-warp的简写形式，默认为row nowarp</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-warp&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>justify-content：定义了在主轴上的对齐方式</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>align-items：定义了项目在交叉轴上的对齐方式</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>align-content：定义了项目在多轴上的对齐方式，如果只有一个轴则不算</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小测验：实现一个有16个元素的flex布局，这16个元素水平排列每四个一行，上下左右居中，同时是响应式的长宽</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">background</span>:skyblue;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>:row;<span class="comment">/*项目排列方向：水平*/</span></span><br><span class="line">    <span class="attribute">flex-wrap</span>:wrap;<span class="comment">/*项目换行方式：换行*/</span></span><br><span class="line">    <span class="attribute">align-content</span>:center;<span class="comment">/*项目交叉轴对齐方式：居中*/</span></span><br><span class="line">    <span class="attribute">justify-content</span>:center/*项目纵轴对齐方式：居中*/</span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">2%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220318224912723.png" alt="image-20220318224912723"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈BFC</title>
    <url>/2022/03/29/%E6%B5%85%E8%B0%88BFC/</url>
    <content><![CDATA[<h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>BFC（Block Formatting Context），中文称块级格式化上下文，是页面中的一块渲染区域，有别于页面的其他地方，它有一套属于自己的渲染规则，它决定了元素如何对齐内容进行布局，以及与其他元素的关系和相互作用。</p>
<p>简而言之：BFC就是一个独立的布局环境，BFC内部的元素布局与外部互不影响</p>
<h2 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h2><table>
<thead>
<tr>
<th>元素或属性</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>根元素</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>left、right</td>
</tr>
<tr>
<td>position</td>
<td>absolute、fixed</td>
</tr>
<tr>
<td>overflow</td>
<td>auto、scroll、hidden</td>
</tr>
<tr>
<td>display</td>
<td>inline-block、table-cell</td>
</tr>
</tbody></table>
<h2 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h2><ol>
<li>内部的BOX会在垂直方向上一个接着一个地放置</li>
<li>BOX垂直方向上的距离由margin决定。属于同一个BFC的两个相邻的BOX的margin会重叠。</li>
<li>每个盒子的左外边框紧挨着包含块的左边框，即使是浮动元素也是如此</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素</li>
<li>计算BFC的高度时候，浮动子元素也参与计算</li>
</ol>
<h2 id="BFC的应用"><a href="#BFC的应用" class="headerlink" title="BFC的应用"></a>BFC的应用</h2><ul>
<li><p>解决子元素使用浮动父元素高度坍塌的问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid pink;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305204614141.png" alt="image-20220305204614141"></p>
<h4 id="使用BFC后"><a href="#使用BFC后" class="headerlink" title="使用BFC后"></a>使用BFC后</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    //触发BFC，规则上计算高度的时候浮动子元素也会被包含在内</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid pink;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305204724251.png" alt="image-20220305204724251"></p>
</li>
<li><p>浮动元素覆盖正常元素（可用于实现两栏、三栏自适应布局）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305211642477.png" alt="image-20220305211642477"></p>
<h4 id="使用BFC后-1"><a href="#使用BFC后-1" class="headerlink" title="使用BFC后"></a>使用BFC后</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305211912897.png" alt="image-20220305211912897"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
