<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bolb和FormData之间的区别</title>
    <url>/2021/06/26/Bolb%E5%92%8CFormData%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>​     问题背景：参与了学校大佬的一个开源项目，基于Apache Pulsar的Function Stream。具体内容看<a href="https://github.com/FunctionStream/function-stream">这里</a>。我在项目中负责某几个接口的对接，其中有一个接口接受一个文件和一个对象，由于后端是基于Apache Pulsar开发的，接口是其他人做的，修改接口不太现实，只好从前端入手了。</p>
<p>​    首先在postman上尝试，能够正常上传。跑去看了看上传成功的数据格式。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/20210910080004594.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>​    Content-Type是form-data，所以很自然地使用FormData去构造数据，将funcConfig和data分别append进参数中，然后上传，结果是不出意料地失败了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1624179110.png" alt="1624179110"></p>
<p>​    网上的说法有：</p>
<ol>
<li>把对象直接append进data里。</li>
<li>是把对象序列化后append进data里</li>
</ol>
<p>​    试过之后发现都不行，要么报错说参数缺失，要么参数格式有误。</p>
<p>​    最后在博客看到有一个说法是用Blob去构造对象。</p>
<p>​    找到一个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> debug = &#123;<span class="attr">hello</span>: <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(debug, <span class="literal">null</span>, <span class="number">2</span>)], &#123;<span class="attr">type</span> : <span class="string">&#x27;application/json&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>​    试了一下，结果成功了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data.append(<span class="string">&#x27;functionConfig&#x27;</span>, <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(functionConfig)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;))</span><br></pre></td></tr></table></figure>



<h4 id="MDN上对Blob的描述："><a href="#MDN上对Blob的描述：" class="headerlink" title="MDN上对Blob的描述："></a>MDN上对Blob的描述：</h4><p>Blob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。 </p>
<p>Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<h4 id="MDN上对File的描述："><a href="#MDN上对File的描述：" class="headerlink" title="MDN上对File的描述："></a>MDN上对File的描述：</h4><p>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。比如说， FileReader, URL.createObjectURL(), createImageBitmap() (en-US), 及 XMLHttpRequest.send() 都能处理 Blob 和File。</p>
<h4 id="MDN上对FormData的描述："><a href="#MDN上对FormData的描述：" class="headerlink" title="MDN上对FormData的描述："></a>MDN上对FormData的描述：</h4><p>FormData 接口提供了一种表示表单数据的键值对 key/value 的构造方式，并且可以轻松的将数据通过XMLHttpRequest.send() 方法发送出去，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 “multipart/form-data”，它会使用和表单一样的格式。</p>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>回头再看发生的错误，正是’functionConfig’这个参数没有被识别出来，那么问题就明确了，后端接收参数的时候确实是使用FormData格式，只是出于某种原因，在本来直接按键值对方式就可以取出的对象参数’functionConfig’,后端默认当成二进制文件一并处理了，处理完成后才去找这个参数。</p>
<p>所以要在上传的时候将这个参数用二进制文件的格式包装起来，才能在后台解析的时候正确获取到对应的值。</p>
]]></content>
      <categories>
        <category>FuntcionStream</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript中的hook</title>
    <url>/2022/04/26/Javascript%E4%B8%AD%E7%9A%84hook/</url>
    <content><![CDATA[<h1 id="Javascript中的hook"><a href="#Javascript中的hook" class="headerlink" title="Javascript中的hook"></a>Javascript中的hook</h1><p>Hook在英文中意为“钩子”，是一种动态修改函数执行流程或返回结果的方法，在实际应用中非常广泛。</p>
<h2 id="Hook是什么"><a href="#Hook是什么" class="headerlink" title="Hook是什么"></a>Hook是什么</h2><p>hook原理图</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/Hook.png" alt="Hook"></p>
<p>可以看出，Hook其实非常像是一个拦截器，只不过它是一个“开放的拦截器”。什么意思呢？就是它相当于来正常的流程中开了一个口，使得A—&gt;B的过程变成了A—&gt;Hook—&gt;B,而这个Hook允许你自行添加处理的逻辑，因此我称它为”开放的拦截器“。</p>
<h3 id="HooK和拦截器的差别"><a href="#HooK和拦截器的差别" class="headerlink" title="HooK和拦截器的差别"></a>HooK和拦截器的差别</h3><p>Hook虽然十分像拦截器，但是还是有所不同的。</p>
<ul>
<li>拦截器是不能在一个封闭的函数中件设置的，而Hook可以。因为Hook是由事件的提供者提供的，也就是说Hook是开发者本身留给你的后门。拦截器只是设置在流程前后的你自己设置的处理逻辑。</li>
<li>你在Hook中添加的逻辑是被流程承认的。而拦截器对于这段流程本身来说是没有联系的，流程并不知道拦截器的存在。</li>
</ul>
<h2 id="Hook的应用"><a href="#Hook的应用" class="headerlink" title="Hook的应用"></a>Hook的应用</h2><ol>
<li><h5 id="最简单的Hook方法"><a href="#最简单的Hook方法" class="headerlink" title="最简单的Hook方法"></a>最简单的Hook方法</h5><p>JavaScript中存在函数重载这一概念，这意味着你可以直接修改同名函数的逻辑，这也是一种Hook。</p>
</li>
<li><h5 id="Vue2-x响应式原理"><a href="#Vue2-x响应式原理" class="headerlink" title="Vue2.x响应式原理"></a>Vue2.x响应式原理</h5><p>JavaScript中存在一个<code>defineProperty</code>API，作用是可以自定义对象中某个元素的行为，例如是否可编辑，是否可遍历，修改当前元素的值等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">document</span>, <span class="string">&#x27;domain&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._domain || location.host;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._domain = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><h5 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h5><p>Vue生命周期钩子是比较典型的Hook</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="Vue3-x响应式原理"><a href="#Vue3-x响应式原理" class="headerlink" title="Vue3.x响应式原理"></a>Vue3.x响应式原理</h5><p>ES6中引入了一个概念<code>proxy</code>代理，简单来说就是为某个东西添加一层拦截，Vue3.x响应式原理就是基于这个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.screen = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="built_in">window</span>.screen, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记02State</title>
    <url>/2022/05/18/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002State/</url>
    <content><![CDATA[<h1 id="React组件三大核心属性之State"><a href="#React组件三大核心属性之State" class="headerlink" title="React组件三大核心属性之State"></a>React组件三大核心属性之State</h1><p>state是组件对象中最重要的属性，值是一个对象（可以包含多个key-value的组合）。组件被称为状态机，通过更新组件的state来更新对应的页面显示（重新渲染组件）</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>我们需要使用类式创建组件，这样才能给组件初始化状态。</p>
<ol>
<li><p>在构造器上挂载state，标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">        isHot: false,</span><br><span class="line">        isWind: false</span><br><span class="line">    &#125;</span><br><span class="line">    this.changeState = this.changeState.bind(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> state = &#123; isHot: true, isWind: false &#125;</span><br><span class="line">//原理，直接使用变量会默认创建挂载在类上的静态属性</span><br></pre></td></tr></table></figure></li>
<li><p>定义render函数，返回一个jsx格式的类XML代码，作为模板代码，在render函数中的this指向组件实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const &#123; isHot, isWind &#125; = this.state</span><br><span class="line">    return (</span><br><span class="line">        &lt;div onClick=&#123;this.changeState&#125;&gt;</span><br><span class="line">            今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;,&#123;isWind ? &#x27;有风&#x27; : &#x27;无风&#x27;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>添加方法，标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//直接挂载在类的原型链上，注意，这种方法在实例中调用的时候会导致this的丢失，需要在构造器中绑定this</span><br><span class="line">changeState() &#123;</span><br><span class="line">    //注意！！！状态不可以直接更改！！</span><br><span class="line">    // this.state.isHot = !this.state.isHot</span><br><span class="line">    const isHot = this.state.isHot</span><br><span class="line">    //状态必须通过setState进行更改，并且更改是只更改选中项的</span><br><span class="line">    this.setState(&#123; isHot: !isHot &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简写格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//原理，利用箭头函数的this在定义的时候就已经绑定了</span><br><span class="line">changeState = () =&gt; &#123;</span><br><span class="line">    const isHot = this.state.isHot</span><br><span class="line">    this.setState(&#123; isHot: !isHot &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>在react中不允许直接修改状态，需要使用一个在react实例原型上的方法<code>setState</code>去间接修改变量。</strong></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TS学习笔记02类</title>
    <url>/2022/04/27/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="TypeScript中的类"><a href="#TypeScript中的类" class="headerlink" title="TypeScript中的类"></a>TypeScript中的类</h1><p>TS中的类定义方式和ES6中定义方式很相似，直接使用class关键字来定义</p>
<p><strong>值得注意的是，在使用变量之前需要声明这个变量，不能像在es6中constructor直接使用this</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> name</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Call(<span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c.call())</span><br></pre></td></tr></table></figure>

<h2 id="类中的属性声明"><a href="#类中的属性声明" class="headerlink" title="类中的属性声明"></a>类中的属性声明</h2><ol>
<li><p><code>public</code>公有属性：这个类本身，它的子类和类外都能访问的属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Call</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> yourname: <span class="built_in">string</span> = <span class="string">&#x27;xixi&#x27;</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">yourname: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.yourname = yourname</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.yourname</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Call(<span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c.call())	<span class="comment">//ddd</span></span><br><span class="line"><span class="built_in">console</span>.log(c.yourname)	<span class="comment">//在类外ddd</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>private</code>私有属性：这个类本身和它的子类才能访问，类外不能访问</p>
</li>
<li><p><code>static</code>静态属性：只有这个类本身才能访问，子类和类外都不能访问</p>
</li>
</ol>
<h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><p>多态是一种继承的形式，父类定义一个方法不去实现，让它的子类去实现，每个子类都可以由不同的表现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params">food: <span class="built_in">string</span></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    eat(food: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`喜欢吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    eat(food: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`不喜欢吃<span class="subst">$&#123;food&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line">cat.eat(<span class="string">&#x27;鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.eat(<span class="string">&#x27;菜&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="TS中的抽象类"><a href="#TS中的抽象类" class="headerlink" title="TS中的抽象类"></a>TS中的抽象类</h2><p>TS中的抽象类的作用是提供其他类继承的基类，<strong>不能直接被实例化</strong></p>
<p>在定义类之前使用<code>abstract</code>关键字可以定义抽象类和抽象方法，抽象类中的抽象方法不包括具体实现，并且必须在派生类中实现，这点类似多态，但是比多态强硬得多。</p>
<p>抽象类和抽象方法是用来定义标准的，因为继承它的子类必须实现它的抽象方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> food: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">food: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.food = food</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> eat(food: <span class="built_in">string</span>): <span class="built_in">any</span>	<span class="comment">//必须没有实现，否则报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">food: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(food)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;						<span class="comment">//这里必须有实现，否则报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`吃<span class="subst">$&#123;<span class="built_in">this</span>.food&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Cat(<span class="string">&#x27;fish&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.eat())</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TS学习笔记04泛型</title>
    <url>/2022/04/28/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="TypeScript中的泛型"><a href="#TypeScript中的泛型" class="headerlink" title="TypeScript中的泛型"></a>TypeScript中的泛型</h1><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统式为你提供了十分灵活的功能。</p>
<p>通俗的理解，泛型就是解决类接口方法的复用性，以及对不特定数据类型的支持</p>
<h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><p>可以支持不特定的数据类型，要求：传入的参数和返回的参数类型一致</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>)	<span class="comment">//正确写法，参数要一致</span></span><br><span class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="string">&#x27;2121&#x27;</span>) <span class="comment">//错误写法</span></span><br></pre></td></tr></table></figure>

<h2 id="类的泛型"><a href="#类的泛型" class="headerlink" title="类的泛型"></a>类的泛型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> list: T[] = []</span><br><span class="line">    add(value: T): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    min(): T &#123;</span><br><span class="line">        <span class="keyword">var</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.list.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minNum &gt; <span class="built_in">this</span>.list[i]) &#123;</span><br><span class="line">                minNum = <span class="built_in">this</span>.list[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;() <span class="comment">/**实例化类，并且制定了类的T代表的类型是number */</span></span><br><span class="line">m1.add(<span class="number">1</span>)</span><br><span class="line">m1.add(<span class="number">2</span>)</span><br><span class="line">m1.add(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m1.min())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m2 = <span class="keyword">new</span> MinClass&lt;<span class="built_in">string</span>&gt;() <span class="comment">/**实例化类，并且制定了类的T代表的类型是string */</span></span><br><span class="line">m2.add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">m2.add(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">m2.add(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m2.min())</span><br></pre></td></tr></table></figure>

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>两种定义方式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ConfigFn&lt;T&gt; &#123;</span><br><span class="line">    (value: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">str: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myGetData: ConfigFn&lt;<span class="built_in">string</span>&gt; = getData</span><br><span class="line"></span><br><span class="line">myGetData(<span class="string">&#x27;20&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ConfigFn &#123;</span><br><span class="line">    &lt;T&gt;(value: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getData: ConfigFn = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">str: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;张三&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="把类作为参数类型的泛型类"><a href="#把类作为参数类型的泛型类" class="headerlink" title="把类作为参数类型的泛型类"></a>把类作为参数类型的泛型类</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    password: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlDb</span>&lt;<span class="title">T</span>&gt; </span>&#123;			<span class="comment">//这个类可以用泛型定义，这样允许它有不同的传参</span></span><br><span class="line">    add(user: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(user)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User()</span><br><span class="line">u.username = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">u.password = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Db = <span class="keyword">new</span> MysqlDb&lt;User&gt;()    <span class="comment">//验证传入的数据类型为你希望的User类</span></span><br><span class="line"><span class="built_in">console</span>.log(Db.add(u))</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>定义一个操作数据库的库，支持Mysql、Mssql，MongoDb</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> DBI&lt;T&gt; &#123;</span><br><span class="line">    add(info: T): <span class="built_in">boolean</span>;</span><br><span class="line">    update(info: T, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">    get(id: <span class="built_in">number</span>): <span class="built_in">any</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个操作mysql数据库的类   注意：要实现泛型接口，这个类也应该是一个泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mysql</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">DBI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    add(info: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    update(info: T, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    get(id: <span class="built_in">number</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个操作mssql数据库的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsSqlDb</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">DBI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    add(info: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    update(info: T, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    get(id: <span class="built_in">number</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作用户表   定义一个User类和数据表做映射</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    password: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User()</span><br><span class="line"></span><br><span class="line">u.username = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">u.password = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oMysql1 = <span class="keyword">new</span> Mysql&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">oMysql1.add(u)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TS学习笔记05模块化与命名空间</title>
    <url>/2022/04/29/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="TypeScript中的模块化与命名空间"><a href="#TypeScript中的模块化与命名空间" class="headerlink" title="TypeScript中的模块化与命名空间"></a>TypeScript中的模块化与命名空间</h1><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>简单来说，模块化就是将原本写在一起的代码按照不同功能分开书写，进行解耦，然后再在需要的地方进行引入就好。</p>
<p>语法格式如下：</p>
<p>导出<code>export</code>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 : SomeInterface.ts </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeInterface &#123; 		<span class="comment">//可多次导出</span></span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">	<span class="comment">//代码部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> User					<span class="comment">//只能导出一次，且必须待代码末尾进行</span></span><br></pre></td></tr></table></figure>

<p>导入<code>import</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import someInterfaceRef from &quot;./SomeInterface.ts &quot;</span><br></pre></td></tr></table></figure>

<p>TS中几乎所有变量都能模块化开发，TS中的模块化与ES6中的模块化非常相似，都是纯静态的引入模式，这里就不作赘述。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间和模块化是一个相对的概念，如果说模块化是把代码分离到外部，再按需引入。那么命名空间就是将代码在内部做隔离，需要用的时候再引入。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;			<span class="comment">//命名空间相对于外部的代码来说是不可见的，除非你把它暴露出去</span></span><br><span class="line">    <span class="keyword">interface</span> DBI&lt;T&gt; &#123;</span><br><span class="line">        add(info: T): <span class="built_in">boolean</span>;</span><br><span class="line">        update(info: T, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">        <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">        get(id: <span class="built_in">number</span>): <span class="built_in">any</span>[]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个操作mysql数据库的类   注意：要实现泛型接口，这个类也应该是一个泛型类</span></span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Mysql</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">DBI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        add(info: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(info)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        update(info: T, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        get(id: <span class="built_in">number</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个操作mssql数据库的类</span></span><br><span class="line">    <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MsSqlDb</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">DBI</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        add(info: T): <span class="built_in">boolean</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        update(info: T, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>(id: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        get(id: <span class="built_in">number</span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Method not implemented.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作用户表   定义一个User类和数据表做映射</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">    password: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User()</span><br><span class="line"></span><br><span class="line">u.username = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">u.password = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oMysql1 = <span class="keyword">new</span> A.Mysql&lt;User&gt;()</span><br><span class="line"></span><br><span class="line">oMysql1.add(u)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TS学习笔记03接口</title>
    <url>/2022/04/27/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="TypeScript中的接口"><a href="#TypeScript中的接口" class="headerlink" title="TypeScript中的接口"></a>TypeScript中的接口</h1><p>在ES6中我们没有办法直接对函数的参数类型进行约束，只能通过在函数内部去判断参数的类型。TS中提供一种方式帮助我们约束函数传参的类型，这就是接口<code>interface</code></p>
<h2 id="接口的基本写法"><a href="#接口的基本写法" class="headerlink" title="接口的基本写法"></a>接口的基本写法</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> name &#123;</span><br><span class="line">    <span class="attr">firstname</span>: <span class="built_in">string</span>;</span><br><span class="line">    secondname: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params">obj: name</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj.firstname&#125;</span> <span class="subst">$&#123;obj.secondname&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callName(&#123; <span class="attr">firstname</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">secondname</span>: <span class="string">&#x27;hua&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>可以看出，接口的使用方式非常直接，在接口中定义参数的类型，然后声明传入参数的类型为接口的类型，就可以规定参数接收规定格式的参数了。</p>
<p><strong>注意，在外部定义变量的时候可以比接口要求的参数多几个参数，但是如果是在函数入口定义参数的话形参和实参必须一致。</strong></p>
<h2 id="函数类型的接口"><a href="#函数类型的接口" class="headerlink" title="函数类型的接口"></a>函数类型的接口</h2><p>接口也可以定义函数形参，和返回值的标准</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> encrypt &#123;</span><br><span class="line">    (key: <span class="built_in">string</span>, <span class="attr">value</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5: encrypt = (key: <span class="built_in">string</span>, <span class="attr">value</span>: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key + value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可索引的接口"><a href="#可索引的接口" class="headerlink" title="可索引的接口"></a>可索引的接口</h2><p>就是在接口中接收数组之类的引用类型时候去规范元素的类型</p>
<h3 id="对数组的约束"><a href="#对数组的约束" class="headerlink" title="对数组的约束"></a>对数组的约束</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Arr &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr: Arr = [<span class="string">&#x27;ddd&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h3 id="对对象的约束"><a href="#对对象的约束" class="headerlink" title="对对象的约束"></a>对对象的约束</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Arr &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr: Arr = &#123; <span class="attr">name</span>: <span class="string">&#x27;ddd&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;21&#x27;</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="类-类型的接口"><a href="#类-类型的接口" class="headerlink" title="类 类型的接口"></a>类 类型的接口</h2><p>这是可以约束类的类型值的接口，有点类似于抽象类的作用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    eat(name: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>					<span class="comment">//接口规定必须有这个属性</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat(action: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;			<span class="comment">//此处可以不使用接口规定的参数，但是必须要有这个函数本身</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Dog(<span class="string">&#x27;狗&#x27;</span>)</span><br><span class="line">a.eat(<span class="string">&#x27;吃肉&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>就和类一样，接口也是可以继承的，简单来说，使用一个继承了其他接口的接口去定义你的类，那么这个类就必须包含所有接口的标准。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    shape(size: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="attr">food</span>: <span class="built_in">string</span></span><br><span class="line">    eat(food: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pieDog</span> <span class="title">implements</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">food</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, food: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.food = food</span><br><span class="line">    &#125;</span><br><span class="line">    shape(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.food)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pie = <span class="keyword">new</span> pieDog(<span class="string">&#x27;小&#x27;</span>, <span class="string">&#x27;吃肉&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pie.shape()</span><br><span class="line">pie.eat()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TS学习笔记06装饰器</title>
    <url>/2022/04/29/TS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="TypeScript中的装饰器"><a href="#TypeScript中的装饰器" class="headerlink" title="TypeScript中的装饰器"></a>TypeScript中的装饰器</h1><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数来扩展类属性方法参数的功能</p>
<p><strong>常见装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器</strong></p>
<p><strong>装饰器的写法：普通装饰器（无法传参）、装饰器工厂（可以传参）</strong></p>
<p>装饰器是过去几年中js最大的成就之一，已经成为了ES7的标准特性之一</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器在类声明之前被声明（紧靠着类声明）。类装饰器应用于类构造函数、可以用来监视，修改或者替换类定义。传入一个参数</p>
<h4 id="普通装饰器："><a href="#普通装饰器：" class="headerlink" title="普通装饰器："></a><strong>普通装饰器：</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params)</span><br><span class="line">    <span class="comment">//params就是当前类</span></span><br><span class="line">    params.prototype.apiUrl = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">    params.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;run&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>   <span class="comment">//使用装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> http: <span class="built_in">any</span> = <span class="keyword">new</span> HttpClient()</span><br><span class="line"><span class="built_in">console</span>.log(http.apiUrl)	<span class="comment">//xxxx</span></span><br><span class="line"><span class="built_in">console</span>.log(http.run())		<span class="comment">//run</span></span><br></pre></td></tr></table></figure>

<h4 id="装饰器工厂（可传参）"><a href="#装饰器工厂（可传参）" class="headerlink" title="装饰器工厂（可传参）"></a><strong>装饰器工厂（可传参）</strong></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">params: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(target)</span></span><br><span class="line">        <span class="comment">// console.log(params)</span></span><br><span class="line">        target.prototype.apiUrl = params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>(<span class="string">&#x27;hello&#x27;</span>)   <span class="comment">//使用装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> http: <span class="built_in">any</span> = <span class="keyword">new</span> HttpClient()</span><br><span class="line"><span class="built_in">console</span>.log(http.apiUrl)	 <span class="comment">//hello</span></span><br></pre></td></tr></table></figure>

<h4 id="重载类构造函数"><a href="#重载类构造函数" class="headerlink" title="重载类构造函数"></a>重载类构造函数</h4><p>在某些情况下，我们可能会希望去重载一些类的方法或者构造函数，装饰器提供了这一种功能</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logClass</span>(<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target)</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">target</span> </span>&#123;	<span class="comment">//重载类，记住，类里面有什么，重载就要有什么，少了会报错</span></span><br><span class="line">        <span class="attr">apiUrl</span>: <span class="built_in">any</span> = <span class="string">&#x27;还是看看远处的佳人们把&#x27;</span></span><br><span class="line">        <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.apiUrl)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@logClass</span>  <span class="comment">//使用装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> apiUrl: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.apiUrl = <span class="string">&#x27;太美丽了礼堂&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.apiUrl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient()</span><br><span class="line">http.getData()</span><br></pre></td></tr></table></figure>

<h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名称</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProperty</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target)</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">        target[name] = params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@logProperty</span>(<span class="string">&#x27;http://itying.com&#x27;</span>)</span><br><span class="line">    <span class="keyword">public</span> url: <span class="built_in">any</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> http: <span class="built_in">any</span> = <span class="keyword">new</span> HttpClient()</span><br><span class="line">http.getData()</span><br></pre></td></tr></table></figure>

<h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p>它会被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义。</p>
<p>方法修饰会在运行时闯入下列3个参数：</p>
<ol>
<li>对于静态成员来说时类的构造函数，对于实例成员来说是类的原型对象</li>
<li>成员的名字</li>
<li>成员的属性描述符</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, methodName: <span class="built_in">any</span>, desc: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target)</span><br><span class="line">        <span class="built_in">console</span>.log(methodName)</span><br><span class="line">        <span class="built_in">console</span>.log(desc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> oMethod = desc.value</span><br><span class="line">        desc.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;	<span class="comment">//这里可以重新定义方法，会覆盖原来的方法</span></span><br><span class="line">            args = args.map(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">String</span>(value)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">console</span>.log(args)</span><br><span class="line">            oMethod.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> apiUrl: <span class="built_in">any</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@get</span>(<span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="title">getData</span>(<span class="params">...args: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http: <span class="built_in">any</span> = <span class="keyword">new</span> HttpClient()</span><br><span class="line">http.getData(<span class="number">123</span>, <span class="string">&#x27;xxx&#x27;</span>)      <span class="comment">//run</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vite学习笔记</title>
    <url>/2022/05/08/Vite%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
    <content><![CDATA[<h1 id="Vite学习笔记"><a href="#Vite学习笔记" class="headerlink" title="Vite学习笔记"></a>Vite学习笔记</h1><h2 id="vite是什么"><a href="#vite是什么" class="headerlink" title="vite是什么"></a>vite是什么</h2><p>vite是一种新型的前端构建工具，能够显著提升前端开发体验。它主要由两个部分组成：</p>
<ul>
<li>一个开发服务器，它基于原生ES模块提供了丰富的内建功能，如速度快到惊人的模块热更新</li>
<li>一套构建指令，它使用Rollup打包代码，并且它是预配置的，可以输出用于生产环境的高度优化过的静态资源</li>
</ul>
<h2 id="为什么要用vite"><a href="#为什么要用vite" class="headerlink" title="为什么要用vite"></a>为什么要用vite</h2><p>vite在打包速度上相比于webpack有明显的优势，当然，webpack作为当下最流行的打包工具，它的生态比vite优秀许多，不过我们可以看出vite的潜力。</p>
<h2 id="vite和webpack的区别"><a href="#vite和webpack的区别" class="headerlink" title="vite和webpack的区别"></a>vite和webpack的区别</h2><ol>
<li><p><strong>底层</strong></p>
<p>从底层上说，vite是基于esbuild与构建依赖。而esbuild是采用go语言编写，操作以纳秒计，而js是以毫秒计。</p>
</li>
<li><p><strong>启动方式</strong></p>
<h4 id="webpack："><a href="#webpack：" class="headerlink" title="webpack："></a><strong>webpack：</strong></h4><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/webpack%E5%8E%9F%E7%90%86.png" alt="webpack原理"></p>
<p>webpack的启动方式是先将所有用到的依赖收集，然后打包成boundle，即整合的依赖，再启动服务，我们查看由webpack构建的前端项目的时候会发现一些比较大的依赖文件，就是由webpack整合的。由于需要提前整合处理依赖，因此启动webpack是需要一定的时间的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220508152615681.png" alt="image-20220508152615681"></p>
<h4 id="vite："><a href="#vite：" class="headerlink" title="vite："></a><strong>vite：</strong></h4><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/vite%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86.png" alt="vite启动原理"></p>
<p>vite的启动方式得益于ES Module的支持，也就是可以静态引入资源。vite是先启动服务器，在页面编译的时候如果对某个模块有请求，再动态编译。所以vite的启动特别快，因为webpack需要编译，而vite不需要，直接启动。在热更新方面，也因为只让浏览器重新请求这个模块，而不像webpack一样重新编译，所以更快。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-2022050815445089224.png" alt="image-2022050815445089224"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vite</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts学习笔记01数据类型和函数</title>
    <url>/2022/04/27/Ts%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="TypeScript中的数据类型和函数"><a href="#TypeScript中的数据类型和函数" class="headerlink" title="TypeScript中的数据类型和函数"></a>TypeScript中的数据类型和函数</h1><p>TS是在JavaScript的基础上添加静态类型定义构建而成的语言，可以说是JavaScript的超集，能通过typescript编译器转化为JavaScript代码从而执行。由于JavaScript动态类型的特性，很多编程错误都是因为对类型定义不准确造成的，TS规定数据类型的方式巧妙的解决了这个难题。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在ts中变量被要求赋予一个固定的类型，类型确定了之后不能随意更改变量的类型。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型就是在定义的变量后面加上<code>:类型</code>用于确定这个变量的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">&#x27;aaa&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在TS中，有两种数组的定义方式，在数组中的各个元素的值也被要求是统一的</p>
<ol>
<li><p>类似于Java中定义数组的方式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">string</span>[] = [<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;33&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>泛型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h4><p>元组是一种特殊的数组，它支持定义每一个内部元素的属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: [<span class="built_in">string</span>, <span class="built_in">number</span>, <span class="built_in">boolean</span>] = [<span class="string">&#x27;dd&#x27;</span>, <span class="number">1</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<h4 id="枚举类型（enum）"><a href="#枚举类型（enum）" class="headerlink" title="枚举类型（enum）"></a>枚举类型（enum）</h4><p>枚举类型可以为每一个值设置一个标识，之后可以使用标识来引用它</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Flag &#123; success = <span class="number">1</span>, error = <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">var</span> success = Flag.success</span><br><span class="line"><span class="built_in">console</span>.log(success)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>如果定义的时候没有赋值，那么默认是获得它的索引值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> color &#123; red, pink, blue &#125;</span><br><span class="line"><span class="keyword">var</span> c: color = color.pink</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果在某一个枚举类型中定义的值，后面的没有定义过值的枚举类型都会以他的值为索引基准获取值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> color &#123; red, pink = <span class="number">45</span>, blue = <span class="number">99</span>, purple &#125;</span><br><span class="line"><span class="keyword">var</span> c: color = color.pink</span><br><span class="line"><span class="keyword">var</span> d: color = color.blue</span><br><span class="line"><span class="keyword">var</span> e: color = color.purple</span><br><span class="line"><span class="built_in">console</span>.log(c)	<span class="comment">//45</span></span><br><span class="line"><span class="built_in">console</span>.log(d)	<span class="comment">//99</span></span><br><span class="line"><span class="built_in">console</span>.log(e)	<span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<h3 id="any任意类型"><a href="#any任意类型" class="headerlink" title="any任意类型"></a>any任意类型</h3><p>在不确定变量的具体类型的情况下可以使用any类型定义，这个定义的类型和原本JavaScript中的类型定义没有区别</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="built_in">any</span> = <span class="literal">NaN</span> || <span class="literal">null</span> </span><br></pre></td></tr></table></figure>

<h3 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h3><p>标识不会出现的值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="built_in">never</span></span><br><span class="line">a = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;错误&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h4 id="null和undefined类型"><a href="#null和undefined类型" class="headerlink" title="null和undefined类型"></a>null和undefined类型</h4><p>null和undefined是never的子类型，可以用于指定如果变量前一个类型无法匹配的情况</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;run&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> call = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TS方法定义传参"><a href="#TS方法定义传参" class="headerlink" title="TS方法定义传参"></a>TS方法定义传参</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="没有返回值的方法"><a href="#没有返回值的方法" class="headerlink" title="没有返回值的方法"></a>没有返回值的方法</h4><p>使用viod定义</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;call&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法可选参数"><a href="#方法可选参数" class="headerlink" title="方法可选参数"></a>方法可选参数</h4><p>es5和es6中方法的形参和实参可以不一样，但是在ts中必须一样，如果不一样需要配置为可选参数</p>
<p><strong>注意！！可选参数必须配置在参数的最后面</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is 18`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(getUserInfo(<span class="string">&#x27;lihua&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>与可选参数不同的是，默认参数位置是随意的，类似于es6中的默认参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span> = <span class="number">20</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is 18`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(getUserInfo(<span class="string">&#x27;lihua&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>就是ES6中的<code>...</code>运算符</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, ...result: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = result.reduce(<span class="function">(<span class="params">total: <span class="built_in">number</span>, cur: <span class="built_in">number</span></span>) =&gt;</span> total + cur)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h4 id="函数重载（重点）"><a href="#函数重载（重点）" class="headerlink" title="函数重载（重点）"></a>函数重载（重点）</h4><p>在JavaScript中函数重载的概念是指重复定义同名函数的时候，无论如何后一个都会取代前一个。</p>
<p>但是在TS中，只要参数的类型不一致，只要参数的个数不一致，就是两个不同的函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">any</span></span>): <span class="title">string</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">if</span> (<span class="params">age</span>) </span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> `<span class="title">$</span></span>&#123;name&#125; is $&#123;age&#125;<span class="string">`</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        return `</span>$&#123;name&#125; is <span class="number">18</span> forever<span class="string">`</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(getUserInfo(&#x27;lihua&#x27;, 34))</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>跟前面的的几种函数没有本质区别</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (name: <span class="built_in">string</span>, age?: <span class="built_in">number</span> | <span class="literal">undefined</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>API</title>
    <url>/2022/04/30/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E5%AE%89%E8%A3%85%E5%92%8C%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="Vue3安装和打包"><a href="#Vue3安装和打包" class="headerlink" title="Vue3安装和打包"></a>Vue3安装和打包</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Vue3支持<code>vue-cli</code>和<code>vite</code>安装方式进行本地部署,这里只演示Vite安装过程。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以npm方式安装vite脚手架</span></span><br><span class="line">npm init vite<span class="literal">-app</span> &lt;project<span class="literal">-name</span>&gt;</span><br><span class="line"><span class="comment">#进入这个项目中</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project<span class="literal">-name</span>&gt;</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">#运行项目</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>运行项目，打开本地网页能看到这个页面就说明运行成功了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/62FB6F27-456F-46CF-8892-93D6A3E6F341.jpg" alt="62FB6F27-456F-46CF-8892-93D6A3E6F341"></p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite学习笔记02底层原理手写</title>
    <url>/2022/05/16/Vite%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%89%8B%E5%86%99/</url>
    <content><![CDATA[<h1 id="Vite底层原理手写"><a href="#Vite底层原理手写" class="headerlink" title="Vite底层原理手写"></a>Vite底层原理手写</h1><p>通过对<code>vite</code>底层原理的解析，我们可以发现<code>vite</code>其实是运行在一个服务器上的，浏览器解析入口<code>html</code>的时候遇到了依赖就会发起请求，<code>vite</code>进行回应。循环往复直到依赖全部加载完成。</p>
<h2 id="建立web服务，返回宿主页"><a href="#建立web服务，返回宿主页" class="headerlink" title="建立web服务，返回宿主页"></a>建立web服务，返回宿主页</h2><p>这里使用express为例子进行web服务器的搭建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//组合拼接出请求文件的绝对地址</span></span><br><span class="line">    <span class="keyword">const</span> url = req.url</span><br><span class="line">    <span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是默认请求，则返回宿主页面</span></span><br><span class="line">        <span class="keyword">let</span> body = fs.readFileSync(path.join(__dirname, <span class="string">&#x27;./index.html&#x27;</span>), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        res.send(body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8081</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;http server running at http://127.0.0.1:8081&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="JS路径加载"><a href="#JS路径加载" class="headerlink" title="JS路径加载"></a>JS路径加载</h2><p>浏览器解析<code>html</code>到<code>script</code>标签的时候就会重新发起<code>url</code>请求，这个时候我们的<code>web</code>服务器就要返回对应的<code>js</code>文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (url.endsWith(<span class="string">&#x27;js&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// js文件加载处理</span></span><br><span class="line">    <span class="keyword">const</span> p = path.join(__dirname, url)</span><br><span class="line">    <span class="comment">//解析是否有裸模块加载</span></span><br><span class="line">    <span class="keyword">let</span> body = rewoteImport(fs.readFileSync(p, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment">//设置响应头</span></span><br><span class="line">    res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/javascript;charset=utf-8&quot;</span>)</span><br><span class="line">    res.send(body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="裸模块加载"><a href="#裸模块加载" class="headerlink" title="裸模块加载"></a>裸模块加载</h2><p>在我们的项目中存在一些第三方的依赖，它们的引入不是通过相对路径，而是裸模块的方式，就是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>浏览器其实不能识别这种请求，所以我们要提前把这种请求转化成浏览器能够认识的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//裸模块重写</span></span><br><span class="line"><span class="comment">// import xx from &#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// import xx from &#x27;/@modules/vue&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rewoteImport</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content.replace(<span class="regexp">/from [&#x27;&quot;](.*)[&#x27;&quot;]/g</span>, <span class="function">(<span class="params">s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.endsWith(<span class="string">&#x27;/&#x27;</span>) || s2.endsWith(<span class="string">&#x27;./&#x27;</span>) || s2.endsWith(<span class="string">&#x27;../&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//说明是裸模块，进行替换</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">` from &#x27;/@modules/<span class="subst">$&#123;s2&#125;</span>&#x27;`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候浏览器就能够正常发送请求了，我们再拦截请求，去模块对应的位置找到对应的依赖文件进行加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;/@modules/&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">//模块加载处理</span></span><br><span class="line">    <span class="comment">//取出裸模块名称</span></span><br><span class="line">    <span class="keyword">const</span> moduleName = url.replace(<span class="string">&#x27;/@modules/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">//去node_modules目录中找</span></span><br><span class="line">    <span class="keyword">const</span> prefix = path.join(__dirname, <span class="string">&quot;./node_modules&quot;</span>, moduleName)</span><br><span class="line">    <span class="built_in">console</span>.log(prefix)</span><br><span class="line">    <span class="comment">//package.json中获取module字段,这个地方就是打包好的依赖</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = <span class="built_in">require</span>(prefix + <span class="string">&quot;/package.json&quot;</span>).module</span><br><span class="line">    <span class="comment">//拼接完整的真实依赖地址</span></span><br><span class="line">    <span class="keyword">const</span> filePath = path.join(prefix, <span class="built_in">module</span>)</span><br><span class="line">    <span class="comment">//读取这个真实依赖</span></span><br><span class="line">    <span class="keyword">const</span> ret = fs.readFileSync(filePath, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/javascript;charset=utf-8&quot;</span>)</span><br><span class="line">    res.send(rewoteImport(ret))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vue单页面组件SFC加载"><a href="#Vue单页面组件SFC加载" class="headerlink" title="Vue单页面组件SFC加载"></a>Vue单页面组件SFC加载</h2><p>vue的编译过程是<code>模板字符串-&gt;AST-&gt;reneder-&gt;vnode-&gt;patch-&gt;dom</code>，再Vite打包中，为了将模板字符串编译为浏览器能够认识的JavaScript，也就是<code>vnode</code>这个阶段，Vite必须把<code>模板字符串-&gt;AST-&gt;reneder-&gt;vnode</code>这个过程提前编译完成，再发送可以直接使用的js文件给浏览器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (url.indexOf(<span class="string">&#x27;.vue&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//SFC解析</span></span><br><span class="line">    <span class="comment">//读取vue文件，解析为js</span></span><br><span class="line">    <span class="keyword">const</span> p = path.join(__dirname, url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">//通过vue模板编译工具转换为AST</span></span><br><span class="line">    <span class="keyword">const</span> ret = complierSFC.parse(fs.readFileSync(p, <span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (!query.type) &#123;</span><br><span class="line">        <span class="comment">//获取脚本部分的内容</span></span><br><span class="line">        <span class="keyword">const</span> scriptContent = ret.descriptor.script.content</span><br><span class="line">        <span class="comment">//替换默认导出（export default）为一个常量，方便后续修改</span></span><br><span class="line">        <span class="keyword">const</span> script = scriptContent.replace(<span class="string">&#x27;export default &#x27;</span>, <span class="string">&#x27;const __script = &#x27;</span>)</span><br><span class="line">        res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/javascript;charset=utf-8&quot;</span>)</span><br><span class="line">        <span class="comment">// 重写依赖路径，防止依赖中又有裸模版依赖</span></span><br><span class="line">        <span class="comment">// 在首次编译的时候，为每一个vue模板挂载上render方法</span></span><br><span class="line">        <span class="keyword">let</span> body = <span class="string">`</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;rewriteImport(script)&#125;</span></span></span><br><span class="line"><span class="string">            import &#123; render as __render &#125; from &#x27;<span class="subst">$&#123;url&#125;</span>?type=template&#x27;</span></span><br><span class="line"><span class="string">            __script.render = __render</span></span><br><span class="line"><span class="string">            export default __script`</span></span><br><span class="line">        res.send(body)</span><br><span class="line">        <span class="comment">// console.log(body)</span></span><br><span class="line">        <span class="comment">// console.log(&#x27;query&#x27;, req.query)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.type === <span class="string">&#x27;template&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//获取编译过的AST中的模板内容</span></span><br><span class="line">        <span class="keyword">const</span> tpl = ret.descriptor.template.content</span><br><span class="line">        <span class="comment">//编译为虚拟DOM，此时浏览器就能理解了</span></span><br><span class="line">        <span class="keyword">const</span> render = compilerDOM.compile(tpl, &#123; <span class="attr">mode</span>: <span class="string">&#x27;module&#x27;</span> &#125;).code</span><br><span class="line">        res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/javascript;charset=utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> body = rewriteImport(render)</span><br><span class="line">        <span class="comment">// console.log(&#x27;body&#x27;, body)</span></span><br><span class="line">        res.send(body)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们实现了将vue项目中的<code>js</code>文件和<code>.vue</code>文件通过<code>express</code>服务器实时编译给浏览器,再深入的话就是对各种文件进行打包，例如css，ts等。</p>
<p>项目地址：<a href="https://github.com/GiorunoGiovanna/study-note/tree/main/%E6%89%8B%E5%86%99vite">https://github.com/GiorunoGiovanna/study-note/tree/main/%E6%89%8B%E5%86%99vite</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1dh411S7Vz?p=7&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1dh411S7Vz?p=7&amp;spm_id_from=pageDriver</a></p>
]]></content>
      <categories>
        <category>vite</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记02组合式API</title>
    <url>/2022/04/30/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E7%BB%84%E5%90%88%E5%BC%8FAPI/</url>
    <content><![CDATA[<h1 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h1><p>compositionAPI提供了以下几个函数，在当前vue版本中，想要使用这些api需要进行引入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; reactive, ref, toRef, toRefs &#125; from &quot;vue&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>setup</li>
<li>ref</li>
<li>reactive</li>
<li>watchEffect</li>
<li>watch</li>
<li>computed</li>
<li>toRefs</li>
<li>生命周期的hook</li>
</ul>
<h2 id="ref和reactive"><a href="#ref和reactive" class="headerlink" title="ref和reactive"></a>ref和reactive</h2><p><code>ref</code>和<code>reactive</code>都是用于定义响应式数据的API，其中</p>
<ol>
<li><code>ref</code>定义字符串、num、boolean、数组，<code>reactive</code>定义对象类型</li>
<li>在<code>setup</code>中<code>ref</code>想要获取变量数据需要在变量名称后加上<code>.value</code>,<code>reactive</code>直接获取数据就可以</li>
<li>在模板字符串中两者都可以直接获取数据</li>
<li>在<code>setup</code>中定义的数据必须在最后return出去才能在模板中使用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;div&gt;HOME-&#123;&#123; user.name &#125;&#125; 今年 &#123;&#123; user.age &#125;&#125;了&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;alertUser&quot;&gt;点击我获取user&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;alertTitle&quot;&gt;点击我获取title&lt;/button&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;title&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//注意，在composition API中使用方法需要引入</span><br><span class="line">import &#123; reactive, ref &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  //composition api</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    //ref 定义子符串、num、boolean、数组</span><br><span class="line">    //reactive 定义响应式数据定义对象</span><br><span class="line">    var title = ref(&quot;我是一个标题&quot;);</span><br><span class="line">    var user = reactive(&#123;</span><br><span class="line">      name: &quot;lihua&quot;,</span><br><span class="line">      age: 18,</span><br><span class="line">    &#125;);</span><br><span class="line">    //获取ref中的数据需要获取数据的value</span><br><span class="line">    let alertTitle = () =&gt; &#123;</span><br><span class="line">      alert(title.value);</span><br><span class="line">      console.log(title);</span><br><span class="line">    &#125;;</span><br><span class="line">    //获取reactive中的数据直接获取</span><br><span class="line">    let alertUser = () =&gt; &#123;</span><br><span class="line">      alert(user.name);</span><br><span class="line">      console.log(user);</span><br><span class="line">    &#125;;</span><br><span class="line">    //在composition api中想要模板能够使用定义的变量和方法必须返回这个名称</span><br><span class="line">    return &#123;</span><br><span class="line">      title,</span><br><span class="line">      user,</span><br><span class="line">      alertTitle,</span><br><span class="line">      alertUser,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h2><p><code>toRefs</code>是一个用于结构响应式对象的api，如果我们想在模板中直接使用解构后的对象，就需要用这个api解构，直接使用三点运算符解构会使对象内部失去响应式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">      title,</span><br><span class="line">      user,</span><br><span class="line">      alertTitle,</span><br><span class="line">      alertUser,</span><br><span class="line">      ...toRefs(user),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p><code>computed</code>这个APi接收一个回调函数，当这个回调函数中的变量发生变化的时候就会重新调用这个回调。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let pass = computed(() =&gt; &#123;</span><br><span class="line">      if (userinfo.score &gt;= 60) &#123;</span><br><span class="line">        return &quot;及格&quot;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &quot;不及格&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Readonly原始数据"><a href="#Readonly原始数据" class="headerlink" title="Readonly原始数据"></a>Readonly原始数据</h2><p>在setup中不使用<code>ref</code>或者<code>reactive</code>定义的变量就是原始数据，也就是不具备响应式的数据。</p>
<p>当我们定义了像意识数据之后，可以使用<code>readonly</code>这个API返回一个原始原始的只读代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let userinfo = reactive(&#123;</span><br><span class="line">      firstName: &quot;admin&quot;,</span><br><span class="line">      lastName: &quot;123456&quot;,</span><br><span class="line">      score: 123,</span><br><span class="line">    &#125;);</span><br><span class="line">    userinfo = readonly(userinfo);</span><br></pre></td></tr></table></figure>

<h2 id="watch和watchEffect"><a href="#watch和watchEffect" class="headerlink" title="watch和watchEffect"></a>watch和watchEffect</h2><p><code>watch</code>和<code>watchEffect</code>都是用于监听函数变化的API，当然它们之间有一些区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//watch的用法</span><br><span class="line">//接收第一个参数作为监听的对象，注意，只能是完整的reactive对象或者是ref</span><br><span class="line">//第二个回调函数传入两个参数旧的值和新的值</span><br><span class="line">watch(data, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">    console.log(`num is $&#123;data.num&#125;`);</span><br><span class="line">    console.log(&quot;new Value is&quot; + newVal + &quot;,oldValue is &quot; + oldVal);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//watchEffect的用法</span><br><span class="line">//当方法里面的变量发生变化的时候执行</span><br><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">    console.log(`num is $&#123;data.num&#125;`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>watch和watchEffect的区别</strong></p>
<ul>
<li><code>watch</code>是懒执行的，只有监控的只改变的时候才会执行回调；<code>watchEffect</code>是在一开始就会执行至少一次的，用以收集依赖。</li>
<li><code>watch</code>监听的对象只要有任意改变都会执行回调，而<code>watchEffect</code>只有在回调内部的值内产生改变才会执行</li>
<li><code>watch</code>的回调可以拿到新值和旧值，<code>watchEffect</code>不能</li>
</ul>
<h2 id="watch、watchEffect与computed的区别"><a href="#watch、watchEffect与computed的区别" class="headerlink" title="watch、watchEffect与computed的区别"></a>watch、watchEffect与computed的区别</h2><p><code>computed</code>可以看作是一个用于自定义跟踪依赖回调的函数，它允许缓存数据，将它赋值给一个变量，就可以允许它在内部回调里面的依赖发生变化的时候计算。</p>
<ol>
<li>支持数据的缓存，就是可以用一个变量去存储它</li>
<li>函数内部数据的改变也会触发。</li>
<li>不支持异步，当<code>computed</code>内部有异步操作的时候<code>computed</code>无效</li>
<li><code>computed</code>可以套娃，就是可以在别的<code>computed</code>中使用前面的<code>computed</code></li>
</ol>
<p><code>watch</code>是一个属性监听器，一半用来监听属性的变化（也可以用来监听计算属性函数）</p>
<ol>
<li>不支持缓存</li>
<li>支持异步</li>
<li>第一个参数是需要监听的数据，第二个参数是回调函数，可以获取旧值和新值</li>
<li>监听的数据必须是data中声明的或者父组件传递过来的props中的数据。</li>
</ol>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex学习笔记01核心概念</title>
    <url>/2022/05/15/Vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex是Vue推荐使用的状态管理工具，它的功能强大，并且专门为Vue设计。</p>
<p>在我们制作项目的时候，往往会遇到组件之间通信的问题，对于Vue而言，父子组件通信十分方便，但是兄弟组件或者没有什么联系的组件之间通信就比较麻烦了，因为它们之间的通信需要一个所谓的中间人，无法直接通信。因此诞生了<code>eventbus</code>事件总线的方式。</p>
<p>Vue中的<code>eventbus</code>利用一个空的Vue组件作为中间人，从而使组件之间能够间接的通信，这在小型项目中是十分有用的，但是随着项目越来越大，<code>eventbus</code>的状态管理会越来越复杂。并且Vue3.0废除了<code>eventbus</code>依赖的一个API<code>$on</code>，因此<code>eventbus</code>的性价比变低了，这时候官方使用的Vuex就显得越来越重要了。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>vuex中有5个核心概念：</p>
<ul>
<li>State</li>
<li>Getter</li>
<li>Mutation</li>
<li>Action</li>
<li>Module</li>
</ul>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State是Vuex的单一状态树，所有的数据都存储在State上。</p>
<h5 id="使用方式-以Vue3为例-："><a href="#使用方式-以Vue3为例-：" class="headerlink" title="使用方式(以Vue3为例)："></a>使用方式(以Vue3为例)：</h5><ol>
<li><p>创建store实例并在Vue实例上使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从vuex中导入createStore方法，该方法，用于创建全局状态管理对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(&#123;</span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dd&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></li>
<li><p>在组件中引入<code>useStore</code>，在setup中创建store实例，就可以使用了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//创建store实例</span></span><br><span class="line">    <span class="keyword">let</span> $store = useStore();</span><br><span class="line">    <span class="built_in">console</span>.log($store.state.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>以语法糖<code>mapState</code>的方式使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> $store = useStore();</span><br><span class="line">    <span class="keyword">let</span> stateName = computed(mapState([<span class="string">&quot;name&quot;</span>]).name.bind(&#123; $store &#125;));</span><br><span class="line">    <span class="built_in">console</span>.log(stateName)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>有时候我们需要对state进行一些业务处理，比如进行过滤数组或者组合某些状态。这个时候就可以使用getter进行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从vuex中导入createStore方法，该方法，用于创建全局状态管理对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(&#123;</span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dd&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义状态得到计算属性</span></span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">getMutine</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.name + <span class="string">&#x27; &#x27;</span> + state.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> $store = useStore();</span><br><span class="line">    <span class="keyword">let</span> word = $store.getters.getMutine;</span><br><span class="line">    <span class="built_in">console</span>.log(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>在Vuex中，为了维护全局的状态统一，是<strong>不允许直接修改Vuex中的状态的</strong>。我们需要在store中定义修改的方法，然后再我们需要使用的地方调用，让Vuex来决定何时修改。<strong>Mutaion就是一个用于同步提交修改的事件类型</strong>。我们可以在<code>mutation</code>中定义对状态的修改方法,然后再组件实例中调用<code>commit</code>方法提交修改请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从vuex中导入createStore方法，该方法，用于创建全局状态管理对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(&#123;</span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dd&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//定义同步执行的方法</span></span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">updateName</span>(<span class="params">state, val</span>)</span> &#123;</span><br><span class="line">            state.name = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> $store = useStore();</span><br><span class="line">    $store.commit(<span class="string">&quot;updateName&quot;</span>, <span class="string">&quot;eede&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log($store.state.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意异步操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从vuex中导入createStore方法，该方法，用于创建全局状态管理对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(&#123;</span><br><span class="line">    <span class="comment">//定义状态</span></span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;dd&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//定义异步执行的方法</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="comment">//一秒后提交同步修改状态请求</span></span><br><span class="line">        <span class="function"><span class="title">updateName</span>(<span class="params">store, val</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                store.commit(<span class="string">&#x27;updateName&#x27;</span>, val)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> $store = useStore();</span><br><span class="line">    <span class="comment">//通过dispatch提交异步修改请求</span></span><br><span class="line">    $store.dispatch(<span class="string">&quot;updateName&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log($store.state.name);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。</p>
<p>为了解决这个问题，Vuex提出了module（模块）的概念，每一个模块都有自己的state、mutation、action、getter、甚至是嵌套子模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象语法树AST</title>
    <url>/2022/04/21/Vue%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91AST/</url>
    <content><![CDATA[<h1 id="抽象语法树AST"><a href="#抽象语法树AST" class="headerlink" title="抽象语法树AST"></a>抽象语法树AST</h1><p>抽象语法树（）是VUE编译阶段中的一个重要概念，是作用是将Vue提供的模板语法编译HTML模板语法，这个时候如果直接编译会比较麻烦，而且后续还要将html再转译为虚拟DOM来进行diff，这样显然费时费力，所以就需要借助AST将模板语法间接编译，再通过渲染函数转换为虚拟节点再到真实DOM。</p>
<h2 id="抽象语法树和虚拟节点的关系"><a href="#抽象语法树和虚拟节点的关系" class="headerlink" title="抽象语法树和虚拟节点的关系"></a>抽象语法树和虚拟节点的关系</h2><p>很多人觉得抽象语法树根虚拟节点很像，所以大概是一样的，其实不然。抽象语法树是Vue编译时的概念，只用于将Vue模板语法转化为真实DOM。而虚拟DOM是Vue运行时候的概念，用于优化DOM操作，提升DOM性能而使用的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220421101608901.png" alt="image-20220421101608901"></p>
<p>Vue的模板语法结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dd dasd&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;das&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;dd&quot;</span> <span class="attr">v-bind</span>=<span class="string">“dddsad”</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span> A f<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>B<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换后的AST结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;h3&quot;</span>,</span><br><span class="line">      <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;text&quot;</span>: <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;attrs&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: <span class="string">&quot;class&quot;</span>,</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;dd&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: <span class="string">&quot;v-bind&quot;</span>,</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="string">&quot;dddsad&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">      <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;li&quot;</span>,</span><br><span class="line">          <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;text&quot;</span>: <span class="string">&quot; A f&quot;</span>,</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;attrs&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;li&quot;</span>,</span><br><span class="line">          <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;text&quot;</span>: <span class="string">&quot;B&quot;</span>,</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;attrs&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;li&quot;</span>,</span><br><span class="line">          <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="string">&quot;text&quot;</span>: <span class="string">&quot;C&quot;</span>,</span><br><span class="line">              <span class="string">&quot;type&quot;</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ],</span><br><span class="line">          <span class="string">&quot;attrs&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;attrs&quot;</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;attrs&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;class&quot;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="string">&quot;dd dasd&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="string">&quot;das&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出AST拥有类似于虚拟DOM的结构，但是它是基于Vue的模板语法生成的，并不能直接同过Diff算法更新到页面上，例如<code>v-bind</code>属性再DOM中是不合法的，必须编译成DOM中的语法才可以。</p>
<h2 id="抽象语法树的核心"><a href="#抽象语法树的核心" class="headerlink" title="抽象语法树的核心"></a>抽象语法树的核心</h2><p>AST的算法核心就是将模板语法当成是字符串，然后将它的结构进行拆解分析重新组装为对象结构，方便后续使用和修改。为了实现这个算法，我们需要了解栈的思想和一定的正则表达式基础，就是将两个相同的模板直接的内容视为这个模板的内嵌内容。（注意，这里不考虑闭合标签如：<code>&lt;input /&gt;</code>,完整的算法会考虑到包括注释、运算符、关键字等等，这里只实现最低限度的核心）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> parseAttrsString <span class="keyword">from</span> <span class="string">&quot;./parseAttrsString.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">templateString</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">//字符串剩余的部分</span></span><br><span class="line">    <span class="keyword">let</span> rest = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//标签开始的标记</span></span><br><span class="line">    <span class="keyword">let</span> startRegExp = <span class="regexp">/^\&lt;([a-z]+[1-6]?)(\s[^\&lt;]+)?\&gt;/</span></span><br><span class="line">    <span class="comment">//标签结束的标记</span></span><br><span class="line">    <span class="keyword">let</span> endRegexp = <span class="regexp">/^\&lt;\/([a-z]+[1-6]?)\&gt;/</span></span><br><span class="line">    <span class="comment">//两个标签之间的文字</span></span><br><span class="line">    <span class="keyword">let</span> wordRegExp = <span class="regexp">/^([^\&lt;]+)(?&lt;!\ )\&lt;\/[a-z]+[1-6]?\&gt;/</span></span><br><span class="line">    <span class="comment">//准备两个栈</span></span><br><span class="line">    <span class="keyword">let</span> stack1 = []</span><br><span class="line">    <span class="keyword">let</span> stack2 = [&#123; <span class="string">&#x27;children&#x27;</span>: [] &#125;]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt; templateString.length - <span class="number">1</span>) &#123;</span><br><span class="line">        rest = templateString.substring(index)</span><br><span class="line">        <span class="keyword">if</span> (startRegExp.test(rest)) &#123;</span><br><span class="line">            <span class="comment">//识别开始标签</span></span><br><span class="line">            <span class="keyword">let</span> tag = rest.match(startRegExp)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">let</span> attrsString = rest.match(startRegExp)[<span class="number">2</span>]</span><br><span class="line">            <span class="comment">// console.log(&#x27;检测到开始标记&#x27;, tag)</span></span><br><span class="line">            <span class="comment">//将开始标记推入栈1中</span></span><br><span class="line">            stack1.push(tag)</span><br><span class="line">            <span class="comment">//将一个空数组（用于存储子数组）推如栈2中</span></span><br><span class="line">            <span class="comment">// console.log(attrsString)</span></span><br><span class="line">            stack2.push(&#123; <span class="string">&#x27;tag&#x27;</span>: tag, <span class="string">&#x27;children&#x27;</span>: [], <span class="string">&#x27;attrs&#x27;</span>: parseAttrsString(attrsString) &#125;)</span><br><span class="line">            <span class="keyword">const</span> attrsStringLength = attrsString ? attrsString.length : <span class="number">0</span></span><br><span class="line">            index += tag.length + <span class="number">2</span> + attrsStringLength</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (endRegexp.test(rest)) &#123;</span><br><span class="line">            <span class="comment">//识别结束标签</span></span><br><span class="line">            <span class="keyword">let</span> tag = rest.match(endRegexp)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment">// console.log(&#x27;检测到结束标记&#x27;, tag)</span></span><br><span class="line">            <span class="keyword">let</span> pop_tag = stack1.pop()</span><br><span class="line">            <span class="comment">//此时tag一定是和栈1顶部的元素是相同的</span></span><br><span class="line">            <span class="keyword">if</span> (tag === pop_tag) &#123;</span><br><span class="line">                <span class="keyword">let</span> pop_arr = stack2.pop()</span><br><span class="line">                <span class="keyword">if</span> (stack2.length) &#123;</span><br><span class="line">                    stack2[stack2.length - <span class="number">1</span>].children.push(pop_arr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;标签错误&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            index += tag.length + <span class="number">3</span></span><br><span class="line">            <span class="comment">// console.log(stack1, JSON.stringify(stack2))</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordRegExp.test(rest)) &#123;</span><br><span class="line">            <span class="comment">//识别标签之间有文字</span></span><br><span class="line">            <span class="keyword">let</span> word = rest.match(wordRegExp)[<span class="number">1</span>]</span><br><span class="line">            <span class="comment">// console.log(&#x27;检测到文字&#x27;, word)</span></span><br><span class="line">            <span class="comment">//改变此时stack2栈顶元素</span></span><br><span class="line">            stack2[stack2.length - <span class="number">1</span>].children.push(&#123; <span class="string">&#x27;text&#x27;</span>: word, <span class="string">&#x27;type&#x27;</span>: <span class="number">3</span> &#125;)</span><br><span class="line">            index += word.length</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回之前存储的stack2第一项</span></span><br><span class="line">    <span class="keyword">return</span> stack2[<span class="number">0</span>].children[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把attrsString变为数组返回</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">attrsString</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (attrsString == <span class="literal">null</span>) <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment">//将属性字符串中的属性名和属性值用正则别名的形式匹配出来</span></span><br><span class="line">    <span class="comment">//?&lt;name&gt;可以给正则匹配一个别名</span></span><br><span class="line">    <span class="comment">//\1可以复用没有给别名的原子组(),从一开始往后数，可以用来同步匹配规则</span></span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/(?&lt;name&gt;[\w-]+)(\s+)?=\2?([&quot;&#x27;])(?&lt;value&gt;[\w\s]+)?\3/g</span></span><br><span class="line">    <span class="keyword">let</span> match = attrsString.matchAll(reg)</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> match) &#123;</span><br><span class="line">        result.push(i.groups)</span><br><span class="line">        <span class="comment">// console.log(i)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> parse <span class="keyword">from</span> <span class="string">&quot;./parse.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> templateString = <span class="string">`&lt;div class=&quot;dd dasd&quot; id=&#x27;das&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;h3 class=&quot;dd&quot; v-bind=&#x27;dddsad&#x27;&gt;你好&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt; A f&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;B&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;C&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ast = parse(templateString)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(ast)))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex学习笔记02实现miniVuex</title>
    <url>/2022/05/15/Vuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E5%AE%9E%E7%8E%B0miniVuex/</url>
    <content><![CDATA[<h1 id="mini-Vue-amp-amp-mini-VueX"><a href="#mini-Vue-amp-amp-mini-VueX" class="headerlink" title="mini-Vue&amp;&amp;mini-VueX"></a>mini-Vue&amp;&amp;mini-VueX</h1><p>我们在Vue中使用Vuex的步骤是先引入Vuex，然后<code>createStore</code>，将配置项做好之后，调用Vue实例<code>app.use()</code>,从而实现挂载了Vuex这个插件。</p>
<h2 id="app-use"><a href="#app-use" class="headerlink" title="app.use()"></a>app.use()</h2><p>在<code>potions API</code>中我们会将插件挂载到全局Vue实例中<code>app.globalProperties.$store = store</code></p>
<p>而在<code>composition API</code>中为了实现组件化，我们需要通过<code>install</code>方法将我们需要被挂载插件的对象传入到插件构造方法内部。</p>
<p>这也是文档一定要我们实现一个install方法的原因,<code>app.use()</code>会调用store提供的这个install方法，并把<code>app</code>传给它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现一个具有创建app实例功能的mini-Vue</span></span><br><span class="line"><span class="keyword">const</span> MiniVue = &#123;</span><br><span class="line">    <span class="function"><span class="title">createApp</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> app = &#123;</span><br><span class="line">            <span class="function"><span class="title">mount</span>(<span class="params">selector</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(selector)</span><br><span class="line">                <span class="keyword">const</span> ctx = options.setup()</span><br><span class="line">                <span class="comment">//监听渲染函数，达到实时刷新数据的效果</span></span><br><span class="line">                watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> el = options.render.call(ctx)</span><br><span class="line">                    parent.innerHTML = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    parent.appendChild(el)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//实现use方法，在实例上使用插件</span></span><br><span class="line">            <span class="function"><span class="title">use</span>(<span class="params">plugin, ...options</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (plugin &amp;&amp; <span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                    plugin.install(app, ...options)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.warn(<span class="string">&#x27;请传入plugin对象，并且提供和一个install方法&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                plugin.install(app)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现store类"><a href="#实现store类" class="headerlink" title="实现store类"></a>实现store类</h2><p>我们在使用Vuex的时候是先<code>createStore</code>，在这个函数里面传入state、mutations等参数。根据module的概念，我们可以创建多个store实例，这里我们使用类方法创建一个Store类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = []</span><br><span class="line"><span class="comment">//创建Store类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//状态树直接使用reactive令他变为响应式的</span></span><br><span class="line">        <span class="built_in">this</span>._state = reactive(&#123;</span><br><span class="line">            <span class="attr">data</span>: options.state</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//获取修改状态的方法mutations</span></span><br><span class="line">        <span class="built_in">this</span>._mutations = options.mutations</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">state</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._state.data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mutations的提交方法</span></span><br><span class="line">    <span class="function"><span class="title">commit</span>(<span class="params">type, payload</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">        <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">&#x27;mutitaion不存在&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        entry(<span class="built_in">this</span>.state, payload)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过install在app上进行扩展插件的操作</span></span><br><span class="line">    <span class="function"><span class="title">install</span>(<span class="params">app, injectKey</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//扩展app</span></span><br><span class="line">        <span class="comment">//为app全局挂载上$store，在这个小demo中没必要</span></span><br><span class="line">        <span class="comment">// app.config.globalProperties.$store = this</span></span><br><span class="line">        <span class="comment">//在setup中这样使用很简单，现在的demo没有这个条件，改用更简单的方式</span></span><br><span class="line">        <span class="comment">// provide(&#x27;store&#x27;, this)</span></span><br><span class="line">        <span class="comment">//挂载到this上</span></span><br><span class="line">        map[injectKey || <span class="string">&#x27;store&#x27;</span>] = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Store(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useStore</span>(<span class="params">key = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return inject(&#x27;store&#x27;)</span></span><br><span class="line">    <span class="comment">//在composition API中我们为需要install的实例挂载，用一个简易的全局变量进行通信</span></span><br><span class="line">    <span class="keyword">return</span> map[key !== <span class="literal">null</span> ? key : <span class="string">&#x27;store&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整体实现"><a href="#整体实现" class="headerlink" title="整体实现"></a>整体实现</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://unpkg.com/vue@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://unpkg.com/vuex@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; ref, reactive, computed, watchEffect &#125; = Vue</span></span><br><span class="line"><span class="javascript">    <span class="comment">// const &#123; createStore, useStore &#125; = Vuex</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> MiniVue = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">createApp</span>(<span class="params">options</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> app = &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">mount</span>(<span class="params">selector</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(selector)</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">const</span> ctx = options.setup()</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                    watchEffect(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> el = options.render.call(ctx)</span></span><br><span class="line"><span class="javascript">                        parent.innerHTML = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">                        parent.appendChild(el)</span></span><br><span class="line"><span class="javascript">                    &#125;)</span></span><br><span class="line"><span class="javascript">                &#125;,</span></span><br><span class="line"><span class="javascript">                <span class="comment">//实现use方法，在实例上使用插件</span></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">use</span>(<span class="params">plugin, ...options</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (plugin &amp;&amp; <span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        plugin.install(app, ...options)</span></span><br><span class="line"><span class="javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.warn(<span class="string">&#x27;请传入plugin对象，并且提供和一个install方法&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                    plugin.install(app)</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> app</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> map = []</span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建Store类</span></span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//状态树直接使用reactive令他变为响应式的</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>._state = reactive(&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">data</span>: options.state</span></span><br><span class="line"><span class="javascript">            &#125;)</span></span><br><span class="line"><span class="javascript">            <span class="comment">//获取修改状态的方法mutations</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>._mutations = options.mutations</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">get</span> <span class="title">state</span>() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">this</span>._state.data</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//mutations的提交方法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">commit</span>(<span class="params">type, payload</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> entry = <span class="built_in">this</span>._mutations[type]</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (!entry) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.error(<span class="string">&#x27;mutitaion不存在&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            entry(<span class="built_in">this</span>.state, payload)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//通过install在app上进行扩展插件的操作</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">install</span>(<span class="params">app, injectKey</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//扩展app</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//为app全局挂载上$store</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// app.config.globalProperties.$store = this</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// provide(&#x27;store&#x27;, this)</span></span></span><br><span class="line"><span class="javascript">            map[injectKey || <span class="string">&#x27;store&#x27;</span>] = <span class="built_in">this</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">options</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> Store(options)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">useStore</span>(<span class="params">key = <span class="literal">null</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// return inject(&#x27;store&#x27;)</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> map[key !== <span class="literal">null</span> ? key : <span class="string">&#x27;store&#x27;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = MiniVue.createApp(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> counter = ref(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                counter.value++</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                counter, add</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> h3 = <span class="built_in">document</span>.createElement(<span class="string">&#x27;h3&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            h3.innerHTML = <span class="built_in">this</span>.counter.value</span></span><br><span class="line"><span class="javascript">            h3.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="built_in">this</span>.add)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> h3</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建store实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> store = createStore(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">state</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">counter</span>: <span class="number">1</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">mutations</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                state.counter++</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">//在app实例挂载之前use插件</span></span></span><br><span class="line"><span class="javascript">    app.use(store)</span></span><br><span class="line"><span class="javascript">    app.mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>视频链接：<a href="https://www.bilibili.com/video/BV1E34y1Q7uA">https://www.bilibili.com/video/BV1E34y1Q7uA</a></p>
]]></content>
      <categories>
        <category>Vuex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue事件机制</title>
    <url>/2022/04/14/Vue%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Vue事件机制"><a href="#Vue事件机制" class="headerlink" title="Vue事件机制"></a>Vue事件机制</h1><p>在Vue中，事件绑定分为两种，</p>
<p>一种是DOM原生的事件绑定，也就是<code>addEventListener</code>；</p>
<p>另一种就是Vue的绑定机制<code>v-on,@</code>,通过这种方式添加的事件绑定，都会先经过Vue模板编译，生成抽象树（ast），在生成render函数，通过render函数生成我们的VDOM，最终生成真实DOM。</p>
<p>那么Vue是如何自定义绑定事件的，而如果是在组件上绑定函数事件的时候又发生了什么。</p>
<h2 id="简单点击事件"><a href="#简单点击事件" class="headerlink" title="简单点击事件"></a>简单点击事件</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test1&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;click1&quot;</span>&gt;</span>click1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test2&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;click2&quot;</span>&gt;</span>click2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类似于上面这种只涉及本组件的点击事件的绑定，我们将其称为简单点击事件。</p>
<p>建立这样一个简单点击事件的步骤是：</p>
<ol>
<li><p>调用initState(Vue)方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line"> vm._watchers = [];</span><br><span class="line"> <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line"> <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props); &#125;</span><br><span class="line"> <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.methods); &#125;<span class="comment">//因为绑定的是一个函数，使用这个初始化事件</span></span><br><span class="line"> <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line"> initData(vm);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line"> <span class="keyword">if</span> (opts.watch) &#123; initWatch(vm, opts.watch); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将methos方法代理到Vue[key]中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接着看看initMethods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm, methods</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> props = vm.$options.props;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line"> vm[key] = methods[key] == <span class="literal">null</span> ? noop : bind(methods[key], vm);<span class="comment">//调用了bind方法，我们再看看bind</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> (methods[key] == <span class="literal">null</span>) &#123;</span><br><span class="line">  warn(</span><br><span class="line">   <span class="string">&quot;method \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; has an undefined value in the component definition. &quot;</span> +</span><br><span class="line">   <span class="string">&quot;Did you reference the function correctly?&quot;</span>,</span><br><span class="line">   vm</span><br><span class="line">  );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">  warn(</span><br><span class="line">   (<span class="string">&quot;method \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; has already been defined as a prop.&quot;</span>),</span><br><span class="line">   vm</span><br><span class="line">  );</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为每个函数绑定作用域和返回这个绑定了作用域的函数，准备随时调用（响应式）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们接着看看bind</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn, ctx</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">boundFn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> l = <span class="built_in">arguments</span>.length;</span><br><span class="line"> <span class="keyword">return</span> l</span><br><span class="line">  ? l &gt; <span class="number">1</span></span><br><span class="line">  ? fn.apply(ctx, <span class="built_in">arguments</span>)<span class="comment">//通过返回函数修饰了事件的回调函数。绑定了事件回调函数的this。并且让参数自定义。更加的灵活</span></span><br><span class="line">  : fn.call(ctx, a)</span><br><span class="line">  : fn.call(ctx)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// record original fn length</span></span><br><span class="line"> boundFn._length = fn.length;</span><br><span class="line"> <span class="keyword">return</span> boundFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Vue在进入compile环节时需要将这个div变成抽象树（ast）当编译到该div时经过核心函数genHandler：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genHandler</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">name,</span></span></span><br><span class="line"><span class="params"><span class="function"> handler</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;function()&#123;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;[&quot;</span> + (handler.map(<span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123; <span class="keyword">return</span> genHandler(name, handler); &#125;).join(<span class="string">&#x27;,&#x27;</span>)) + <span class="string">&quot;]&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isMethodPath = simplePathRE.test(handler.value);</span><br><span class="line">    <span class="keyword">var</span> isFunctionExpression = fnExpRE.test(handler.value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handler.modifiers) &#123;</span><br><span class="line">        <span class="keyword">return</span> isMethodPath || isFunctionExpression<span class="comment">//假如没有修饰符。直接返回回调函数</span></span><br><span class="line">            ? handler.value</span><br><span class="line">        : (<span class="string">&quot;function($event)&#123;&quot;</span> + (handler.value) + <span class="string">&quot;&#125;&quot;</span>) <span class="comment">// inline statement</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> code = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> genModifierCode = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> keys = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> handler.modifiers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (modifierCode[key]) &#123;</span><br><span class="line">                genModifierCode += modifierCode[key];<span class="comment">//处理修饰符数组，例如.stop就在回调函数里加入event.stopPropagation()再返回。实现修饰的目的</span></span><br><span class="line">                <span class="comment">// left/right</span></span><br><span class="line">                <span class="keyword">if</span> (keyCodes[key]) &#123;</span><br><span class="line">                    keys.push(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                keys.push(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (keys.length) &#123;</span><br><span class="line">            code += genKeyFilter(keys);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure modifiers like prevent and stop get executed after key filtering</span></span><br><span class="line">        <span class="keyword">if</span> (genModifierCode) &#123;</span><br><span class="line">            code += genModifierCode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> handlerCode = isMethodPath</span><br><span class="line">        ? handler.value + <span class="string">&#x27;($event)&#x27;</span></span><br><span class="line">        : isFunctionExpression</span><br><span class="line">        ? (<span class="string">&quot;(&quot;</span> + (handler.value) + <span class="string">&quot;)($event)&quot;</span>)</span><br><span class="line">        : handler.value;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;function($event)&#123;&quot;</span> + code + handlerCode + <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步很清晰了，对于可能存在的修饰符进行处理，绑定上真实DOM上的真实事件函数，全部处理完毕的话虚拟DOM就已经完成了，接下来只需要将这个虚拟DOM编译为真实DOM就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_c(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;test1&quot;</span>&#125;,<span class="attr">on</span>:&#123;<span class="string">&quot;click&quot;</span>:click1&#125;&#125;,[_v(<span class="string">&quot;click1&quot;</span>)]),_v(<span class="string">&quot; &quot;</span>),_c(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;test2&quot;</span>&#125;,<span class="attr">on</span>:&#123;<span class="string">&quot;click&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params">$event</span>)</span>&#123;$event.stopPropagation();click2($event)&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用核心函数，渲染真实DOM</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add$1</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">event,</span></span></span><br><span class="line"><span class="params"><span class="function"> handler,</span></span></span><br><span class="line"><span class="params"><span class="function"> once$$<span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> capture,</span></span></span><br><span class="line"><span class="params"><span class="function"> passive</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (once$$1) &#123;</span><br><span class="line">        <span class="keyword">var</span> oldHandler = handler;</span><br><span class="line">        <span class="keyword">var</span> _target = target$<span class="number">1</span>; <span class="comment">// save current target element in closure</span></span><br><span class="line">        handler = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> res = <span class="built_in">arguments</span>.length === <span class="number">1</span></span><br><span class="line">            ? oldHandler(ev)</span><br><span class="line">            : oldHandler.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">            <span class="keyword">if</span> (res !== <span class="literal">null</span>) &#123;</span><br><span class="line">                remove$<span class="number">2</span>(event, handler, capture, _target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    target$<span class="number">1.</span>addEventListener(</span><br><span class="line">        event,</span><br><span class="line">        handler,</span><br><span class="line">        supportsPassive</span><br><span class="line">        ? &#123; <span class="attr">capture</span>: capture, <span class="attr">passive</span>: passive &#125;<span class="comment">//此处绑定点击事件</span></span><br><span class="line">        : capture</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="组件事件绑定"><a href="#组件事件绑定" class="headerlink" title="组件事件绑定"></a>组件事件绑定</h2><p>相比于前面的事件绑定，组件事件绑定会涉及到组件之间的交互通信，因此不能和前面的事件一样走</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">&quot;nativeclick&quot;</span> <span class="attr">v-on:componenton</span>=<span class="string">&quot;parentOn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>两个例子唯一的区别就是是否有修饰符<code>.native</code>，这个修饰符的作用是在原生DOM上绑定事件，也就是和第一种绑定一样。</p>
<p>第二种没有修饰符的事件绑定调用的是$on函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> this$<span class="number">1</span> = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">            this$<span class="number">1.</span>$on(event[i], fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (vm._events[event] || (vm._events[event] = [])).push(fn);<span class="comment">//存入事件</span></span><br><span class="line">        <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">        <span class="comment">// instead of a hash lookup</span></span><br><span class="line">        <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">            vm._hasHookEvent = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(vm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> lowerCaseEvent = event.toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">            tip(</span><br><span class="line">                <span class="string">&quot;Event \&quot;&quot;</span> + lowerCaseEvent + <span class="string">&quot;\&quot; is emitted in component &quot;</span> +</span><br><span class="line">                (formatComponentName(vm)) + <span class="string">&quot; but the handler is registered for \&quot;&quot;</span> + event + <span class="string">&quot;\&quot;. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Note that HTML attributes are case-insensitive and you cannot use &quot;</span> +</span><br><span class="line">                <span class="string">&quot;v-on to listen to camelCase events when using in-DOM templates. &quot;</span> +</span><br><span class="line">                <span class="string">&quot;You should probably use \&quot;&quot;</span> + (hyphenate(event)) + <span class="string">&quot;\&quot; instead of \&quot;&quot;</span> + event + <span class="string">&quot;\&quot;.&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cbs = vm._events[event];</span><br><span class="line">    <span class="built_in">console</span>.log(cbs);</span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">        cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs;</span><br><span class="line">        <span class="keyword">var</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">            cbs[i].apply(vm, args);／／当emit的时候调用该事件。注意上面说的vue在初始化的守候。用bind修饰了事件函数。所以组件上挂载的事件都是在父作用域中的</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说，在vue实例上的事件会调用<code>$on,$emit</code>之类的方法构成一个订阅/发布机制，用来为组件通信服务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>在普通html元素和在组件上挂载了<code>.native</code>修饰符的事件。最终成为EventTarget.addEventListener()改在事件</li>
<li>在组件上的事件，会调用Vue原型上的$on,$emit</li>
</ol>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记01</title>
    <url>/2021/12/04/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B001%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><p>从原理上来讲vue是利用了Object的defineProperty的属性，它把我们放进去的data中每一个属性都设置了getter和setter，这样当data的属性值更新后，我们就会收到通知，并可以通知那些需要更新的地方去进行更新。</p>
<h3 id="getter-amp-amp-setter简单实现"><a href="#getter-amp-amp-setter简单实现" class="headerlink" title="getter&amp;&amp;setter简单实现"></a>getter&amp;&amp;setter简单实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查是否为对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">        &amp;&amp; !<span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">        &amp;&amp; obj !==<span class="literal">null</span></span><br><span class="line">        &amp;&amp; obj !==<span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">convert</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isObject(obj))&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为每个对象的键值对添加getter和setter</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//提供变量存储键对应的值</span></span><br><span class="line">            <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">                <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`getting key &quot;<span class="subst">$&#123;key&#125;</span>&quot;: <span class="subst">$&#123;internalValue&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">return</span> internalValue</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`setting key &quot;<span class="subst">$&#123;key&#125;</span>&quot; to: <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">                    internalValue = newValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="依赖跟踪"><a href="#依赖跟踪" class="headerlink" title="依赖跟踪"></a>依赖跟踪</h3><p>使用上面的getter和setter我们模拟了对象的响应式，那么问题来了，假设我们有一个对象，其中有个属性added：233，我们在一个函数中使用了这个added做一个加法，得到了一个结果，但是我们修改了added的值，并期望函数的结果也会随之改变，这要怎么实现呢？、</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a class representing a dependency</span></span><br><span class="line"><span class="comment">// exposing it on window is necessary for testing</span></span><br><span class="line"><span class="built_in">window</span>.Dep = <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//设置一个变量存储</span></span><br><span class="line">      <span class="built_in">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跟踪函数依赖，类似于在此处插眼</span></span><br><span class="line">    depend () &#123;</span><br><span class="line">      <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">        <span class="comment">// register the current active update as a subscriber</span></span><br><span class="line">          <span class="comment">//将跟踪的函数加入到set表中</span></span><br><span class="line">        <span class="built_in">this</span>.subscribers.add(activeUpdate)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新执行函数，在刚刚插眼的函数中重新执行该函数，达到更新的效果</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">      <span class="comment">// run all subscriber functions</span></span><br><span class="line">        <span class="comment">//set列表中的每一个函数都重新执行</span></span><br><span class="line">      <span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">subscriber</span> =&gt;</span> subscriber())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用一个全局变量储存函数（重点！）,这样可以让类实例在外部访问这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrappedUpdate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    activeUpdate = wrappedUpdate</span><br><span class="line">    update()</span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>简单来讲，就是创建一个类，它提供一种类似“插眼”的功能（depend ()），我们在需要跟踪的函数中插入这个眼，当我们需要它更新时，再调用这个眼（notify ()）重新执行一遍函数，达到更新结果的目的。</p>
<h3 id="迷你观察者"><a href="#迷你观察者" class="headerlink" title="迷你观察者"></a>迷你观察者</h3><p>我们把依赖追踪和getter&amp;&amp;setter结合起来，就可以完成我们需要的功能了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">      &amp;&amp; !<span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">      &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">      &amp;&amp; obj !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(obj))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> internalValue = obj[key]</span><br><span class="line">        <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">            get () &#123;</span><br><span class="line">                <span class="comment">//插眼</span></span><br><span class="line">                dep.depend()</span><br><span class="line">                <span class="keyword">return</span> internalValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> ifValueChange = v !==internalValue</span><br><span class="line">                <span class="keyword">if</span>(ifValueChange)&#123;</span><br><span class="line">                    internalValue = v</span><br><span class="line">                    <span class="comment">//检测到数值变化重新调用该函数</span></span><br><span class="line">                    dep.notify()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.Dep = <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeUpdate) &#123;</span><br><span class="line">      <span class="comment">// register the current active update as a subscriber</span></span><br><span class="line">      <span class="built_in">this</span>.subscribers.add(activeUpdate)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// run all subscriber functions</span></span><br><span class="line">    <span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">subscriber</span> =&gt;</span> subscriber())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> activeUpdate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span> (<span class="params">update</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">wrappedUpdate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    activeUpdate = wrappedUpdate</span><br><span class="line">    update()</span><br><span class="line">    activeUpdate = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  wrappedUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>可以看到我们把插眼这个动作放到了getter里面，把重新调用放到了setter里面，这样我们就可以监听对象的变化，一旦它的属性值发生改变，就会触发重新调用，这样就达到了监听对象，并实时更新与他有关的值，即Vue响应式的简单原理。</p>
<p>参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p>参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记02</title>
    <url>/2021/12/04/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B002%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="编写一个简单插件"><a href="#编写一个简单插件" class="headerlink" title="编写一个简单插件"></a>编写一个简单插件</h2><p>Vue中有一个强大的功能就是提供插件的使用:</p>
<h3 id="Vue-use-Plugin"><a href="#Vue-use-Plugin" class="headerlink" title="Vue.use(Plugin)"></a>Vue.use(Plugin)</h3><p>通过简单的use命令就可以调用各种各样的插件，极大方便了我们的日常开发。那么如何编写一个插件呢？</p>
<p>插件（Plugin）本质上就是一个函数，它接受一个参数是Vue构造器，另一个参数是可选的选项对象options。<br>另一个需要了解的技术是Vue.mixin:</p>
<h3 id="Vue-mixin-options"><a href="#Vue-mixin-options" class="headerlink" title="Vue.mixin(options)"></a>Vue.mixin(options)</h3><p>mixins本质上是一段可重复利用的代码段，Vue.mixin(options)是一个全局的api，所以它可以应用到所有实例之中。注意！因为它可以混入到所有实例中，所以我们在使用它的时候要格外的小心。</p>
<p>如果你想使用一些全局上的功能，可能会用到mixin，但是如果你需要反复调用mixin，最好的办法是将其用插件接口包装，这样插件会防止被反复应用。<br>最后一个知识点是$options:</p>
<h3 id="options"><a href="#options" class="headerlink" title="$options"></a>$options</h3><p>$options是一个对象，他会收集包括</p>
<p>1.全局mixins</p>
<p>2.组件自定义的mixin</p>
<p>3.你传递给他的选项（options）</p>
<p>4.你添加到组件的任何自定义项<br>利用上面说到的知识，就可以编写一个简单的插件了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RulesPlugin = &#123;</span><br><span class="line">    <span class="comment">//加载vue插件，稍后使用Vue.use注册它</span></span><br><span class="line">  install (Vue) &#123;</span><br><span class="line">      <span class="comment">//全局混入，注意，它将影响之后创建的每一个vue实例！</span></span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        <span class="comment">//在created生命周期钩子处注册函数</span></span><br><span class="line">      created () &#123;</span><br><span class="line">          <span class="comment">//在data外定义的属性和方法可以用$options调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.hasOwnProperty(<span class="string">&#x27;rules&#x27;</span>)) &#123;</span><br><span class="line">          <span class="keyword">const</span> rules = <span class="built_in">this</span>.$options.rules</span><br><span class="line">          <span class="built_in">Object</span>.keys(rules).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> rule = rules[key]</span><br><span class="line">              <span class="comment">//监听rules对象中的每一个属性变化</span></span><br><span class="line">            <span class="built_in">this</span>.$watch(key, <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> result = rule.validate(newValue)</span><br><span class="line">              <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(rule.message)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Vue.use(RulesPlugin)</span><br></pre></td></tr></table></figure>

<p>这个插件的作用是监听一个Vue实例中data的属性值，当其中的属性值发生改变的时候，就会检查对应的规则，并进行校验。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">foo</span>: <span class="number">10</span>,<span class="attr">bar</span> :<span class="number">10</span> &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">1</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;foo must be greater than one&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bar</span>: &#123;</span><br><span class="line">      <span class="attr">validate</span>: <span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">1</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;gun yuan dian&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">vm.foo = <span class="number">1</span> <span class="comment">// should log: &quot;foo must be greater than one&quot;</span></span><br></pre></td></tr></table></figure>

<p> 参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p>参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记03</title>
    <url>/2021/12/04/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B003%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="Render-Function"><a href="#Render-Function" class="headerlink" title="Render Function"></a>Render Function</h3><p>渲染函数是组成完整的响应性渲染系统的另外一半，Vue的template实际上是通过渲染函数渲染出来的。</p>
<p>在Vue上下文中，当我们第一次渲染一个Vue应用时，会将template放到渲染函数进行编译。Render函数实际上是一个返回虚拟DOM的函数，然后Vue基于虚拟DOM生成真实DOM。</p>
<p>在后续的产生虚拟DOM的过程本质上是调用渲染函数，因为渲染函数和所有的data属性有依赖关系，在Vue中，这些data属性是具有响应性的，所有这些data属性会帮助这个组件的渲染函数收集依赖，如果这些依赖关系中的任何一个发生变化，将会再次调用渲染函数，它会返回一个新的虚拟DOM，新的虚拟DOM会和旧的虚拟DOM进行比较，最后，把最少量的更改应用到真实DOM中。</p>
<h3 id="Render-Function-API"><a href="#Render-Function-API" class="headerlink" title="Render Function API"></a>Render Function API</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    render (h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [...])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> render函数接收一个参数h（hyper script超文本脚本），h需要三个参数，第一个参数是元素类型，第二个参数是数据对象（可选），第三个参数是一个数组表示子节点。它会返回这个虚拟DOM树的顶层元素，以便返回整个树。</p>
<h3 id="虚拟DOM（Virtual-DOM）"><a href="#虚拟DOM（Virtual-DOM）" class="headerlink" title="虚拟DOM（Virtual DOM）"></a>虚拟DOM（Virtual DOM）</h3><p> 通常情况下，调用真实DOM的开销十分的大，因为真实DOM具有非常多的属性，并且它在底层实现也十分的复杂。所以很多时候我们会说直接修改DOM是比较缓慢的。虚拟DOM的结构十分简单，因此它的开销会比真实DOM小很多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Virtual DOM</span><br><span class="line"></span><br><span class="line"><span class="comment">//tag标签名；data数据对象，如果没有数据对象可以忽略</span></span><br><span class="line"><span class="comment">//children可以拥有子虚拟节点，这样就构成了一个虚拟DOM树</span></span><br><span class="line">&#123; <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>, <span class="attr">data</span>:&#123; <span class="attr">attrs</span>:&#123;&#125;, ...&#125;, <span class="attr">children</span>:[] &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>虚拟DOM的本质是用轻量的Javascript数据格式来表示真实DOM在特定时间的外在表现，我们每次更新信息，先构造一个新的虚拟DOM，我们先计算差异，然后将这些更改应用到DOM上。</p>
<h3 id="响应性和Render-Function整合"><a href="#响应性和Render-Function整合" class="headerlink" title="响应性和Render Function整合"></a>响应性和Render Function整合</h3><p><img src="https://img-blog.csdnimg.cn/82151c8e6d0d47058fd61a0cc8a9d6e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAam9rZXJfMjE=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 每一个组件都有一个渲染函数，它实际上包装在我们之前实现的autorun函数（笔记1）中，当数据发生变化的时候，观察者（wathcer）通过调用data属性中的getter收集依赖项，并监听setter，将收集到的改变通知到渲染函数，渲染函数再生成一个新的虚拟DOM。只要我们依赖的渲染属性发生变化，就会不断循环上述步骤。</p>
<p>每个组件都有自己的自动循环渲染，组件树有许多组件构成，每个组件都只负责自己的依赖。</p>
<p>由于你可以更改数据依赖关系，你的数据可以再任何地方发生改变，但是因为么个组件都只负责自己的依赖，再整个组件树中我们确切的知道哪些组件受到哪些数据的影响，所以，它有一个精确的依赖跟踪系统，不会造成过多的组件发生不必要的重新渲染。</p>
<p>相比于React自上而下的渲染模型，Vue可以说省去了一部分优化的工作。但是也付出了一部分将数据转换为getter和setter的开销。因此有了React上限高（优化做得好的话），下限低（优化不好），而Vue下限高（一部分优化工作自动完成），上限低（相比React开销更大一些）。但是在实际应用中，两者的差距其实很小，只有在极端情况下才会出现较大偏差。</p>
<h3 id="动态渲染标签"><a href="#动态渲染标签" class="headerlink" title="动态渲染标签"></a>动态渲染标签</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">example</span> <span class="attr">:tags</span>=<span class="string">&quot;[&#x27;h1&#x27;, &#x27;h2&#x27;, &#x27;h3&#x27;]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个新的Vue组件，组件就是自定义元素，</span></span><br><span class="line"><span class="comment">//第一个参数为组件名，第二个参数为可选的函数部分，第三个参数为template写组件内容</span></span><br><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//表示组件是纯函数式组件，只根据props计算渲染输出，本身不包含不改变仍和state</span></span><br><span class="line">  <span class="attr">functional</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">tags</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="comment">//自定义验证函数</span></span><br><span class="line">      validator (arr) &#123;<span class="keyword">return</span> !!arr.length &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//渲染函数</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h, context</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tags = context.props.tags</span><br><span class="line">    <span class="comment">//hyper script，接受第一个参数为tagname标签名</span></span><br><span class="line">    <span class="comment">//第二个参数为数据对象（可选），第三个参数为子节点</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, context.data, tags.map(<span class="function">(<span class="params">tag, index</span>) =&gt;</span> h(tag, index)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="更进一步，动态渲染组件"><a href="#更进一步，动态渲染组件" class="headerlink" title="更进一步，动态渲染组件"></a>更进一步，动态渲染组件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">example</span> <span class="attr">:ok</span>=<span class="string">&quot;ok&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">example</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;ok = !ok&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> Foo = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">functional</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> Bar = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">functional</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">functional</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">ok</span>: <span class="built_in">Boolean</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//由于函数式组件中没有this，参数需要靠context来传递;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">render</span>: <span class="function">(<span class="params">h, context</span>) =&gt;</span> h(context.props.ok ? Foo : Bar)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">new</span> Vue(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">ok</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>context 参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props：提供所有 prop 的对象</span><br><span class="line">children: VNode 子节点的数组</span><br><span class="line">slots: 一个函数，返回了包含所有插槽的对象</span><br><span class="line">scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</span><br><span class="line">data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</span><br><span class="line">parent：对父组件的引用</span><br><span class="line">listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是data.on 的一个别名。</span><br><span class="line">injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p>参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记04</title>
    <url>/2021/12/05/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B004%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>简单来说，就是一个封装了一个或多个具体功能的组件，它与外界的联系只有简单的props，这样可以保证这个组件与其他组件的耦合度最低，可复用性强，并且不容易污染其他组件。</p>
<h3 id="高阶函数和Mixins"><a href="#高阶函数和Mixins" class="headerlink" title="高阶函数和Mixins"></a>高阶函数和Mixins</h3><p>高阶函数不会污染外部函数，可以在其他组件中被复用。如果确定组件只用在这个项目中，他只处理非常具体的任务，那么使用mixin也是可以的。</p>
<p>由于高阶函数与其他组件耦合度低，也使得它更好的进行测试，可以分别测试增强组件和内部组件，相反，使用Mixin时，你只能测试一个组件。</p>
<p>然而，有时候Mixin比高阶函数更容易掌握，当你使用了太多的高阶组件时，组件的层级会变得复杂，使得难以定位错误，还有搞清楚它们的层级关系，和他们之间的影响。而且，当你多层嵌套时，你需要注意属性需要经过多层传递，嵌套多层组件也会带来一些性能开销，使用mixin的话往往能节省这些开销，所以要视情况使用。</p>
<h3 id="高阶函数的实现"><a href="#高阶函数的实现" class="headerlink" title="高阶函数的实现"></a>高阶函数的实现</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">smart-avatar</span> <span class="attr">username</span>=<span class="string">&quot;vuejs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">smart-avatar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// mock API</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fetchURL</span> (<span class="params">username, cb</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// hard coded, bonus: exercise: make it fetch from gravatar!</span></span></span><br><span class="line"><span class="javascript">            cb(<span class="string">&#x27;https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="number">500</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> Avatar = &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">props</span>: [<span class="string">&#x27;src&#x27;</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>: <span class="string">`&lt;img :src=&quot;src&quot;&gt;`</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//高阶组件</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">withAvatarURL</span> (<span class="params">InnerComponent</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">username</span>: <span class="built_in">String</span></span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            data () &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">url</span>: <span class="string">&#x27;http://via.placeholder.com/200x200&#x27;</span></span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            created () &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//在这里进行请求</span></span></span><br><span class="line"><span class="javascript">                fetchURL(<span class="built_in">this</span>.username, <span class="function">(<span class="params">url</span>) =&gt;</span> &#123; <span class="built_in">this</span>.url = url &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            render (h) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//渲染一个image标签，第二个参数给src传值</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> h(InnerComponent, &#123; <span class="attr">props</span>: &#123; <span class="attr">src</span>: <span class="built_in">this</span>.url &#125; &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> SmartAvatar = withAvatarURL(Avatar)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">components</span>: &#123; SmartAvatar &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p> 参考视频：<a href="https://www.bilibili.com/video/av51444410/">尤雨溪教你写vue 高级vue教程 源码分析 中文字幕翻译完毕_哔哩哔哩_bilibili</a></p>
<p> 参考github：<a href="https://github.com/zhengguorong/vue-advanced-workshop">https://github.com/zhengguorong/vue-advanced-workshop</a></p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记05</title>
    <url>/2021/12/06/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B005%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><p>在以前，前端没有状态管理的概念。人们试图把MVC这个概念引入到前端中，把状态叫做模型。在很多场景下，这是一中很好的抽象。但是主要问题是我们缺乏一种以声明的方式将模型与渲染结合。</p>
<p>在Vue等前端框架中，优势是状态已经透明到链接的Vue中，当然这也有问题，因为它太容易将状态传播到任何地方，并在任何地方进行修改。随着项目规模的增大，跟踪储存状态的位置立即改变状态的位置会变得越来越困难。</p>
<p>总体而言，很多问题实际上是查明问题的来源并且没有适当的模式让你管理和状态有关的代码。这会导致你的应用变得越来越不可预测。因此，状态管理只是前端开发人员试图找出一种科学方法解决代码如何存放和状态如何管理的问题。从而当问题出现的时候可以更轻松地查明问题。</p>
<p>Flux就是第一个关于单向数据流的想法。</p>
<p>在Vue中一切都很直接，只需要将状态放入组件中即可。实际上，很多简单场景已经够用。状态管理库或状态管理模式不一定在每种情况下都需要。</p>
<h1 id="VueX——Vue的状态管理模式"><a href="#VueX——Vue的状态管理模式" class="headerlink" title="VueX——Vue的状态管理模式"></a>VueX——Vue的状态管理模式</h1><p>如果有多个组件需要访问同一个状态，问题会变得复杂。如果数据是应用中多个组件共享的，那么数据应该提取出来集中管理，而不是放到某个组件中。所以这就提出了使用库或者是一个模式的必要性。</p>
<p>VueX的本质就是Vue的生态系统，当然，历经多次迭代，处理基础概念，他还带来了其他工具，例如模块系统，插件系统。</p>
<h1 id="Props传递"><a href="#Props传递" class="headerlink" title="Props传递"></a>Props传递</h1><p>最基本的状态管理，将数据和视图分离，counter本身只负责接受一些属性和渲染它。这些实例都有共同的父组件。在很多情况下，最坏的情况下你可能需要管理所有状态。在根节点中，并通过Props传递下去。当组件树结构越来越大，这样的弊端会逐渐显现出来，就是需要手动地将props一层层传递下去。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">&quot;count&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// requirement: a counter component rendered 3 times</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// the component takes the current count via props</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// and a button that increments all 3 counters at once</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//状态</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">Counter</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">count</span>: <span class="built_in">Number</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//视图</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>我们可以将一个对象独立出来作为共享对象作为我们的状态，这样就避免了参数在组件中的传递。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// create a counter component (that doesn&#x27;t take any props)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// all instances of it should share the same count state</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// and a button that increments all counters at the same time</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//定义一个独立状态</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> state = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Counter = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// Convert state into reactive object</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//用data返回这个状态，这样Vue就可以给他加上响应式</span></span></span><br><span class="line"><span class="javascript">  data () &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> state</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">//渲染函数</span></span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// Proxy the object</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.count)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//注册组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Counter</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      state.count++</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="共享实例"><a href="#共享实例" class="headerlink" title="共享实例"></a>共享实例</h1><p>上一个思路是共享对象，那么我们能不能更近一步，使用实例进行状态共享。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// copy and modify the first exercise to use a Vue instance as</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// a shared store instead.</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//把数据和方法直接在vue中定义，这样他们就会带上响应式</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> state = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.count++</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//渲染组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Counter = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, state.count)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//注册组件和方法</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    Counter</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//这里有点绕，用这个函数包装state的函数，使得数据交换被隐藏了起来,会更为安全</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      state.inc()</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h1><p>在上一个例子中我们成功将实例抽象出来进行共享。那么使用Vue实例去封装一些使用方法，最后导出不同的API又该怎么实现呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;inc&quot;</span>&gt;</span>increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//定义一个函数，它返回Vue实例</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">&#123; state, mutations &#125;</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//使其具有响应性</span></span></span><br><span class="line"><span class="javascript">      state</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      commit (mutation) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!mutations.hasOwnProperty(mutation)) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown mutation&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">		<span class="comment">//解构mutations获取内部所有方法，给他们赋予状态</span></span></span><br><span class="line"><span class="javascript">        mutations[mutation](state)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> store = createStore(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">mutations</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc (state) &#123;</span></span><br><span class="line"><span class="javascript">      state.count++</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Counter = &#123;</span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, store.state.count)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123; Counter &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    inc () &#123;</span></span><br><span class="line"><span class="javascript">      store.commit(<span class="string">&#x27;inc&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="最后一步，模拟VueX"><a href="#最后一步，模拟VueX" class="headerlink" title="最后一步，模拟VueX"></a>最后一步，模拟VueX</h1><p>当完成了前面的练习时，模拟VueX已经呼之欲出了，通过封装一个app函数，在函数内实现挂载节点，共享状态，视图和数据。之后只需要调用这个函数，传入必要参数就可以模拟VueX的行为了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//Vuex简单模拟</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//el:Vue实例挂载的元素节点，model共享的数据，view视图，action动作函数</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">app</span> (<span class="params">&#123; el, model, view, actions &#125;</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> wrappedActions = &#123;&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//给动作函数中的所有函数传入实例的响应式数据，直接传入函数的话，函数内部的值将不具有响应式</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> originalAction = actions[key]</span></span><br><span class="line"><span class="javascript">    wrappedActions[key] = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      vm.model = originalAction(vm.model)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建vue实例对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//挂载节点</span></span></span><br><span class="line"><span class="javascript">    el,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//数据</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//给它带上响应式</span></span></span><br><span class="line"><span class="javascript">      model</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//渲染函数（视图）</span></span></span><br><span class="line"><span class="javascript">    render (h) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> view(h, <span class="built_in">this</span>.model, wrappedActions)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//动作函数</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: actions</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// voila</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//这里就可以进行类似Vue创建实例的方法了</span></span></span><br><span class="line"><span class="javascript">app(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">model</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">actions</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">inc</span>: <span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> (&#123; <span class="attr">count</span>: count + <span class="number">1</span> &#125;),</span></span><br><span class="line"><span class="javascript">    <span class="attr">dec</span>: <span class="function">(<span class="params">&#123; count &#125;</span>) =&gt;</span> (&#123; <span class="attr">count</span>: count - <span class="number">1</span> &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">view</span>: <span class="function">(<span class="params">h, model, actions</span>) =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;&#125;, [</span></span><br><span class="line"><span class="javascript">    model.count, <span class="string">&#x27; &#x27;</span>,</span></span><br><span class="line"><span class="javascript">    h(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: actions.inc &#125;&#125;, <span class="string">&#x27;+&#x27;</span>),</span></span><br><span class="line"><span class="javascript">    h(<span class="string">&#x27;button&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: actions.dec &#125;&#125;, <span class="string">&#x27;-&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  ])</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上面的这些例子只是非常简单的vue实例，只是为了演示VueX的实现方式。事实上VueX具有更多的功能。例如VueX有action，getter，模块等概念。当然VueX的核心仍然是基于Vue实例实现响应性。</p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期</title>
    <url>/2022/03/21/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Vue2生命周期"><a href="#Vue2生命周期" class="headerlink" title="Vue2生命周期"></a>Vue2生命周期</h1><p>每个Vue的实例创建的时候都有一系列的阶段，比如创建Vue实例，数据装载，渲染DOM数，渲染CSS等等，这些不同阶段就被成为Vue的生命周期。理解生命周期的概念和各个生命周期钩子的作用有助于对Vue项目的提升。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/11370083-f279314aef6741db.webp" alt="11370083-f279314aef6741db"></p>
<p>这是大佬博客的图，很直观的展示了Vue生命周期和生命周期钩子的作用。</p>
<ol>
<li><p>beforeCreate（创建前）</p>
<p>这个时候Vue对象刚刚创建，没有DOM和数据</p>
</li>
<li><p>created（已创建）</p>
<p>这个时候已经开始监控Data数据变化，这个时候就<strong>可以获取到Data的内容了</strong></p>
</li>
<li><p>beforeMount</p>
<p>这个阶段编译了虚拟DOM树，真实DOM树还没有渲染到页面上</p>
</li>
<li><p>mounted</p>
<p>这个阶段已经将虚拟DOM编译为真实DOM，此时一般可以进行一些ajax操作，mouted只会执行一次</p>
</li>
<li><p>beforeUpdate</p>
<p>这是响应式更新前的钩子，可以在虚拟DOM的基础上再次修改DOM</p>
</li>
<li><p>updated</p>
<p>这是响应式更新后的钩子，此时真实DOM已经更新完毕，最好不要在这里才再次修改DOM</p>
</li>
<li><p>beforeDestroy</p>
<p>实例销毁前的钩子，实例任然完全可用</p>
</li>
<li><p>destroyed</p>
<p>实例已经销毁</p>
</li>
</ol>
<p>问题一：Vue从创建到挂载这段时间内究竟发生了什么？</p>
<p>从生命周期的角度去看：</p>
<p>创建到挂载这段时间内发生的是beforeCreate、created、beforeMount、mounted</p>
<p>那么发生了什么就很清晰了，发生了数据响应式更新的监控，同时获取了虚拟DOM并渲染了真实DOM到浏览器上。</p>
<p>从源码的角度去看：</p>
<ul>
<li><p>vue本质上是一个构造函数，执行new Vue()的时候，会通过它的构造函数执行很多函数，本质上就是为了给vue的prototype扩展一些方法，调用this._init。</p>
</li>
<li><p>this._init干了什么</p>
<ul>
<li><p>给每一个vue实例写一个唯一的uid</p>
</li>
<li><p>合并options</p>
</li>
<li><p>执行一堆initXXX的函数</p>
<p>看源码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在原型上添加 _init 方法</span></span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前实例</span></span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 合并配置</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// 把子组件依赖父组件的 props、listeners 挂载到 options 上，并指定组件的$options</span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 把我们传进来的 options 和当前构造函数和父级的 options 进行合并，并挂载到原型上</span></span><br><span class="line">      vm.$options = mergeOptions(</span><br><span class="line">        resolveConstructorOptions(vm.constructor),</span><br><span class="line">        options || &#123;&#125;,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm) <span class="comment">// 初始化实例的属性、数据：$parent, $children, $refs, $root, _watcher...等</span></span><br><span class="line">    initEvents(vm) <span class="comment">// 初始化事件：$on, $off, $emit, $once</span></span><br><span class="line">    initRender(vm) <span class="comment">// 初始化渲染： render, mixin</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>) <span class="comment">// 调用生命周期钩子函数</span></span><br><span class="line">    initInjections(vm) <span class="comment">// 初始化 inject</span></span><br><span class="line">    initState(vm) <span class="comment">// 初始化组件数据：props, data, methods, watch, computed</span></span><br><span class="line">    initProvide(vm) <span class="comment">// 初始化 provide</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>) <span class="comment">// 调用生命周期钩子函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      <span class="comment">// 如果传了 el 就会调用 $mount 进入模板编译和挂载阶段</span></span><br><span class="line">      <span class="comment">// 如果没有传就需要手动执行 $mount 才会进入下一阶段</span></span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>执行vm.$mount,调用mountComponent，创建updateComponent</p>
</li>
<li><p>执行_render,获取虚拟DOM</p>
</li>
<li><p>执行_update,将虚拟DOM转化为真实DOM</p>
</li>
</ul>
<p>参考博客：<a href="https://www.jianshu.com/p/672e967e201c">https://www.jianshu.com/p/672e967e201c</a></p>
<p>​                    <a href="https://blog.csdn.net/a151681931/article/details/120704697">https://blog.csdn.net/a151681931/article/details/120704697</a></p>
<h1 id="Vue3生命周期"><a href="#Vue3生命周期" class="headerlink" title="Vue3生命周期"></a>Vue3生命周期</h1><p>Vue3的生命周期与Vue2的生命周期有一些更新，但是总体区别不大。vue3中新增了三个用于调试和服务端渲染场景。</p>
<table>
<thead>
<tr>
<th>生命周期v2</th>
<th>生命周期v3</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>beforeCreate</td>
<td>组件实例被创建之初</td>
</tr>
<tr>
<td>created</td>
<td>created</td>
<td>组件实例已经完全创建</td>
</tr>
<tr>
<td>beforeMount</td>
<td>beforeMount</td>
<td>组件挂载之前</td>
</tr>
<tr>
<td>mounted</td>
<td>mounted</td>
<td>组件挂载到实例上去之后</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>beforeUpdate</td>
<td>组件数据发生变化，更新之前</td>
</tr>
<tr>
<td>updated</td>
<td>updated</td>
<td>数据数据更新之后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td><strong>beforeUnmounted</strong></td>
<td>组件实例销毁之前</td>
</tr>
<tr>
<td>destroyed</td>
<td><strong>unmounted</strong></td>
<td>组件实例销毁之后</td>
</tr>
<tr>
<td>activated</td>
<td>activated</td>
<td>keep-alive 缓存的组件激活时</td>
</tr>
<tr>
<td>deactivated</td>
<td>deactivated</td>
<td>keep-alive 缓存的组件停用时调用</td>
</tr>
<tr>
<td>errorCaptured</td>
<td>errorCaptured</td>
<td>捕获一个来自子孙组件的错误时被调用</td>
</tr>
<tr>
<td>-</td>
<td><strong>renderTracked</strong></td>
<td>调试钩子，响应式依赖被收集时调用</td>
</tr>
<tr>
<td>-</td>
<td><strong>renderTriggered</strong></td>
<td>调试钩子，响应式依赖被触发时调用</td>
</tr>
<tr>
<td>-</td>
<td><strong>serverPrefetch</strong></td>
<td>ssr only，组件实例在服务器上被渲染前调用</td>
</tr>
</tbody></table>
<h2 id="Vue3生命周期图示"><a href="#Vue3生命周期图示" class="headerlink" title="Vue3生命周期图示"></a>Vue3生命周期图示</h2><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f6c6966656379636c652e63656331316463632e706e67.png" alt="68747470733a2f2f67697465652e636f6d2f3537636f64652f706963676f2f7261772f6d61737465722f6c6966656379636c652e63656331316463632e706e67"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于前端开发来说，Vue3生命周期的时间节点没什么变化，该用还是一样用，但是记得在setup中使用生命周期钩子时候要记得使用<code>onMounted</code>这种加上on的方式调用生命周期。</p>
<h2 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h2><h4 id="setup中有created钩子吗"><a href="#setup中有created钩子吗" class="headerlink" title="setup中有created钩子吗"></a>setup中有created钩子吗</h4><p>没有，因为setup比created更早执行，所以直接在setup中定义的方法对于开发者来说时间节点是一样的，因此没有必要再setup中提供created钩子</p>
]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM与Diff算法</title>
    <url>/2022/04/21/Vue%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="虚拟DOM与DIff算法"><a href="#虚拟DOM与DIff算法" class="headerlink" title="虚拟DOM与DIff算法"></a>虚拟DOM与DIff算法</h1><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>在Vue中虚拟DOM是一个重要的概念，是作为Vue响应式与真实DOM之间的‘桥梁’</p>
<h3 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h3><p>虚拟DOM的本质就是一个对象，用以描述视图的界面结构。在Vue中，每个组件都有一个render函数，每个render函数都会返回一个虚拟DOM树，这也就意味着每个组件都有一个对应的虚拟DOM树</p>
<h3 id="为什么要虚拟DOM"><a href="#为什么要虚拟DOM" class="headerlink" title="为什么要虚拟DOM"></a>为什么要虚拟DOM</h3><p>Vue的核心在于响应式，为了实现响应式，就必须要频繁地根据用户的操作去增删改真实DOM，但是频繁的对真实DOM修改会极大的影响性能，因此，我们先用比真实DOM轻量得多的虚拟DOM去获取用户的操作，再使用Diff算法实现对真实DOM的最小量更新，从而节约性能。</p>
<h3 id="虚拟dom是如何转换为真实dom的？"><a href="#虚拟dom是如何转换为真实dom的？" class="headerlink" title="虚拟dom是如何转换为真实dom的？"></a>虚拟dom是如何转换为真实dom的？</h3><p>在一个组件实例首次被渲染时，它先生成虚拟dom树，然后根据虚拟dom树创建真实dom，并把真实dom挂载到页面中合适的位置，此时，每个虚拟dom便会对应一个真实的dom。</p>
<p>如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一个新的虚拟dom树，用新树和旧树对比，通过对比，vue会找到最小更新量，然后更新必要的真实dom节点</p>
<p>这样一来，就保证了对真实dom达到最小的改动。</p>
<h2 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h2><p>diff算法是一个对比算法，用以实现最小量更新，在Vue中，这个算法被包括在patch函数中，而patch函数正是对比前后两个节点的最小量更新函数。</p>
<h3 id="patch流程图"><a href="#patch流程图" class="headerlink" title="patch流程图"></a>patch流程图</h3><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/patch%E6%B5%81%E7%A8%8B.png" alt="patch流程"></p>
<h3 id="实现核心代码"><a href="#实现核心代码" class="headerlink" title="实现核心代码"></a>实现核心代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> patchVnode <span class="keyword">from</span> <span class="string">&quot;./patchVnode.js&quot;</span></span><br><span class="line"><span class="keyword">import</span> createElement <span class="keyword">from</span> <span class="string">&quot;./createElement.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;新旧节点都有子节点&#x27;</span>)</span><br><span class="line">    <span class="comment">//旧前</span></span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="comment">//新前</span></span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="comment">//旧后</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">//新后</span></span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">//旧前节点</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//旧后节点</span></span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="comment">//新前节点</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//新后节点</span></span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> keyMap = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当四个节点没有错位，循环就要继续</span></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="comment">//如果当前的节点已经被标记了，说明不用再进行处理了</span></span><br><span class="line">        <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span> || oldCh[oldStartIdx] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span> || oldCh[oldEndIdx] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span> || newCh[newStartIdx] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span> || newCh[newEndIdx] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkSameVNode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">//新前和旧前比  </span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;1.新前和旧前命中&#x27;</span>)</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkSameVNode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            <span class="comment">//新后和旧后比</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;2.新后和旧后命中&#x27;</span>)</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkSameVNode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            <span class="comment">//新后和旧前比</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;3.新后和旧前命中&#x27;</span>)</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">            <span class="comment">//当3.新后与旧前命中的时候，此时要移动节点。</span></span><br><span class="line">            <span class="comment">//移动新前指向的这个节点到老节点的旧后的后面</span></span><br><span class="line">            parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkSameVNode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">//新后和旧前比</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;4.新前和旧后命中&#x27;</span>)</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">            <span class="comment">//当4.新后和旧前命中的时候，此时要移动节点。</span></span><br><span class="line">            <span class="comment">//移动新前指向的这个节点到老节点的旧前的前面</span></span><br><span class="line">            parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//四种命中都没有命中</span></span><br><span class="line">            <span class="comment">//寻找key的map</span></span><br><span class="line">            <span class="keyword">if</span> (!keyMap) &#123;</span><br><span class="line">                keyMap = &#123;&#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt; oldEndIdx; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> key = oldCh[i].key</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        keyMap[key] = i</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(keyMap)</span><br><span class="line">            <span class="comment">//寻找当前项在keyMap中的映射位置序号</span></span><br><span class="line">            <span class="keyword">const</span> idxInOld = keyMap[newStartVnode.key]</span><br><span class="line">            <span class="built_in">console</span>.log(idxInOld)</span><br><span class="line">            <span class="keyword">if</span> (idxInOld == <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">//如果找不到这一个虚拟DOM说明它是全新的</span></span><br><span class="line">                <span class="comment">//被加入的项（就是newStartVnode这个项）现在只是虚拟DOM</span></span><br><span class="line">                parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//找得到这个虚拟DOM就说明他不是全新的，而是要移动位置</span></span><br><span class="line">                <span class="keyword">const</span> elmToMove = oldCh[idxInOld]</span><br><span class="line">                patchVnode(elmToMove, newStartVnode)</span><br><span class="line">                <span class="comment">//把这一项标记为undefined,表示我已经处理完这一项了</span></span><br><span class="line">                oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">                parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针下移，只移动新的头</span></span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看是否有剩余的节点</span></span><br><span class="line">    <span class="keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;还有剩余节点待添加&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">            <span class="comment">//insertBefore方法可以自动识别null，如果null就会自动拍到队尾去。和appendChild是一致的了。</span></span><br><span class="line">            <span class="comment">//newCh[i]现在还没有真正的DOM，所以要调用createElement()函数变为DOM</span></span><br><span class="line">            parentElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;old还有剩余节点没有删除&#x27;</span>)</span><br><span class="line">        <span class="comment">//批量删除oldStart和oldEnd指针之间的项</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCh[i]) &#123;</span><br><span class="line">                parentElm.removeChild(oldCh[i].elm)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkSameVNode</span>(<span class="params">nodeA, nodeB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nodeA.sel === nodeB.sel &amp;&amp; nodeA.key === nodeB.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习笔记06</title>
    <url>/2021/12/08/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B006%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>vue-router是Vue框架的另一个强大工具。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
<h1 id="哈希路由"><a href="#哈希路由" class="headerlink" title="哈希路由"></a>哈希路由</h1><p>单页应用路由，我们有一些url，想把他们映射到组件。即使组件和这些url有一一对应的关系，并能够实现跳转。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;routeTo(&#x27;#foo&#x27;)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;routeTo(&#x27;#bar&#x27;)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="comment">//一个基于哈希的路由解决方案</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">		浏览器有两种方式进行路由，可以使用哈希，也可以使用HTML5 History API。</span></span></span><br><span class="line"><span class="comment"><span class="javascript">		从某种意义上说，Html5 History APi更好，它支持弹出状态，你的URL看起来会更好，但是他需要某种服务器配置</span></span></span><br><span class="line"><span class="comment"><span class="javascript">		为了更方便的展示，这里使用哈希方式访问。</span></span></span><br><span class="line"><span class="comment"><span class="javascript">	*/</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">url</span>: <span class="string">&#x27;foo&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">foo</span>: &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo&lt;/div&gt;`</span>&#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">bar</span>: &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span>&#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    routeTo (route) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.location.hash = route</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h1><p>完成了基础路由跳转的实现，那么我们能不能把基础路由和组件的对应关系维护起来，形成一张表，这样当我们需要跳转的时候查询路由表再跳转对应组件就好了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;matchedComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/foo&#x27; -&gt; Foo</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/bar&#x27; -&gt; Bar</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/404&#x27; -&gt; NotFound</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Foo = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//路由表，维护组件和路径的对应关系</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> routeTable = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">foo</span>: Foo,</span></span><br><span class="line"><span class="javascript">  <span class="attr">bar</span>: Bar</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">url</span>: <span class="string">&#x27;foo&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">//两种视图实现方式,render渲染函数和html模板</span></span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">	  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span></span><br><span class="line"><span class="javascript">		  h(routeTable[<span class="built_in">this</span>.url] || NotFound),</span></span><br><span class="line"><span class="javascript">		  h(<span class="string">&#x27;a&#x27;</span>,&#123; <span class="attr">attrs</span>:&#123; <span class="attr">href</span>:<span class="string">&#x27;#foo&#x27;</span>&#125;&#125;, <span class="string">&#x27;foo&#x27;</span>),</span></span><br><span class="line"><span class="javascript">		  <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">		  h(<span class="string">&#x27;a&#x27;</span>,&#123; <span class="attr">attrs</span>:&#123; <span class="attr">href</span>:<span class="string">&#x27;#bar&#x27;</span>&#125;&#125;, <span class="string">&#x27;bar&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	  ])</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// computed: &#123;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//   matchedComponent () &#123;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//     return routeTable[this.url] || NotFound</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="正则匹配动态路由"><a href="#正则匹配动态路由" class="headerlink" title="正则匹配动态路由"></a>正则匹配动态路由</h2><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>使用path-to-regexp工具库中的pathToRegexp函数处理url中的地址和参数</p>
<h3 id="动态路由的匹配"><a href="#动态路由的匹配" class="headerlink" title="动态路由的匹配"></a>动态路由的匹配</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/foo/123&#x27; -&gt; foo with id: 123</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/bar&#x27; -&gt; Bar</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// &#x27;#/404&#x27; -&gt; NotFound</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// path-to-regexp usage:</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// const regex = pathToRegexp(pattern)</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// const match = regex.exec(path)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//根据路由展现的组件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Foo = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">props</span>: [<span class="string">&#x27;id&#x27;</span>],</span></span><br><span class="line"><span class="javascript">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;foo with id: &#123;&#123; id &#125;&#125;&lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> Bar = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;bar&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> NotFound = &#123; <span class="attr">template</span>: <span class="string">`&lt;div&gt;not found!&lt;/div&gt;`</span> &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//正则捕获的路由表</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> routeTable = &#123;</span></span><br><span class="line"><span class="javascript">  <span class="string">&#x27;/foo/:id&#x27;</span>: Foo,</span></span><br><span class="line"><span class="javascript">  <span class="string">&#x27;/bar&#x27;</span>: Bar</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//编译完成后的数组，就是经过正则匹配后的数组</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> compiledRoutes = []</span></span><br><span class="line"><span class="javascript"><span class="comment">//取出路由表中的所有匹配规则</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">Object</span>.keys(routeTable).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> dynamicSegments = []</span></span><br><span class="line"><span class="javascript">  <span class="comment">//工具库函数pathToRegexp，用于处理url中的地址和参数</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> regex = pathToRegexp(key, dynamicSegments)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> component = routeTable[key]</span></span><br><span class="line"><span class="javascript">  compiledRoutes.push(&#123;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//对应规则映射组件</span></span></span><br><span class="line"><span class="javascript">    component,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//匹配规则</span></span></span><br><span class="line"><span class="javascript">    regex,</span></span><br><span class="line"><span class="javascript">	<span class="comment">//解析动态匹配部分</span></span></span><br><span class="line"><span class="javascript">    dynamicSegments</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">  app.url = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">url</span>: <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  render (h) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> path = <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.url</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> componentToRender</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> props = &#123;&#125;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//检查是否有匹配上的路由</span></span></span><br><span class="line"><span class="javascript">    compiledRoutes.some(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> match = route.regex.exec(path)</span></span><br><span class="line"><span class="javascript">      componentToRender = NotFound</span></span><br><span class="line"><span class="javascript">	  <span class="comment">//判断匹配是否成功</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (match) &#123;</span></span><br><span class="line"><span class="javascript">        componentToRender = route.component</span></span><br><span class="line"><span class="javascript">        route.dynamicSegments.forEach(<span class="function">(<span class="params">segment, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          props[segment.name] = match[index + <span class="number">1</span>]</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span></span><br><span class="line"><span class="javascript">      h(componentToRender, &#123; props &#125;),</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/123&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 123&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#foo/234&#x27;</span> &#125;&#125;, <span class="string">&#x27;foo 234&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#bar&#x27;</span> &#125;&#125;, <span class="string">&#x27;bar&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27; | &#x27;</span>,</span></span><br><span class="line"><span class="javascript">      h(<span class="string">&#x27;a&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">href</span>: <span class="string">&#x27;#garbage&#x27;</span> &#125;&#125;, <span class="string">&#x27;garbage&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    ])</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue源码</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习笔记03打包文件探秘</title>
    <url>/2022/05/07/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<h1 id="Webpack打包文件"><a href="#Webpack打包文件" class="headerlink" title="Webpack打包文件"></a>Webpack打包文件</h1><p>在webpack中打包文件的原理是从一个入口文件开始，将整个散落的js，html，css等文件整合打包到几个文件中去，而这个打包规则就是webpack的配置项。我们可以在webpack打包过后的文件中窥见webpack的打包机制和原理。</p>
<p>首先我们将webpack配置文件设置打包模式为<code>none</code>这可以令webpack以最原始的打包方式进行打包，对于想要研究webpack打包产物的开发者比较友好。</p>
<p>然后我们就可以愉快的阅读打包后的文件啦！</p>
<p>这里以webpack<code>5.72.0</code>打包文件为例</p>
<ol>
<li><p>先看整体</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220507104634099.png" alt="image-20220507104634099"></p>
<p>这是一个立即执行函数，内部包含了所有我们的业务逻辑</p>
</li>
<li><p>拆开看</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220507105447450.png" alt="image-20220507105447450"></p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面试专题01</title>
    <url>/2022/05/10/Vue%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%9801/</url>
    <content><![CDATA[<h1 id="Vue面试专题"><a href="#Vue面试专题" class="headerlink" title="Vue面试专题"></a>Vue面试专题</h1><h2 id="1-组件间通信的方式有哪些？"><a href="#1-组件间通信的方式有哪些？" class="headerlink" title="1.组件间通信的方式有哪些？"></a>1.组件间通信的方式有哪些？</h2><ol>
<li>大致有以下8中<ul>
<li>props</li>
<li>$emit/<del>$on</del></li>
<li><del>$children</del>/$parent</li>
<li>provide/inject</li>
<li>$root</li>
<li>ref</li>
<li>eventbus(不推荐，因为$on被废弃了)</li>
<li>vuex</li>
</ul>
</li>
</ol>
<p>父子：$emit，props，ref，provide，$parent</p>
<p>兄弟：Vuex,$parents（中间人）</p>
<p>任意：Vuex，eventBus，provide（不推荐）</p>
<h2 id="2-v-if和v-for优先级？"><a href="#2-v-if和v-for优先级？" class="headerlink" title="2.v-if和v-for优先级？"></a>2.v-if和v-for优先级？</h2><ul>
<li>从实际上说：不要把<code>v-if</code>和<code>v-if</code>写在一起，因为</li>
<li>vue2中<code>v-for</code>优先级高于<code>v-if</code>，它的执行逻辑是先将列表渲染出来，然后在逐项比较是否删除，这样比较浪费资源。</li>
<li>vue3中<code>v-if</code>优先级高于<code>v-for</code>，它的执行逻辑是先在虚拟dom中判断是否删除，然后再<code>v-for</code>，如果再使用vue2的写法会报错。</li>
<li>vue3解决办法，在需要判断遍历的属性上使用<code>computed</code>计算属性</li>
</ul>
<h2 id="3-v-model作用以及原理"><a href="#3-v-model作用以及原理" class="headerlink" title="3.v-model作用以及原理"></a>3.v-model作用以及原理</h2><ul>
<li>v-model的作用是提供数据的双向绑定，可以绑定一个动态值到视图，当动态值更新的时候视图也会更新。是一个语法糖，默认情况下相当于:value和@input。</li>
<li>v-model起作用的原理是从模板编译开始的，vue将v-model解析出来之后，就为数据绑定上一个事件监听，在数据的属性发生改变的时候，执行对应的依赖跟踪作用。这说明v-model在编译完成的时候就已经具备这个功能了。</li>
<li>通常在表单项中使用v-model，当然，在不同类型的表单中v-model输出的渲染函数是不同的。</li>
</ul>
<h2 id="4-子组件能直接修改父组件的数据吗"><a href="#4-子组件能直接修改父组件的数据吗" class="headerlink" title="4.子组件能直接修改父组件的数据吗"></a>4.子组件能直接修改父组件的数据吗</h2><ol>
<li>理论上可以，但是不建议这么做，因为编程中有一个单向数据流规则，选择直接修改父组件数据会让程序变得过于复杂。</li>
<li>在实践中如果我们直接修改props会被警告。解决方案：将props克隆一份作为本地数据进行修改，不直接使用props进行修改。</li>
<li> 如果想要改变父组件数据可以使用emit等方式间接修改父组件状态。</li>
</ol>
<h2 id="5-路由权限管理的实现和精确控制"><a href="#5-路由权限管理的实现和精确控制" class="headerlink" title="5.路由权限管理的实现和精确控制"></a>5.路由权限管理的实现和精确控制</h2><ol>
<li>前端方案：设置路由守卫，当用户试图访问网页的时候判断用户身份，分配路由表。具体实现可见vue-admin</li>
<li>后端方案：将所有页面路由信息存在数据库中，用户登录的时候根据其角色查询</li>
</ol>
<h2 id="6-响应式的理解"><a href="#6-响应式的理解" class="headerlink" title="6.响应式的理解"></a>6.响应式的理解</h2><ol>
<li><p>响应式就是数据发生变化的时候能够获取变化并做出响应的机制。</p>
</li>
<li><p>每个MVVM框架都要解决的问题就是数据层和视图层的统一。</p>
</li>
<li><p>在vue中响应式加上虚拟DOM和patch（diff算法）就可以实现基础的响应式了。</p>
</li>
<li><p>在vue2中：响应式原理是通过一个<code>Object.defineProperty</code>的APi去实现给每一个对象元素添加getter&amp;&amp;setter，还有通过依赖跟踪实现的响应式。对于数组则是覆盖了其中的一些会添加元素的方法实现动态更新。当然这也是有缺点的，因为不支持es6最新的数据结构Map、Set等，在性能上也有损失，在做数据响应式的时候需要循环递归遍历。</p>
<p>在vue3中：响应式原理是通过一个ES6的Pxory代理实现的，proxy更像是一个拦截器，不管对于那种数据类型，编程体验是一致的。初始化性能和内存消耗都得到了大幅度的改善。</p>
</li>
</ol>
<h2 id="7-如何实现一个router"><a href="#7-如何实现一个router" class="headerlink" title="7.如何实现一个router"></a>7.如何实现一个router</h2><h2 id="8-vue中的-nextTick的作用？"><a href="#8-vue中的-nextTick的作用？" class="headerlink" title="8.vue中的$nextTick的作用？"></a>8.vue中的$nextTick的作用？</h2><ul>
<li>vue中的nextTick是一个用于在下此DOM更新后的工具方法</li>
<li>举例来说，我们如果在vue中更新了DOM的内容，vue是不能立刻获取到更新后DOM的内容的。这是与vue的更新策略有关。在Vue所有与DOM有关的操作不会立即更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生所有数据变更会异步的批量更新。这个策略确实优化了dom的操作次数，对资源要求更低，但同时也使得我们无法立刻获取更新后的DOM状态。</li>
<li>$nextTick会将你的回调放到一个promise.then中（微任务，等待DOM更新完成之后再调用里面的回调函数，这样就能够异步地看到最新的DOM值了）</li>
</ul>
<h3 id="9-扩展组件方法"><a href="#9-扩展组件方法" class="headerlink" title="9.扩展组件方法"></a>9.扩展组件方法</h3><p>按照逻辑扩展和内容扩展来划分</p>
<p>逻辑扩展：mixin、extend、composition api</p>
<p>内容扩展：slots</p>
<ol>
<li><p>slots是一种组件插槽，用于直接在模板中插入其他组件的内容</p>
<p>子组件Child</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;slot&gt;这个内容会被父组件传递的内容替换&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>父组件Parent</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;Child&gt;来自老爹的内容&lt;/Child&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果需要精确分发可以使用具名slot</p>
</li>
<li><p>mixin是一种比较强大的组件扩展手段</p>
<ul>
<li><p>在Vue2中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复用代码：它是一个配置对象，选项和组件里面一样</span></span><br><span class="line"><span class="keyword">const</span> mymixin = &#123;</span><br><span class="line">	<span class="attr">methods</span>: &#123;</span><br><span class="line">		<span class="function"><span class="title">dosomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局混入：将混入对象传入</span></span><br><span class="line">Vue.mixin(mymixin)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部混入：做数组项设置到mixins选项，仅作用于当前组件</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">	<span class="attr">mixins</span>: [mymixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Vue3中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义组件扩展内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> composition = &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> count = ref(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">const</span> adder = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(count.value++)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            adder,</span><br><span class="line">            count,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; composition &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/mixin&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取混入</span></span><br><span class="line">    <span class="keyword">const</span> &#123; adder &#125; = composition.setup();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      adder,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>composition api是Vue3中新引入的组件扩展方式，可以利用独立出来的响应式模块组合使用逻辑（推荐）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复用逻辑1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useXX</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 复用逻辑2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useYY</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 逻辑组合</span></span><br><span class="line"><span class="keyword">const</span> Comp = &#123;</span><br><span class="line">	<span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> &#123;xx&#125; = useXX()</span><br><span class="line">		<span class="keyword">const</span> &#123;yy&#125; = useYY()</span><br><span class="line">		<span class="keyword">return</span> &#123;xx, yy&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Vue面试</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习笔记04loader和plugin</title>
    <url>/2022/05/13/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004loader%E5%92%8Cplugin/</url>
    <content><![CDATA[<h1 id="Loader和Plugin"><a href="#Loader和Plugin" class="headerlink" title="Loader和Plugin"></a>Loader和Plugin</h1><p>在<code>webpack</code>中有两个重要的概念，<code>loader</code>和<code>Plugin</code>,这两个概念有点类似但实际上并不一样。</p>
<h2 id="Loader是什么"><a href="#Loader是什么" class="headerlink" title="Loader是什么"></a>Loader是什么</h2><p><code>loader</code>是一个用于让<code>webpack</code>处理非JavaScript的文件（<code>webpack</code>本身只能理解<code>JavaScript</code>）。<code>loader</code>可以将所有类型的文件转换为<code>webpack</code>能够处理的有效模块。</p>
<p>因为<code>webpack</code>本身是由<code>JavaScript</code>编写的，并且只能识别js结尾的模块，<code>loader</code>就相当于一个翻译官，将其他类型的文件翻译成<code>webpack</code>能够识别的模块。</p>
<h2 id="Plugin是什么"><a href="#Plugin是什么" class="headerlink" title="Plugin是什么"></a>Plugin是什么</h2><p><code>plugin</code>是插件的意思，它是<code>webpack</code>支柱功能，其目的在于解决<code>loader</code>无法实现的其他功能。</p>
<p>我们注入<code>plugin</code>之后，会在<code>webpack</code>后续构建的某个时间节点上触发<code>plugin</code>定义的功能。就像是Vue中的生命周期一样，我们注入的<code>plugin</code>会被视为生命周期中某个钩子（视你使用的插件而定）的方法，当<code>webpack</code>打包程序到这个节点的时候，就会执行函数。</p>
<h2 id="Loader和Plugin的区别是什么"><a href="#Loader和Plugin的区别是什么" class="headerlink" title="Loader和Plugin的区别是什么"></a>Loader和Plugin的区别是什么</h2><ul>
<li>loader是专门处理文件转换的一个模块，比起plugin来说没有那么广泛；而plugin不止可以进行法宝，还可以优化打包和压缩，重新定义环境变量等。</li>
<li>loader运行在打包文件之前(loader为在模块加载时的预处理文件)；plugins在整个编译的周期都起作用。</li>
<li>在webpack运行的生命周期中会广播出许多事件，plugin会监听这些事件，在合适的时机通过webpack提供的API改变输出结果</li>
</ul>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack底层原理手写</title>
    <url>/2022/05/14/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%89%8B%E5%86%99/</url>
    <content><![CDATA[<h1 id="Webpack底层原理手写"><a href="#Webpack底层原理手写" class="headerlink" title="Webpack底层原理手写"></a>Webpack底层原理手写</h1><p><code>webpack</code>是时下最受欢迎的前端打包工具之一。前端需要打包的原因在于现代浏览器不支持<code>CommonJS</code>的导入，也就是不支持<code>require()</code>和<code>export</code>。为此我们再运行前端项目的时候需要有一个服务器，并且将<code>nodejs</code>中以<code>CommonJS</code>格式书写的<code>js</code>代码进行编译打包，转移成浏览器能够理解的<code>ES Module</code>语法。</p>
<h2 id="Part1-原型和boundle"><a href="#Part1-原型和boundle" class="headerlink" title="Part1.原型和boundle"></a>Part1.原型和boundle</h2><p>在整个<code>webpack</code>运行中，最先要做的就是编译，也就是将代码翻译成浏览器能够认识的代码。</p>
<ol>
<li>从入口开始解析整个项目，去收集依赖。</li>
<li>将ES6语法通过<code>babel</code>转成ES5语法（现在已经不需要了，浏览器已经支持ES6）。</li>
<li>替换require与exports，因为浏览器不支持这些语法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack原理</span></span><br><span class="line"><span class="comment">//建立自运行函数，保证变量不外泄</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//由于es Module没有exports这个方法函数，最简单的方法就是创建一个</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, code</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">eval</span>(code)</span><br><span class="line">        &#125;)(<span class="built_in">exports</span>, list[file])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exports</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从入口开始解析</span></span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&quot;index.js&quot;</span>)</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">    <span class="comment">//1.从入口开始解析整个项目，收集依赖</span></span><br><span class="line">    <span class="comment">//2.ES6转ES5(bable)</span></span><br><span class="line">    <span class="comment">//3.替换require与exports，因为不支持commentJS，没有这些方法</span></span><br><span class="line">    <span class="string">&#x27;index.js&#x27;</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            var add = require(&#x27;add.js&#x27;).default</span></span><br><span class="line"><span class="string">            console.log(add(1, 2))</span></span><br><span class="line"><span class="string">        `</span>,</span><br><span class="line">    <span class="string">&#x27;add.js&#x27;</span>: <span class="string">`</span></span><br><span class="line"><span class="string">            exports.default = function (a, b) &#123;</span></span><br><span class="line"><span class="string">                return a + b</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Part2-AST与模块分析"><a href="#Part2-AST与模块分析" class="headerlink" title="Part2.AST与模块分析"></a>Part2.AST与模块分析</h2><p>在<code>webpack</code>编译过程中，会遇到两个问题：</p>
<ol>
<li>有哪些依赖被引入了</li>
<li>将ES6转换成ES5代码（为了兼容）</li>
</ol>
<p>对于第一个问题，<code>webpack</code>的解决方法是先将文件转化为<code>AST</code>抽象语法树，然后再解析<code>AST</code>，分析依赖。</p>
<ul>
<li>类比<code>Vue</code>的模板编译过程：<code>模板字符串=&gt;AST=&gt;render=&gt;vnode=&gt;dom</code></li>
<li>在<code>webpack</code>中的过程是：<code>代码字符串=&gt;AST=&gt;对象遍历解析</code></li>
</ul>
<p>对于第二个问题，利用<code>babel</code>可以轻松在AST中将代码转换为ES5</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getModuleInfo</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">// console.log(body)</span></span><br><span class="line">    <span class="comment">//第一个问题:有哪些依赖被引入了</span></span><br><span class="line">    <span class="comment">//转换语法树</span></span><br><span class="line">    <span class="comment">//过程就是:代码字符串str =&gt; 对象(AST) =&gt;对象遍历解析</span></span><br><span class="line">    <span class="comment">//类比vue:模板字符串=&gt; AST =&gt;render</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(body, &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span><span class="comment">//指的是ES Module</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// console.log(ast)</span></span><br><span class="line">    <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        <span class="comment">// vistor</span></span><br><span class="line">        <span class="function"><span class="title">ImportDeclaration</span>(<span class="params">&#123; node &#125;</span>)</span> &#123;</span><br><span class="line">            <span class="comment">//遇到import节点的时候</span></span><br><span class="line">            <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">            <span class="comment">//在windows下join拼接的是反斜杠，我们要加上转换才能正常</span></span><br><span class="line">            <span class="keyword">const</span> abspath = <span class="string">&#x27;./&#x27;</span> + path.join(dirname, node.source.value).replace(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="comment">// console.log(abspath)</span></span><br><span class="line">            <span class="comment">// 收集依赖</span></span><br><span class="line">            deps[node.source.value] = abspath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用babel将ast转译为es5的代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> moduleInfo = &#123; file, deps, code &#125;</span><br><span class="line">    <span class="comment">//导出入口文件和依赖项还有es5的代码</span></span><br><span class="line">    <span class="keyword">return</span> moduleInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Part3-依赖分析"><a href="#Part3-依赖分析" class="headerlink" title="Part3.依赖分析"></a>Part3.依赖分析</h2><p>我们前面解决了入口文件的依赖分析，但是有一个问题，就是<strong>入口文件的依赖文件本身可能也依赖其他的文件，</strong></p>
<p>因此，我们还需要更进一步，通过递归的方式去查询整个依赖图谱。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseModules</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取入口文件的依赖和信息</span></span><br><span class="line">    <span class="keyword">const</span> entry = getModuleInfo(file)</span><br><span class="line">    <span class="comment">//把入口文件的信息存入数组</span></span><br><span class="line">    <span class="keyword">const</span> temp = [entry]</span><br><span class="line">    <span class="comment">//依赖关系图</span></span><br><span class="line">    <span class="keyword">const</span> depsGraph = &#123;&#125;</span><br><span class="line">    getDeps(temp, entry)</span><br><span class="line">    temp.forEach(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//整理信息</span></span><br><span class="line">        depsGraph[info.file] = &#123;</span><br><span class="line">            <span class="attr">deps</span>: info.deps,</span><br><span class="line">            <span class="attr">code</span>: info.code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> depsGraph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取依赖,因为入口文件所依赖的文件本身也可能存在依赖，所以需要</span></span><br><span class="line"><span class="comment"> * 不断向下查询依赖直到没有依赖为止,在这个过程中也顺便把依赖项</span></span><br><span class="line"><span class="comment"> * 的代码转成了es5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDeps</span>(<span class="params">temp, &#123; deps &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//遍历每一个依赖文件</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(deps).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> child = getModuleInfo(deps[key])</span><br><span class="line">        temp.push(child)</span><br><span class="line">        <span class="comment">//递归向深处遍历，直到依赖全部加载</span></span><br><span class="line">        getDeps(temp, child)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Part4-打包"><a href="#Part4-打包" class="headerlink" title="Part4.打包"></a>Part4.打包</h2><p>在获取了所有的依赖和代码之后，我们可以打包了。在Part1中我们已经得到了<code>bundle</code>文件的原型格式，只需要将入口文件还有依赖图拼接上去，再在<code>./dist</code>文件夹中输出<code>bundle.js</code>就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合boundle原型和我们获取的依赖关系图</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> depsGraph = <span class="built_in">JSON</span>.stringify(parseModules(file))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(function (graph) &#123;</span></span><br><span class="line"><span class="string">            function require(file) &#123;</span></span><br><span class="line"><span class="string">                function absRequire(relPath) &#123;</span></span><br><span class="line"><span class="string">                    return require(graph[file].deps[relPath])</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">                (function (require, exports, code) &#123;</span></span><br><span class="line"><span class="string">                    eval(code)</span></span><br><span class="line"><span class="string">                &#125;)(absRequire, exports, graph[file].code)</span></span><br><span class="line"><span class="string">                return exports</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            require(&#x27;<span class="subst">$&#123;file&#125;</span>&#x27;)</span></span><br><span class="line"><span class="string">        &#125;)(<span class="subst">$&#123;depsGraph&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = bundle(<span class="string">&#x27;./src/index.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建dist文件夹，存放bundle.js</span></span><br><span class="line">!fs.existsSync(<span class="string">&#x27;./dist&#x27;</span>) &amp;&amp; fs.mkdirSync(<span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">fs.writeFileSync(<span class="string">&#x27;./dist/bundle.js&#x27;</span>, content)</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析单独模块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span><span class="variable">file</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getModuleInfo</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">// console.log(body)</span></span><br><span class="line">    <span class="comment">//第一个问题:有哪些依赖被引入了</span></span><br><span class="line">    <span class="comment">//转换语法树</span></span><br><span class="line">    <span class="comment">//过程就是:代码字符串str =&gt; 对象(AST) =&gt;对象遍历解析</span></span><br><span class="line">    <span class="comment">//类比vue:模板字符串=&gt; AST =&gt;render</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(body, &#123;</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span><span class="comment">//指的是ES Module</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// console.log(ast)</span></span><br><span class="line">    <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">    traverse(ast, &#123;</span><br><span class="line">        <span class="comment">// vistor</span></span><br><span class="line">        <span class="function"><span class="title">ImportDeclaration</span>(<span class="params">&#123; node &#125;</span>)</span> &#123;</span><br><span class="line">            <span class="comment">//遇到import节点的时候</span></span><br><span class="line">            <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">            <span class="comment">//在windows下join拼接的是反斜杠，我们要加上转换才能正常</span></span><br><span class="line">            <span class="keyword">const</span> abspath = <span class="string">&#x27;./&#x27;</span> + path.join(dirname, node.source.value).replace(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="comment">// console.log(abspath)</span></span><br><span class="line">            <span class="comment">// 收集依赖</span></span><br><span class="line">            deps[node.source.value] = abspath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用babel将ast转译为es5的代码</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> moduleInfo = &#123; file, deps, code &#125;</span><br><span class="line">    <span class="comment">//导出入口文件和依赖项还有es5的代码</span></span><br><span class="line">    <span class="keyword">return</span> moduleInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const info = getModuleInfo(&quot;./src/index.js&quot;)</span></span><br><span class="line"><span class="comment">// // getModuleInfo(&#x27;./src/index.js&#x27;)</span></span><br><span class="line"><span class="comment">// console.log(info)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析模块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseModules</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取入口文件的依赖和信息</span></span><br><span class="line">    <span class="keyword">const</span> entry = getModuleInfo(file)</span><br><span class="line">    <span class="comment">//把入口文件的信息存入数组</span></span><br><span class="line">    <span class="keyword">const</span> temp = [entry]</span><br><span class="line">    <span class="comment">//依赖关系图</span></span><br><span class="line">    <span class="keyword">const</span> depsGraph = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    getDeps(temp, entry)</span><br><span class="line"></span><br><span class="line">    temp.forEach(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//整理信息</span></span><br><span class="line">        depsGraph[info.file] = &#123;</span><br><span class="line">            <span class="attr">deps</span>: info.deps,</span><br><span class="line">            <span class="attr">code</span>: info.code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depsGraph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取依赖,因为入口文件所依赖的文件本身也可能存在依赖，所以需要</span></span><br><span class="line"><span class="comment"> * 不断向下查询依赖直到没有依赖为止,在这个过程中也顺便把依赖项</span></span><br><span class="line"><span class="comment"> * 的代码转成了es5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDeps</span>(<span class="params">temp, &#123; deps &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//遍历每一个依赖文件</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(deps).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> child = getModuleInfo(deps[key])</span><br><span class="line">        temp.push(child)</span><br><span class="line">        <span class="comment">//递归向深处遍历，直到依赖全部加载</span></span><br><span class="line">        getDeps(temp, child)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合boundle原型和我们获取的依赖关系图</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> depsGraph = <span class="built_in">JSON</span>.stringify(parseModules(file))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(function (graph) &#123;</span></span><br><span class="line"><span class="string">            function require(file) &#123;</span></span><br><span class="line"><span class="string">                function absRequire(relPath) &#123;</span></span><br><span class="line"><span class="string">                    return require(graph[file].deps[relPath])</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">                (function (require, exports, code) &#123;</span></span><br><span class="line"><span class="string">                    eval(code)</span></span><br><span class="line"><span class="string">                &#125;)(absRequire, exports, graph[file].code)</span></span><br><span class="line"><span class="string">                return exports</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            require(&#x27;<span class="subst">$&#123;file&#125;</span>&#x27;)</span></span><br><span class="line"><span class="string">        &#125;)(<span class="subst">$&#123;depsGraph&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> content = bundle(<span class="string">&#x27;./src/index.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建dist文件夹，存放bundle.js</span></span><br><span class="line">!fs.existsSync(<span class="string">&#x27;./dist&#x27;</span>) &amp;&amp; fs.mkdirSync(<span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">fs.writeFileSync(<span class="string">&#x27;./dist/bundle.js&#x27;</span>, content)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack学习笔记01</title>
    <url>/2021/12/05/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h1><p>webpack是一种前端资源构建工具，一个静态的模块打包器（module bundler）。在webpack看来，前端的所有资源文件（js/json/css/img/less）都会作为模块处理。</p>
<p><strong>五个核心概念</strong></p>
<ol>
<li><p><strong>Entry</strong></p>
<p>​    入口：提示webpack以哪一个文件为入口起点打包，分析构建内部依赖图。</p>
</li>
<li><p>   <strong>Output</strong></p>
</li>
</ol>
<p>   ​     输出：提示webpack打包后的资源bundles输出到哪里去，以及如何命名</p>
<ol start="3">
<li>   <strong>Loader</strong></li>
</ol>
<p>   ​     Loader：相当于翻译官，让webpack能够取处理哪些非JavaScript文件（webpack本身只能理解JavaScript）</p>
<ol start="4">
<li>   <strong>Plugins</strong></li>
</ol>
<p>   ​     插件：可以用于执行范围更广的任务。插件的范围包括从打包优化和压缩，一直到重新定义环境中的变量。</p>
<ol start="5">
<li><p>   <strong>Mode</strong></p>
</li>
<li><p>development</p>
<p>会将DefinePlugin中process.env.NODE_ENV的值设置为development能让代码本地调试运行的环境</p>
</li>
<li><p>production</p>
</li>
</ol>
<p>   ​       会将DefinePlugin中process.env.NODE_ENV的值设置为production能让代码优化上线运行的环境</p>
<h1 id="搭建一个基础开发环境"><a href="#搭建一个基础开发环境" class="headerlink" title="搭建一个基础开发环境"></a>搭建一个基础开发环境</h1><p>webpack.config.js<br>   webpack配置文件，webpack开发环境配置基本都在这里写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  开发环境配置：能让代码运行</span></span><br><span class="line"><span class="comment">    运行项目指令：</span></span><br><span class="line"><span class="comment">      webpack 会将打包结果输出出去</span></span><br><span class="line"><span class="comment">      npx webpack-dev-server 只会在内存中编译打包，没有输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// loader的配置</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理less资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理css资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理图片资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">limit</span>: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">// 关闭es6模块化</span></span><br><span class="line">          <span class="attr">esModule</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;imgs&#x27;</span></span><br><span class="line">        &#125;，</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;javascript/auto&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理html中img资源</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 处理其他资源</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/\.(html|js|css|less|jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;[hash:10].[ext]&#x27;</span>,</span><br><span class="line">          <span class="attr">outputPath</span>: <span class="string">&#x27;media&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">static</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">    <span class="comment">//启动gzip压缩</span></span><br><span class="line">    <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>webpack5踩坑<br>   在devServer配置中出口文件配置要使用static而不是contextBase<br>   使用devServer之后打包命令在Webpack5要用npx webpack serve而不是npx webpack-dev-server<br>   处理图片资源的时候要在rules的具体规则中加一句type: ‘javascript/auto’来阻止Webpack5自动打包</p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack学习笔记02</title>
    <url>/2021/12/06/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="Css文件优化操作"><a href="#Css文件优化操作" class="headerlink" title="Css文件优化操作"></a>Css文件优化操作</h1><h2 id="提取css文件"><a href="#提取css文件" class="headerlink" title="提取css文件"></a>提取css文件</h2><ol>
<li><p>默认情况下webpack打包会把css文件压缩到目的js文件中</p>
</li>
<li><p>如果要提取出js中的文件需要加载插件mini-css-extract-plugin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D	//加载依赖</span><br><span class="line"></span><br><span class="line">const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">	module:&#123;</span><br><span class="line">		rules:[</span><br><span class="line">			&#123;</span><br><span class="line">				test:/\.css$/,</span><br><span class="line">				use:[</span><br><span class="line">					//创建style标签，将样式放入</span><br><span class="line">					// &#x27;style-loader&#x27;,</span><br><span class="line">					//取代&#x27;style-loader&#x27;。作用，提取被打包js中的css代码成为单独的文件</span><br><span class="line">					MiniCssExtractPlugin.loader,</span><br><span class="line">					//将css文件整合到js文件中</span><br><span class="line">					&#x27;css-loader&#x27;</span><br><span class="line">				]</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins:[</span><br><span class="line">		new MiniCssExtractPlugin(&#123;</span><br><span class="line">			//对输出的css文件重命名</span><br><span class="line">			filename:&#x27;css/built.css&#x27;</span><br><span class="line">		&#125;)</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="压缩css文件"><a href="#压缩css文件" class="headerlink" title="压缩css文件"></a>压缩css文件</h2><ol>
<li>使用插件提取出来的css文件是按照正常格式输出的，这样的文件比较大，需要压缩</li>
<li>使用optimize-css-assets-webpack-plugin插件进行压缩</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i optimize-css-assets-webpack-plugin -D	//加载依赖</span><br><span class="line"></span><br><span class="line">const OptimizeCssAssetsWebpackPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;)</span><br><span class="line"></span><br><span class="line">	plugins:[</span><br><span class="line">		//压缩css</span><br><span class="line">		new OptimizeCssAssetsWebpackPlugin()</span><br><span class="line">	],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="css兼容性处理"><a href="#css兼容性处理" class="headerlink" title="css兼容性处理"></a>css兼容性处理</h2><p>1.在开发环境中对兼容性的要求很高，因为不同的浏览器之间css实现方式可能不同，可能会有冲突。这个时候就需要兼容性处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i postcss-preset-env -D	//加载依赖</span><br><span class="line"></span><br><span class="line">// 设置nodejs环境变量</span><br><span class="line">process.env.NODE_ENV = &#x27;development&#x27;;</span><br><span class="line"></span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#x27;css-loader&#x27;,</span><br><span class="line">          /*</span><br><span class="line">            css兼容性处理：postcss --&gt; postcss-loader postcss-preset-env</span><br><span class="line"></span><br><span class="line">            帮postcss找到package.json中browserslist里面的配置，通过配置加载指定的css兼容性样式</span><br><span class="line"></span><br><span class="line">            &quot;browserslist&quot;: &#123;</span><br><span class="line">              // 开发环境 --&gt; 设置node环境变量：process.env.NODE_ENV = development</span><br><span class="line">              &quot;development&quot;: [</span><br><span class="line">                &quot;last 1 chrome version&quot;,</span><br><span class="line">                &quot;last 1 firefox version&quot;,</span><br><span class="line">                &quot;last 1 safari version&quot;</span><br><span class="line">              ],</span><br><span class="line">              // 生产环境：默认是看生产环境</span><br><span class="line">              &quot;production&quot;: [</span><br><span class="line">                &quot;&gt;0.2%&quot;,</span><br><span class="line">                &quot;not dead&quot;,</span><br><span class="line">                &quot;not op_mini all&quot;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          */</span><br><span class="line">          // 使用loader的默认配置</span><br><span class="line">          // &#x27;postcss-loader&#x27;,</span><br><span class="line">          // 修改loader的配置</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              ident: &#x27;postcss&#x27;,</span><br><span class="line">              plugins: () =&gt; [</span><br><span class="line">                // postcss的插件</span><br><span class="line">                require(&#x27;postcss-preset-env&#x27;)()</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记01快速上手、选择器</title>
    <url>/2021/12/25/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1、css优势："><a href="#1、css优势：" class="headerlink" title="1、css优势："></a>1、css优势：</h2><ul>
<li>内容和表现分离</li>
<li>可以实现复用，网页结构表现统一</li>
<li>样式十分丰富</li>
<li>建议使用独立于html的css文件</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ul>
<h2 id="2、css的3中导入方式："><a href="#2、css的3中导入方式：" class="headerlink" title="2、css的3中导入方式："></a>2、css的3中导入方式：</h2><ol>
<li><p>内联样式</p>
<ul>
<li>写在本网页中的style标签中</li>
</ul>
</li>
<li><p>外联样式</p>
<ul>
<li>写在外部文件中，通过link标签引入（推荐，因为便于维护和管理）</li>
</ul>
</li>
<li><p>行内样式</p>
<ul>
<li>写在html标签的内部，用style=“”写</li>
</ul>
<p>优先级排序</p>
<p>行内&gt;内联&gt;外联</p>
</li>
<li><p>拓展：外联样式的两种写法</p>
<ol>
<li><p>连接式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 连接式 --&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/index.css&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>导入式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入式 --&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="keyword">@import</span> url(<span class="string">&quot;./css/index.css&quot;</span>);</span></span></span><br><span class="line"><span class="css"><span class="xml">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>两者区别</p>
<ul>
<li>link标签是html标签，只能放在html中使用。</li>
<li>@import在html中使用的时候外面要加style标签，但是也可以直接在css文件中使用用以引入其他css文件</li>
<li>本质上区别不大，推荐使用link</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h2><blockquote>
<p>作用：选择页面中的某一个元素</p>
</blockquote>
<ol>
<li>标签选择器</li>
<li>类选择器 class（可多对一）</li>
<li>id选择器（仅一对一，权重高）</li>
</ol>
<p>优先级：id&gt;class&lt;标签</p>
<h2 id="3-1、层次选择器"><a href="#3-1、层次选择器" class="headerlink" title="3.1、层次选择器"></a>3.1、层次选择器</h2><ol>
<li><p>后代选择器： 在某个元素后面</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*后代选择器 */</span></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子选择器，一代，儿子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 子选择器 */</span></span><br><span class="line"><span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>相邻兄弟选择器（只有一个，而且是向下相邻）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 相邻兄弟选择器 */</span></span><br><span class="line"><span class="selector-class">.p1</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通用兄弟选择器（下面所有统一层次的选择器）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通用选择器 */</span></span><br><span class="line"><span class="selector-class">.p1</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: chartreuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-2、结构伪类选择器"><a href="#3-2、结构伪类选择器" class="headerlink" title="3.2、结构伪类选择器"></a>3.2、结构伪类选择器</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ul的第一个子元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ul的最后一个子元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中p1 </span></span><br><span class="line"><span class="comment">选择当前p元素的父级元素，选中父级元素的第nth个，并且是当前元素的同类元素才生效*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#008000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择当前p元素的父级元素，选中父级元素的第nth个子类同类元素*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类，鼠标悬停 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、属性选择器"><a href="#3-3、属性选择器" class="headerlink" title="3.3、属性选择器"></a>3.3、属性选择器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-class">.demo</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">				<span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">				<span class="attribute">color</span>: aliceblue;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">				<span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">50px</span> Arial;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 存在id的元素，把他选中 a[]&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">				属性名，属性名 = 属性值(正则)</span></span></span><br><span class="line"><span class="comment"><span class="css">				= 为绝对等于</span></span></span><br><span class="line"><span class="comment"><span class="css">				*= 为包含此元素 </span></span></span><br><span class="line"><span class="comment"><span class="css">				^= 为以此开头的</span></span></span><br><span class="line"><span class="comment"><span class="css">				￥= 为以此结尾的</span></span></span><br><span class="line"><span class="comment"><span class="css">							*/</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[id]</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">color</span>: <span class="number">#0000FF</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[id=first]</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[class*=<span class="string">&quot;links&quot;</span>]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#FFE4C4</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 选中herf中以http开头的元素 */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[href^=http]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#FF0000</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[href$=pdf]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item active&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.png&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.jpg&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/a.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abcd.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item last&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>= 为绝对等于</li>
<li>*= 为包含此元素 </li>
<li>^= 为以此开头的</li>
<li>￥= 为以此结尾的</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记02样式</title>
    <url>/2021/12/26/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="美化网页元素"><a href="#美化网页元素" class="headerlink" title="美化网页元素"></a>美化网页元素</h1><ol>
<li><p>为什么要美化网页</p>
<ol>
<li>有效传递页面信息</li>
<li>美化网页、页面漂亮、才能吸引用户</li>
<li>凸显页面的主题</li>
<li>提高用户体验</li>
</ol>
</li>
<li><p>span</p>
<p>约定俗成的标记重点语句用的标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">		<span class="attribute">color</span>: <span class="number">#FF0000</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">	&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>word!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>字体样式</p>
<ul>
<li>font-family:”Arial Black”(字体)</li>
<li>font-size（字体大小）</li>
<li>font-weight:bolder(字体粗细)</li>
</ul>
</li>
<li><p>文本样式</p>
<ol>
<li>颜色    color    rgb    rgba</li>
<li>文本对齐方式   text-align = center</li>
<li>首行缩进 text-indent:2em</li>
<li>下划线（装饰） text-decoration</li>
<li>行高 line-height</li>
<li>文本图片水平对齐 vertical-align:middle</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">		<span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 居中 */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.p1</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 首行缩进 */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">text-indent</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.p2</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			<span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 行高，可以用于上下居中 */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 划线（上下中） */</span></span></span><br><span class="line"><span class="css">			<span class="attribute">text-decoration</span>: line-through;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">		<span class="comment">/* 水平对齐	参照物	a,b */</span></span></span><br><span class="line"><span class="css">		<span class="selector-tag">img</span>,<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">			<span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">		&#125;</span></span><br><span class="line"><span class="css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>故事简介<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span></span><br><span class="line">		从故事中可看出，JOJO每一代故事发生的背景舞台是不同的。</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">			作为主角的新一代JOJO，拥有诸多“萌点”。因帽子上的手型标志被网友指为平行世界的空条承太郎。赤身裸体从地底爬出的出场方式也十分“惊艳”。以异于常人的生理特点而被人称为“四蛋男”。现名为“东方定助”，事实上是吉良吉影与空条仗世文的融合。</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.png&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span>&gt;</span>jojo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>超链接伪类</p>
<p>一般情况下，使用:hover或:active足够了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-<span class="number">8</span>&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;style&gt;</span><br><span class="line">		<span class="comment">/* 默认颜色 */</span></span><br><span class="line">		<span class="selector-tag">a</span>&#123;</span><br><span class="line">			<span class="attribute">text-decoration</span>: none;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 鼠标悬停 */</span></span><br><span class="line">		<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#7FFF00</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 鼠标点击 */</span></span><br><span class="line">		<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">			<span class="attribute">color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">			<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="selector-id">#price</span>&#123;</span><br><span class="line">			<span class="attribute">text-shadow</span>: <span class="number">#7FFF00</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">3px</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">	&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">a</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;image<span class="selector-class">.png</span>&quot; /&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;ex&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">			&lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;yue&lt;/<span class="selector-tag">a</span>&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">		&lt;<span class="selector-tag">p</span> id=&quot;price&quot;&gt;</span><br><span class="line">			￥<span class="number">99</span></span><br><span class="line">		&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">	&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记03布局</title>
    <url>/2022/01/11/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>对于选择器的优先级：</p>
<ul>
<li>标签选择器、伪元素选择器：1</li>
<li>类选择器、伪类选择器、属性选择器：10</li>
<li>id选择器：100</li>
<li>内联样式：1000</li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li>!important声明的样式的优先级最高</li>
<li>如果优先级相同，则最后出现的样式生效</li>
<li>继承得到的样式优先级最低</li>
<li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以他们的权值为0</li>
<li>样式表的来源不同，优先级顺序为：内联样式&gt;内部样式&gt;外部样式&gt;浏览器用户自定义样式&gt;浏览器默认样式</li>
</ul>
<h6 id="简单记住结论：-important-gt-行内样式-gt-id选择器-gt-class选择器-属性选择器-gt-标签选择器-gt-通配符"><a href="#简单记住结论：-important-gt-行内样式-gt-id选择器-gt-class选择器-属性选择器-gt-标签选择器-gt-通配符" class="headerlink" title="简单记住结论：!important&gt;行内样式&gt;id选择器&gt;class选择器/属性选择器&gt;标签选择器&gt;通配符*"></a>简单记住结论：!important&gt;行内样式&gt;id选择器&gt;class选择器/属性选择器&gt;标签选择器&gt;通配符*</h6><h5 id="覆盖原则："><a href="#覆盖原则：" class="headerlink" title="覆盖原则："></a>覆盖原则：</h5><ol>
<li>由于集成儿发生样式冲突时，最近祖先获胜</li>
<li>继承的样式和直接指定的样式冲突的时候，样式权值高者获胜</li>
<li>样式权值相同时，后者获胜</li>
<li>!important的样式属性不被覆盖</li>
</ol>
<h2 id="CSS3中有哪些新特性"><a href="#CSS3中有哪些新特性" class="headerlink" title="CSS3中有哪些新特性"></a>CSS3中有哪些新特性</h2><ul>
<li>新增各种CSS选择器（:not(.input):所有class不是“input”的节点）</li>
<li>圆角（border-radius:8px）</li>
<li>多列布局（multi-column layout）</li>
<li>阴影和反射（Shadoweflect）</li>
<li>文字特效（text-shadow）</li>
<li>文字渲染（Text-decoration）</li>
<li>线性渐变（gradient）</li>
<li>旋转（transform）</li>
<li>增加了旋转，缩放，定位，倾斜，动画，多背景。</li>
</ul>
<h2 id="CSS中可继承和不可继承的属性有哪些"><a href="#CSS中可继承和不可继承的属性有哪些" class="headerlink" title="CSS中可继承和不可继承的属性有哪些"></a>CSS中可继承和不可继承的属性有哪些</h2><h5 id="无继承性的属性"><a href="#无继承性的属性" class="headerlink" title="无继承性的属性"></a>无继承性的属性</h5><ul>
<li>display：规定元素应该生成的框的类型</li>
<li>文本属性<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
</li>
<li>盒子模型的属性：width,height,margin,border,padding</li>
<li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
</ul>
<h2 id="display的属性值及其作用"><a href="#display的属性值及其作用" class="headerlink" title="display的属性值及其作用"></a>display的属性值及其作用</h2><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承display属性的值。</td>
</tr>
</tbody></table>
<h6 id="display的block、inline和inline-block的区别"><a href="#display的block、inline和inline-block的区别" class="headerlink" title="display的block、inline和inline-block的区别"></a>display的block、inline和inline-block的区别</h6><ul>
<li>block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding</li>
<li>inline：不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不嫩设置垂直方向的padding和margin</li>
<li>inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。对于行内元素和块级元素，其特点如下：<ul>
<li>行内元素<ul>
<li>设置宽高无效</li>
<li>可以设置水平方向的margin和padding属性，但不嫩设置垂直方向的padding和margin</li>
<li>不会自动换行</li>
</ul>
</li>
<li>块级元素<ul>
<li>可以设置宽高</li>
<li>可以设置margin和padding</li>
<li>可以自动换行</li>
<li>多个块级元素，默认排列从上到下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="隐藏元素的方法有哪些"><a href="#隐藏元素的方法有哪些" class="headerlink" title="隐藏元素的方法有哪些"></a>隐藏元素的方法有哪些</h3><ul>
<li>display:none：在页面中不占据位置，也不会响应绑定的监听事件</li>
<li>visibility:hidden：在页面中占据位置，但不会响应监听事件</li>
<li>opacity:0：设置透明度来隐藏元素，在页面中占据位置，同时会响应监听事件</li>
<li>clip/clip-path：裁剪元素，在页面中占据位置，但不会响应监听事件</li>
<li>transform:scale(0,0)：缩放元素，在页面中占据位置，但不会响应监听事件</li>
</ul>
<h3 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h3><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p>
<h3 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h3 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h3><ul>
<li>伪类就是一个选择处于特定状态的元素的选择器，比如某一个 clsss 的第一个元素，某个被 hover 的元素等等，我们可以理解成一个特定的 CSS 类，但与普通的类不一样，它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</li>
<li>伪元素和伪类很像，但是伪元素类似于增添一个新的 DOM 节点到 DOM 树中，而不是改变元素的状态。注意了，这里是类似，而不是真的增加一个节点，这也是其被称为伪元素的原因（实质上，元素被创建在文档外）。</li>
<li>伪类是操作文档中已有的元素，而伪元素是创建了一个文档外的元素，两者最关键的区别就是这点。此外，为了书写 CSS 时进行区分，一般伪类是单冒号，如:hover，而伪元素是双冒号::before。</li>
</ul>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ul>
<li>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</li>
</ul>
<h3 id="CSS预处理器-后处理器是什么？为什么要使用他们？"><a href="#CSS预处理器-后处理器是什么？为什么要使用他们？" class="headerlink" title="CSS预处理器/后处理器是什么？为什么要使用他们？"></a>CSS预处理器/后处理器是什么？为什么要使用他们？</h3><p>预处理器，如：less，sass，stylus，用来预编译sass或者less，增加了css代码的复用性。层级，mixin，变量，循环，函数等对编写以及开发UI组件都极为方便。</p>
<p>后处理器，如：postCss，通常是在完成的样式表中根据css规范化处理css，让其更加有效。目前最常做的就是给css属性添加浏览器私有前缀，实现跨浏览器兼容性问题。</p>
<p>css预处理器为css增加一些编程特性，无需考虑浏览器的兼容问题，可以在css 中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简介，增加适应性以及可读性，可维护性等。</p>
<p>其他css预处理器语言Sass（Scss），Less，Stylus…</p>
<p>使用原因：</p>
<ul>
<li>结构清晰，便于扩展</li>
<li>可以很方便的屏蔽浏览器私有语法的差异</li>
<li>可以轻松实现多重继承</li>
<li>完美的兼容了CSS代码，可以应用到老项目中。</li>
</ul>
<h3 id="页面布局单位以及设计（重点）"><a href="#页面布局单位以及设计（重点）" class="headerlink" title="页面布局单位以及设计（重点）"></a>页面布局单位以及设计（重点）</h3><h5 id="css布局单位"><a href="#css布局单位" class="headerlink" title="css布局单位"></a>css布局单位</h5><p>常用的由包括像素（px），百分比（%），em，rem，vw/wh</p>
<ol>
<li>像素<ul>
<li>像素是页面布局的基础，一个像素标识终端屏幕所能显示的最小区域，像素分为两种类型：CSS像素和物理像素：</li>
<li>CSS像素：为web开发者提供，在CSS中使用的一个抽象单位</li>
<li>物理像素：设备实际的像素</li>
</ul>
</li>
<li>百分比（%）,当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</li>
<li>em和rem相对于px跟家灵活，他们都是相对长度单位，区别：em相对于父元素，rem相对于根元素<ul>
<li>em：文本相对长度单位，相对当前对象被文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（默认16px）。（相对父元素的字体大小倍数）</li>
<li>rem：rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏间的比值来设置font-size的值，一次实现当屏幕分辨率变化是让元素也随之变化。</li>
</ul>
</li>
<li>vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口的高度，除了vw和vh外，还有vmin和vmax。</li>
</ol>
<h3 id="px、em、rem的区别"><a href="#px、em、rem的区别" class="headerlink" title="px、em、rem的区别"></a>px、em、rem的区别</h3><ul>
<li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li>
</ul>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><p>首先，实现flex布局需要先指定一个容器，任何一个容器都可以被指定为flex布局，这样容器的内部元素就可以使用flex来进行布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex | inline-flex; <span class="comment">/*可以有两种取值方式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</p>
</blockquote>
<p>有下面六种属性可以设置在容器上，它们分别是：</p>
<p>1、flex-direction</p>
<p>2、flex-wrap</p>
<p>3、flex-flow</p>
<p>4、justify-content</p>
<p>5、align-items</p>
<p>6、align-content</p>
<ul>
<li><strong>flex-direction: 决定主轴的方向(即项目的排列方向)</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认值：row，主轴为水平方向，起点在左端。</p>
<ul>
<li><strong>flex-warp：决定换行方式</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>flex-flow：是flex-direction和flex-warp的简写形式，默认为row nowarp</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-warp&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>justify-content：定义了在主轴上的对齐方式</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>align-items：定义了项目在交叉轴上的对齐方式</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>align-content：定义了项目在多轴上的对齐方式，如果只有一个轴则不算</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小测验：实现一个有16个元素的flex布局，这16个元素水平排列每四个一行，上下左右居中，同时是响应式的长宽</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">background</span>:skyblue;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>:row;<span class="comment">/*项目排列方向：水平*/</span></span><br><span class="line">    <span class="attribute">flex-wrap</span>:wrap;<span class="comment">/*项目换行方式：换行*/</span></span><br><span class="line">    <span class="attribute">align-content</span>:center;<span class="comment">/*项目交叉轴对齐方式：居中*/</span></span><br><span class="line">    <span class="attribute">justify-content</span>:center/*项目纵轴对齐方式：居中*/</span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">2%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220318224912723.png" alt="image-20220318224912723"></p>
<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>网格布局(grid)是css强大的布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前只能通过复杂的css框架达到的效果，现在浏览器内置了。</p>
<p>Grid布局和Flex布局有一定的相似性，都可以指定容器内部多个项目的位置。但是它们之间也有重大的区别。</p>
<p>Flex布局是轴线布局，只能指定‘项目（items）’针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid则是将容器划分为‘行’和‘列’，产生单元格，然后指定项目所在的单元格，可以看作是二维的布局。Grid布局对于各个项目（items）的自定义程度更高。</p>
<h5 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h5><p>首先，实现Grid布局需要先指定一个容器，任何一个容器都可以被指定为Grid布局，这样容器的内部元素就可以使用Grid来进行布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid | inline-grid; <span class="comment">/*可以有两种取值方式*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是：当时设置 Grid布局之后，子元素的 <code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p>
</blockquote>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><p><strong>grid-template-columns,grid-template-rows</strong></p>
<p>容器指定了网格布局后，接着就要划分行和列。<strong>grid-template-columns</strong>定义每一列的列宽,<strong>grid-template-rows</strong>定义每一行的行高。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>repeat()</p>
<p>使用经典写法的话需要手动定义每一行和每一列，可以使用repeat()函数简化重复的值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br><span class="line">  grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>auto-fill关键字</p>
<p>当单元格大小固定而容器的大小不确定的时候。如果希望每一行(或每一列)容纳尽可能多的单元格，这时可以使用auto-fill关键字。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fr 关键字（*）</p>
<p>为了方便比例的关系，网格布局提供了fr关键字（fraction的缩写，意为“片段”）。如果两列的宽度分别为1fr 和 2fr，就表示后者是前者的两倍。</p>
<p><strong>注意：一旦使用fr关键字，它将会默认将剩余的空间进行比例划分。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>minmax()</p>
<p>指定一个长度范围，接收两个参数，分别为最小值和最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure></li>
<li><p>auto关键字</p>
<p>让浏览器自己决定长度</p>
<p><strong>注意：设置垂直方向的排列布局会使垂直方向上的auto关键字失效，水平方向同理</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr auto <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>网格线的名称</p>
<p>在定义行高列宽的时候可以使用方括号为每一根网格线命名，方便以后引用。（使用网格线名称来指定项目放置的位置）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: [a] <span class="number">50px</span> [b] auto [c] <span class="number">20px</span> [d];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>布局实例</p>
<p><strong>grid-template-columns</strong>对于实现布局非常有用，例如两栏布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">30%</span> <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>row-gap，columns-gap，gap</strong></p>
<p><strong>row-gap和columns-gap</strong>分别设置表格的行间距和列间距</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">  grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>gap</strong>是<strong>row-gap和columns-gap</strong>的合并写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    grid-gap: <span class="number">20px</span> <span class="number">20px</span> || <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>grid-template-areas</strong>(*)</p>
<p>网格布局允许定义区域，一个区域可以由多个单元格组成。<strong>定义的区域只能为矩形区域，否则不生效</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>:<span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">    grid-template-rows:<span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">    grid-template-areas:<span class="string">&quot;a a a&quot;</span> <span class="string">&quot;c b b&quot;</span> <span class="string">&quot;c b b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">    grid-area:a;</span><br><span class="line">    <span class="attribute">background</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span>&#123;</span><br><span class="line">    grid-area:b;</span><br><span class="line">    <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.c</span>&#123;</span><br><span class="line">    grid-area:c;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220403154704309.png" alt="image-20220403154704309"></p>
</li>
<li><p><strong>grid-auto-flow</strong></p>
<p>这个属性定义项目items的换行方式，默认是先行后列。优先级上区域优先级更高。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-<span class="attribute">auto</span>-flow: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>justify-items,align-items,place-items</strong></p>
<p>这个属性定义单元格内的内容对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    justify-items: start | end | center | stretch;</span><br><span class="line">    <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>justify-content,align-content,place-content</strong></p>
<p>这个属性定义整个单元格的对齐方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: start | end | center | stretch;</span><br><span class="line">    <span class="attribute">align-content</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>grid-column-start，grid-column-end，grid-row-start，grid-row-end</strong></p>
<p>用于根据指定网格线取指定项目的位置</p>
</li>
<li><p><strong>justify-self ，align-self，place-self</strong></p>
<p>用于指定单个项目的定位，用法跟justify-content一样</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记04动画</title>
    <url>/2022/04/04/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h1><p>在CSS3之前前端动画实现基本上都靠JavaScriptAPI去动态改变元素样式属性来完成，这种方式虽然能够实现动画，但是在性能上存在一些问题。CSS3动画的出现很好地解决了这些问题。</p>
<p>CSS动画属性主要有<strong>transform、transition、animation</strong></p>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>transform可以用来设置元素的形状改变，主要有以下几种变形：<code>rotate</code>（旋转）、<code>scale</code>（缩放）、<code>skew</code>（扭曲）、<code>translate</code>（移动）和<code>matrix</code>（矩阵变形），语法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-class</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span> ： <span class="attribute">none</span> | &lt;<span class="attribute">transform</span>-function&gt; <span class="selector-attr">[ &lt;transform-function&gt; ]</span>*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>none</code>表示不做变换；<code>&lt;transform-function&gt;</code>表示一个或多个变化函数，变化函数由函数名和参数组成，参数包含在<code>()</code>里面，用<strong>空格</strong>分开，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-class</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span> ： rotate(<span class="number">30deg</span>) scale(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transform-origin基点"><a href="#transform-origin基点" class="headerlink" title="transform-origin基点"></a>transform-origin基点</h3><p>所有变形都是基于基点，基点默认为元素的中心点。用法：<code>transform-origin:(x,y)</code>其中x和y的值可以是百分比、rem或者px等等，也可以用表示位置的单词来表示例如：x可以用<code>left、center、right</code>；y可以用<code>top、center、bottom</code><strong>不要加括号也不要加逗号，空格就行</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-class</span> &#123;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rotate旋转"><a href="#rotate旋转" class="headerlink" title="rotate旋转"></a>rotate旋转</h3><p><code>rotate(&lt;angle&gt;)</code>；表示通过指定的角度对元素进行旋转变形，如果是正数则顺时针旋转，如果是负数则逆时针旋转，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-rotate</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scale缩放"><a href="#scale缩放" class="headerlink" title="scale缩放"></a>scale缩放</h3><p>它有三种用法：<code>scale(&lt;number&gt;[, &lt;number&gt;])</code>、<code>scaleX(&lt;number&gt;)</code>和<code>scaleY(&lt;number&gt;)</code>；分别代表水平和垂直方向同时缩放、水平方向的缩放以及垂直方向的缩放，入参代表水平或者垂直方向的缩放比例。缩放比例如果大于1则放大，反之则缩小，如果等于1代表原始大小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-scale</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>,<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transform-scaleX</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transform-scaleY</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="translate移动"><a href="#translate移动" class="headerlink" title="translate移动"></a>translate移动</h3><p>移动也分三种情况：<code>translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])</code>、<code>translateX(&lt;translation-value&gt;)</code>和<code>translateY(&lt;translation-value&gt;)</code>；分别代表水平和垂直的移动、水平方向的移动以及垂直方向同时移动，移动单位是 CSS 中的长度单位：<code>px</code>、<code>rem</code>等;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-translate</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">400px</span>, <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transform-translateX</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">300px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transform-translateY</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skew扭曲"><a href="#skew扭曲" class="headerlink" title="skew扭曲"></a>skew扭曲</h3><p>扭曲同样也有三种情况，<code>skew(&lt;angle&gt;[, &lt;angle&gt;])</code>、<code>skewX(&lt;angle&gt;)</code>和<code>skewY(&lt;angle&gt;)</code>；同样也是水平和垂直方向同时扭曲、水平方向的扭曲以及垂直方向的扭曲，单位为角度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transform-skew</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">30deg</span>, <span class="number">10deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transform-skewX</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skewX</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.transform-skewY</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skewY</span>(<span class="number">10deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="matrix矩阵形变"><a href="#matrix矩阵形变" class="headerlink" title="matrix矩阵形变"></a>matrix矩阵形变</h3><p>to be continue</p>
<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>transform是过渡的意思。过渡是CSS3中具有颠覆性的一个特征，可以实现元素不同状态的平滑过渡（补间动画），进程用来制作动画效果。 </p>
<p><code>transition</code>是用来设置样式的属性值是如何从一种状态平滑过渡到另外一种状态，他有四个属性：</p>
<ul>
<li>transition-property（变换的属性，即哪一种形式的变换：大小、位置、扭曲）</li>
<li>transition-duration（变换延续的时间）</li>
<li>transition-timing-function（变换的速率）</li>
<li>transition-delay（变换的延时）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-class</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span> ： <span class="selector-attr">[&lt;<span class="string">&#x27;transition-property&#x27;</span>&gt; || &lt;<span class="string">&#x27;transition-duration&#x27;</span>&gt; || &lt;<span class="string">&#x27;transition-timing-function&#x27;</span>&gt; || &lt;<span class="string">&#x27;transition-delay&#x27;</span>&gt; [, [&lt;<span class="string">&#x27;transition-property&#x27;</span>&gt; || &lt;<span class="string">&#x27;transition-duration&#x27;</span>&gt; || &lt;<span class="string">&#x27;transition-timing-function&#x27;</span>&gt; || &lt;<span class="string">&#x27;transition-delay&#x27;</span>&gt;]</span>]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><p>用于设置哪些属性的改变会有平滑过渡的效果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-property</span> &#123;</span><br><span class="line">    <span class="attribute">transition-property</span> ： <span class="attribute">none</span> | all | <span class="selector-attr">[ &lt;IDENT&gt; ]</span> <span class="selector-attr">[ <span class="string">&#x27;,&#x27;</span> &lt;IDENT&gt; ]</span>*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h3><p>用于设置转换过程的持续时间，单位是s或者ms</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-duration</span> &#123;</span><br><span class="line">    <span class="attribute">transition-duration</span> ： &lt;<span class="selector-tag">time</span>&gt; <span class="selector-attr">[, &lt;time&gt;]</span>* ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><p>它是来设置过渡效果的速率，它有6种形式的速率：</p>
<ul>
<li>ease：逐渐变慢（默认），等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)；</li>
<li>linear：匀速，等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)；</li>
<li>ease-in：加速，等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)；</li>
<li>ease-out：减速，等同于贝塞尔曲线(0, 0, 0.58, 1.0)；</li>
<li>ease-in-out：先加速后减速，等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)；</li>
<li>cubic-bezier：自定义贝塞尔曲线。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-timing</span> &#123;</span><br><span class="line">    <span class="attribute">transition-timing-function</span> ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) <span class="selector-attr">[, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)]</span>*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h3><p>它是来设置过渡动画开始执行的时间，单位是<code>s</code>或者<code>ms</code>，默认值为0；</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition-delay</span> &#123;</span><br><span class="line">    <span class="attribute">transition-delay</span> ： &lt;<span class="selector-tag">time</span>&gt; <span class="selector-attr">[, &lt;time&gt;]</span>*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transition-1"><a href="#transition-1" class="headerlink" title="transition"></a>transition</h3><p>它是<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code>的简写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.transition</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span> ：&lt;property&gt; &lt;duration&gt; &lt;timing function&gt; &lt;delay&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><p><code>animation</code>比较类似于flash中的逐帧动画，逐帧动画就像电影的播放一样，表现非常细腻并且有非常强大的灵活性。然而<code>transiton</code>只是指定了开始和结束态，整个动画的过程也是由特定的函数控制。这种逐帧动画是由关键帧组成的。在CSS3中就是由属性<code>keyframes</code>来完成逐帧动画的。</p>
<h3 id="keyframes关键帧"><a href="#keyframes关键帧" class="headerlink" title="@keyframes关键帧"></a>@keyframes关键帧</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> animationName &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        properties: value;</span><br><span class="line">    &#125;</span><br><span class="line">    percentage &#123;</span><br><span class="line">        properties: value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        properties: value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//or</span><br><span class="line"><span class="keyword">@keyframes</span> animationName &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        properties: value;</span><br><span class="line">    &#125;</span><br><span class="line">    percentage &#123;</span><br><span class="line">        properties: value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        properties: value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h3><p>它是用来设置动画的名称，可以同时赋值多个动画名称</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: none | IDENT[,none | IDENT]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h3><p>它是用来设置动画的持续时间，单位为<code>s</code>，默认值为<code>0</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-duration</span>: &lt;time&gt;[,&lt;time&gt;]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h3><p>和<code>transition-timing-function</code>类似：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-timing-function</span>:ease | linear | ease-in | ease-out | ease-in-out | <span class="built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, ease | linear | ease-in | ease-out | ease-in-out | <span class="built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h3><p>它是来设置动画的开始时间，单位是<code>s</code>或者<code>ms</code>，默认值为0：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-delay</span>: &lt;time&gt;[,&lt;time&gt;]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h3><p>它是来设置动画循环的次数，默认为<code>1</code>，<code>infinite</code>为无限次数的循环：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-iteration-count</span>:infinite | &lt;number&gt; [, infinite | &lt;number&gt;]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h3><p>它是来设置动画播放的方向，默认值为<code>normal</code>表示向前播放，<code>alternate</code>代表动画播放在第偶数次向前播放，第奇数次向反方向播放：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-direction</span>: normal | alternate [, normal | alternate]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h3><p>它主要是来控制动画的播放状态：<code>running</code>代表播放，而<code>paused</code>代表停止播放，<code>running</code>为默认值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animation</span> &#123;</span><br><span class="line">    <span class="attribute">animation-play-state</span>:running | paused [, running | paused]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="animation-1"><a href="#animation-1" class="headerlink" title="animation"></a>animation</h3><p>它是<code>animation-name</code>、<code>animation-duration</code>、<code>animation-timing-function</code>、<code>animation-delay</code>、<code>animation-iteration-count</code>、<code>animation-direction</code>的简写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">.animation &#123;</span><br><span class="line">    animation:[<span class="tag">&lt;<span class="name">animation-name</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-duration</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-timing-function</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-delay</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-iteration-count</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-direction</span>&gt;</span>] [, [<span class="tag">&lt;<span class="name">animation-name</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-duration</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-timing-function</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-delay</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-iteration-count</span>&gt;</span> || <span class="tag">&lt;<span class="name">animation-direction</span>&gt;</span>] ]*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css学习笔记05图层和浏览器渲染</title>
    <url>/2022/04/13/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%E5%9B%BE%E5%B1%82%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="图层和浏览器渲染"><a href="#图层和浏览器渲染" class="headerlink" title="图层和浏览器渲染"></a>图层和浏览器渲染</h1><h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><p>层叠上下文、渲染图层和复合图层（硬件加速）的区别和联系</p>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>层叠上下文是元素的一种属性，是html中的一个三维概念。如果元素具备以下任何一个条件，则改元素会创建一个新的层叠上下文。</p>
<ul>
<li>根元素</li>
<li>z-index不是auto的定位元素</li>
</ul>
<h3 id="渲染图层和复合图层的关系"><a href="#渲染图层和复合图层的关系" class="headerlink" title="渲染图层和复合图层的关系"></a>渲染图层和复合图层的关系</h3><p>两者都是为了让HTML元素在2D平面堆叠处3D的视觉效果。</p>
<p>简单理解就是，<strong>拥有层叠上下文属性的元素</strong>会生成一个新的层叠上下文对象，每个层叠上下文对象都是一个渲染图图层，渲染图层与复合图层的概念是不同的，渲染图层是伪3D，始终离不开层叠上下文，而复合图层则完全脱离层叠上下文，相当于开辟新的位面。</p>
<ul>
<li>渲染图层是页面普通的文档流，我们虽然可以通过绝对定位，相对定位，浮动定位脱离文档流，但他仍然属于默认复合层（根层叠上下文），共用一个绘图上下文对象（GraphicsContext）</li>
<li>复合图层，又称图形层。它会单独分配系统资源，每个复合图层都有一个独立的GraphicsContext。（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</li>
</ul>
<h4 id="复合涂层创建标准"><a href="#复合涂层创建标准" class="headerlink" title="复合涂层创建标准"></a>复合涂层创建标准</h4><ul>
<li>3D转换：translate3d，translateZ依此类推；</li>
<li>&lt;video&gt;，&lt;canvas&gt;和&lt;iframe&gt;元件;</li>
<li>有合成层后代同时本身 fixed 定位</li>
</ul>
<h2 id="浏览器渲染原理以及流程"><a href="#浏览器渲染原理以及流程" class="headerlink" title="浏览器渲染原理以及流程"></a>浏览器渲染原理以及流程</h2><h3 id="渲染流程有四个主要步骤："><a href="#渲染流程有四个主要步骤：" class="headerlink" title="渲染流程有四个主要步骤："></a>渲染流程有四个主要步骤：</h3><p><strong>1.解析HTML生成DOM树</strong> - 渲染引擎首先解析HTML文档，生成DOM树<br> <strong>2.构建Render树</strong> - 接下来不管是内联式，外联式还是嵌入式引入的CSS样式会被解析生成CSSOM树，根据DOM树与CSSOM树生成另外一棵用于渲染的树-渲染树(Render tree)，<br> <strong>3.布局Render树</strong> - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置<br> <strong>4.绘制Render树</strong> - 最后遍历渲染树并用UI后端层将每一个节点绘制出来<br> 以上步骤是一个渐进的过程，为了提高用户体验，渲染引擎试图尽可能快的把结果显示给最终用户。它不会等到所有HTML都被解析完才创建并布局渲染树。它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。</p>
<h3 id="关键渲染路径与阻塞渲染"><a href="#关键渲染路径与阻塞渲染" class="headerlink" title="关键渲染路径与阻塞渲染"></a>关键渲染路径与阻塞渲染</h3><p>在浏览器拿到HTML、CSS、JS等外部资源到渲染出页面的过程，有一个重要的概念<strong>关键渲染路径</strong>（Critical Rendering  Path）。例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。</p>
<p>现代浏览器总是并行加载资源，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。</p>
<p>同时，由于下面两点：</p>
<p>1.CSS 被视为<strong>渲染阻塞资源 (包括JS)</strong> ，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。<br> 2.JavaScript 被认为是<strong>解释器阻塞资源</strong>，HTML解析会被JS阻塞，它不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</p>
<p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p>
<p>1.当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。<br> 2.JavaScript 可以查询和修改 DOM 与 CSSOM。<br> 3.CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。<br> 所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<p>1.CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。<br> 2.JavaScript 应尽量少影响 DOM 的构建。</p>
<p>没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering  Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析（所以通常会把css放在头部，js放在body尾）</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2022/04/11/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="git常用操作命令"><a href="#git常用操作命令" class="headerlink" title="git常用操作命令"></a>git常用操作命令</h1><h3 id="git常用本地操作命令"><a href="#git常用本地操作命令" class="headerlink" title="git常用本地操作命令"></a>git常用本地操作命令</h3><ol>
<li><p>创建git库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>在当前目录中创建一个.git目录（含有.git目录的就是git仓库）</p>
</li>
<li><p>注册用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br><span class="line">git config --list #查看用户信息</span><br></pre></td></tr></table></figure></li>
<li><p>向git库中添加修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add[path] #会把对应的目录或文件，添加到stage状态</span><br><span class="line">git add . #将当前所有的未被忽略的文件添加到stage状态</span><br></pre></td></tr></table></figure></li>
<li><p>拉取远程仓库的代码到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li>
<li><p>向版本库提交修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m&quot;XXXXX&quot; #提交修改，添加注释</span><br></pre></td></tr></table></figure></li>
<li><p>将本地版本库中的提交推送到远程仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前代码库的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li>
<li><p>查看版本信息，这个版本信息就是你每次提交的时候生成的版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li>
<li><p>查看指定版本信息，根据上面的命令得到的信息查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show sdjf974654dd….  #(show后面为每次提交系统自动生成的一串哈希值)</span><br><span class="line"></span><br><span class="line">git show sdji97 #一般只使用版本号的前几个字符即可 </span><br></pre></td></tr></table></figure></li>
<li><p>撤销修改</p>
<p>git reset(可以回退commit操作)</p>
<ul>
<li><p>撤销整体的修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard #退回到原来编辑的地方，改动会丢失</span><br><span class="line">git reset --soft dsadwf #退回到指定的版本</span><br></pre></td></tr></table></figure>

<p>参数<strong>soft</strong>指的是：保留当前工作区，以便重新提交<br> 还可以选择参数<strong>hard</strong>，会撤销相应工作区的修改，一定要谨慎使用</p>
</li>
<li><p>撤销某次修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD^ #撤回上一次的修改</span><br><span class="line">git reset HEAD^^ #撤回上两次的修改，以此类推</span><br></pre></td></tr></table></figure></li>
</ul>
<p>撤销已经push到远程仓库的提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master –force #强制提交当前版本号，以达到撤销版本号的目的：</span><br></pre></td></tr></table></figure>

<p>必须添加参数<strong>force</strong>进行强制提交，否则会提交失败，并报错。报错原因：<strong>本地项目版本号低于远端仓库版本号</strong>。</p>
</li>
</ol>
<h3 id="git团队开发常用操作命令"><a href="#git团队开发常用操作命令" class="headerlink" title="git团队开发常用操作命令"></a>git团队开发常用操作命令</h3><ol>
<li><p>获取远端库项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone/pull</span><br></pre></td></tr></table></figure></li>
<li><p>团队开发基本流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .   #添加改动的文件</span><br><span class="line">git commit  #（提交至本地）</span><br><span class="line">git pull --rebase  #（将服务器项目与本地项目合并）</span><br><span class="line">git push    #（将本地项目上传至远端库）</span><br><span class="line">（在提交前要git pull --rebase 一下，确保当前的本地的代码为最新。） </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h3><ol>
<li><p>建立分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch AAA #建立新分支</span><br></pre></td></tr></table></figure></li>
<li><p>分支切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout AAA #从当前分支切换到AAA分支（若AAA分支不存在，则自动刷新）</span><br></pre></td></tr></table></figure></li>
<li><p>将分支与主枝master合并</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master   #（首先切换回主枝）</span><br><span class="line">git merge AAA    #（将分支AAA与主枝合并）</span><br><span class="line"></span><br><span class="line">注：git merge：默认情况下，Git执行&quot;快进式合并&quot;（fast-farward merge），会直接将Master分支指向Develop分支。</span><br><span class="line">使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰（保持提交曲线为直线），建议采用这种方法。 </span><br></pre></td></tr></table></figure></li>
<li><p>当前分支查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch    #默认有master（也称为主枝）</span><br><span class="line">git branch -r  #查看远端库分支</span><br><span class="line">git branch –a  #查看当前所有分支（包括本地分支和远端库分支） </span><br></pre></td></tr></table></figure></li>
<li><p>删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch –d  AAA   #删除分支AAA </span><br></pre></td></tr></table></figure></li>
<li><p>切下远端库A分支到本地库A分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b  A origin/A  （若本地A分支不存在，则自动新建） </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css常见布局方式</title>
    <url>/2022/03/30/css%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="CSS中常见的几种布局方式"><a href="#CSS中常见的几种布局方式" class="headerlink" title="CSS中常见的几种布局方式"></a>CSS中常见的几种布局方式</h1><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：两栏布局*/</span></span><br><span class="line"><span class="comment">/*1.float*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;<span class="comment">/*清除浮动，可以用float:right代替*/</span></span><br><span class="line">    <span class="attribute">background</span>:blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：两栏布局*/</span></span><br><span class="line"><span class="comment">/*2.flex*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：两栏布局*/</span></span><br><span class="line"><span class="comment">/*3.grid*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>:<span class="number">30%</span> <span class="number">70%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：三栏布局*/</span></span><br><span class="line"><span class="comment">/*1.flex*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">40%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:green;</span><br><span class="line">    <span class="attribute">flex</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：三栏布局*/</span></span><br><span class="line"><span class="comment">/*2.float*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">40%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：三栏布局*/</span></span><br><span class="line"><span class="comment">/*3.grid*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">display</span>:grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>:<span class="number">20%</span> <span class="number">60%</span> <span class="number">20%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:green;</span><br><span class="line">    <span class="attribute">flex</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="九宫格布局"><a href="#九宫格布局" class="headerlink" title="九宫格布局"></a>九宫格布局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.flex布局*/</span></span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">background</span>:skyblue;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>:row;<span class="comment">/*项目排列方向：水平*/</span></span><br><span class="line">    <span class="attribute">flex-wrap</span>:wrap;<span class="comment">/*项目换行方式：换行*/</span></span><br><span class="line">    <span class="attribute">align-content</span>:center;<span class="comment">/*项目交叉轴对齐方式：居中*/</span></span><br><span class="line">    <span class="attribute">justify-content</span>:center/*项目纵轴对齐方式：居中*/</span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">2%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*2.grid*/</span></span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">background</span>:skyblue;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">30%</span> <span class="number">30%</span> <span class="number">30%</span>;</span><br><span class="line">    grid-template-rows: <span class="number">30%</span> <span class="number">30%</span> <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">align-content</span>:center;<span class="comment">/*项目交叉轴对齐方式：居中*/</span></span><br><span class="line">    <span class="attribute">justify-content</span>:center/*项目纵轴对齐方式：居中*/</span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">2%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="水平垂直居中（重点）"><a href="#水平垂直居中（重点）" class="headerlink" title="水平垂直居中（重点）"></a>水平垂直居中（重点）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：水平垂直居中*/</span></span><br><span class="line"><span class="comment">/*1.利用绝对定位*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">background</span>:pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css常见布局：水平垂直居中*/</span></span><br><span class="line"><span class="comment">/*2.利用flex布局*/</span></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50vw</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内联元素居中布局"><a href="#内联元素居中布局" class="headerlink" title="内联元素居中布局"></a>内联元素居中布局</h4><p>水平居中</p>
<ul>
<li>行内元素可设置：text-align: center;</li>
<li>flex 布局设置父元素：display: flex; justify-content: center; </li>
</ul>
<p>垂直居中</p>
<ul>
<li>单行文本父元素确认高度：height === line-height </li>
<li>多行文本父元素确认高度：disaply: table-cell; vertical-align: middle; </li>
</ul>
<h4 id="块级元素居中布局"><a href="#块级元素居中布局" class="headerlink" title="块级元素居中布局"></a>块级元素居中布局</h4><p>水平居中</p>
<ul>
<li>定宽: margin: 0 auto; </li>
<li>不定宽： 参考上诉例子中不定宽高例子。 </li>
</ul>
<p>垂直居中</p>
<ul>
<li>position: absolute 设置 left、top、margin-left、margin-to(定高)； </li>
<li>position: fixed 设置 margin: auto(定高)； </li>
<li>display: table-cell； </li>
<li>transform: translate(x, y)； </li>
<li>flex(不定高，不定宽)； </li>
<li>grid(不定高，不定宽)，兼容性相对比较差； </li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js事件冒泡和捕获</title>
    <url>/2022/03/19/js%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<h1 id="javaScript事件"><a href="#javaScript事件" class="headerlink" title="javaScript事件"></a>javaScript事件</h1><h2 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h2><p>事件是文档和浏览器窗口中发生交互的瞬间，当我们对web页面进行某些类型的交互的时候，就发生了事件。</p>
<h2 id="什么是事件流？"><a href="#什么是事件流？" class="headerlink" title="什么是事件流？"></a>什么是事件流？</h2><p>事件流是从页面中接收事件的顺序，有IE提出的事件冒泡流，也有网景提出的事件捕获流。</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onclick</span>=<span class="string">&quot;bodyClick()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;divClick()&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;btn()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;p()&quot;</span>&gt;</span>点击冒泡<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;p标签被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">btn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;button被点击&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">divClick</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;div被点击&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">bodyClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;body被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件发生顺序</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319094655872.png" alt="image-20220319094655872"></p>
<p>可以看出冒泡流就是事件由最底层的文档先触发，再一步步向上触发，就像是冒泡一样从水底到水面。<strong>p=&gt;button=&gt;div=&gt;body</strong></p>
<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击捕获<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oP=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oB=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oD=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> oBody=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oP.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;p标签被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oB.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;button被点击&quot;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oD.addEventListener(<span class="string">&#x27;click&#x27;</span>,  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;div被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        oBody.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;body被点击&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件发生顺序：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319095041637.png" alt="image-20220319095041637"></p>
<p>可以看出，事件捕获是从最顶层的文档流开始向下触发，直到底层。</p>
<p><strong>body=&gt;div=&gt;button=&gt;p</strong></p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定事件流为三个阶段：“事件捕获阶段”，“处于目标阶段”，“事件冒泡阶段”。首先发生的事件捕获为获取事件提供机会，然后是事件的目标接受事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>DOM事件流<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="javascript">    btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;div 处于目标阶段&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;event bubble 事件冒泡&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">false</span>);<span class="comment">//最后的这个布尔值决定此事件是在捕获阶段触发（true）还是冒泡阶段触发（false）</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;event catch 事件捕获&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件触发顺序：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319100130996.png" alt="image-20220319100130996"></p>
<p>可以得出DOM事件流就是事件捕获和事件冒泡的结合</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1174211-20171201225153933-1205737719.png" alt="1174211-20171201225153933-1205737719"></p>
<p>关于DOM2级事件处理程序：</p>
<p>DOM 2级事件定义了两个方法：用于添加事件（addEventListener()）和删除事件（removeEventListiener()）</p>
<p>所有DOM节点都包含这两个事件，同时接收三个参数</p>
<ol>
<li>要处理的事件方式（click，mouseover，dbclick）</li>
<li>事件处理的函数，可以是命名函数，也可以是匿名函数，但是匿名函数无法被删除</li>
<li>一个布尔值，决定是在事件捕获阶段触发（true）还是在事件冒泡阶段触发（false），默认为false</li>
</ol>
<p>使用DOM2级事件的好处是可以定义多个触发函数，可以在不同阶段触发，也可以决定它们的顺序。</p>
<p>DOM2级事件和DOM0级事件的对比</p>
<p>DOM2级事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">         <span class="comment">//第一个事件</span></span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,foo,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;我是按钮&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//第二个事件</span></span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,newFoo,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">newFoo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;我是新按钮&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319101149877.png" alt="image-20220319101149877"></p>
<p>DOM0级事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;foo()&quot;</span>  <span class="attr">onclick</span>=<span class="string">&quot;newFoo()&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="number">2</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">newFoo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="number">9</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220319101256058.png" alt="image-20220319101256058"></p>
<p>可以看出，DOM0级事件重复定义的话是会只执行最早定义的，其他的会被忽略，而DOM2级事件不会覆盖，而是按照一定顺序执行。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2021/12/04/hello-world/</url>
    <content><![CDATA[<h2 id="博客搭建指南"><a href="#博客搭建指南" class="headerlink" title="博客搭建指南"></a>博客搭建指南</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodejs</span><br></pre></td></tr></table></figure>

<p>安装软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure>

<p>准备一个github账号</p>
<h3 id="第一步：绑定github（2021-8-14之后github取消了账号密码登录，只能使用shh登录了"><a href="#第一步：绑定github（2021-8-14之后github取消了账号密码登录，只能使用shh登录了" class="headerlink" title="第一步：绑定github（2021/8/14之后github取消了账号密码登录，只能使用shh登录了)"></a>第一步：绑定github（2021/8/14之后github取消了账号密码登录，只能使用shh登录了)</h3><h3 id="第二步：安装hexo"><a href="#第二步：安装hexo" class="headerlink" title="第二步：安装hexo"></a>第二步：安装hexo</h3><p>首先在D盘建立一个文件夹 Blog，点开 Blog 文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入 hexo init 命令初始化博客；</p>
<p>然后输入 hexo g 静态部署；</p>
<p>这时网页已经部署完成，输入 hexo s 命令可以查看；</p>
<h3 id="第三步：将Hexo部署到GitHub"><a href="#第三步：将Hexo部署到GitHub" class="headerlink" title="第三步：将Hexo部署到GitHub"></a>第三步：将Hexo部署到GitHub</h3><p>现在回到我们的 Blog 文件夹，用笔记本打开 _config.yml 文件，在最后输入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:GiorunoGiovanna/GiorunoGiovana.github.io.git  <span class="comment">#你的仓库地址(注意，由于GitHub登录规则的改变，最好使用git地址而不是http)</span></span><br><span class="line">  branch: master	<span class="comment">#要和你项目的分支名称一致</span></span><br></pre></td></tr></table></figure>

<p>然后回到 Blog 文件夹中，打开 Git Bash，安装Git部署插件</p>
<p>输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后分别输入以下三条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>完成以后就可以访问你的博客啦！</p>
<p>踩坑：</p>
<ol>
<li><p><strong>不知道是不是因为登录方式的改变，我一开始在deploy中rep地址使用的是http地址，一直报错说部署失败。</strong></p>
<p>把http地址改成shh的地址之后就可以正常部署了。</p>
</li>
<li><p><strong>部署到github上面之后开心地打开后发现没有样式，我直接？</strong></p>
<p>上网查找后发现在deploy中把url：那一行改一下就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: https://giorunogiovanna.github.io/GiorunoGiovana.github.io	#你的博客网址</span><br><span class="line">root: /GiorunoGiovana.github.io/	#你的博客网址最后一段后缀</span><br></pre></td></tr></table></figure></li>
<li><p>（2022/5/17）<strong>图床又崩了，这次是cdn的DNS污染了，好在没有全部寄，换一下图片url就可以了，流汗黄豆</strong></p>
<p><strong>记得把typeora的默认url也给换了</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220517155634833.png" alt="image-20220517155634833"></p>
<p><a href="https://github.com/jsdelivr/jsdelivr/issues/18397">https://github.com/jsdelivr/jsdelivr/issues/18397</a></p>
</li>
</ol>
<p>本博客只是用于学习笔记和踩坑记录，具体操作可以看大神的<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a></p>
]]></content>
  </entry>
  <entry>
    <title>Js学习笔记01Html中的JavaScript</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001Html%E4%B8%AD%E7%9A%84JavaScript/</url>
    <content><![CDATA[<h1 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a>script元素</h1><p>script元素是用于引入JavaScript的html元素。</p>
<p>1.可选属性有：</p>
<p>async：</p>
<p>​    表示应该立即下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效（不保证顺序执行）</p>
<p>defer：</p>
<p>​    表示脚本可以延迟到文档完全被解析后再执行。只对外部脚本有效。</p>
<p>2.scrpit标签中引用外部脚本的时候不受浏览器同源策略限制，就是可以跨域（jsonp方案的原理）</p>
<p>3.在script元素中的代码被计算完成之前，在这段代码之后的页面的其余内容不会被加载，也不会被显示。</p>
<p>4.不该在已经引用了外部脚本的script标签中包含JavaScript代码，会被忽略。</p>
<h3 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h3><p>1.放在head标签内</p>
<p>意味着必须把所有JavaScript代码都下载，解析和解释完成后才能渲染画面。（可能导致白屏幕时间过长）</p>
<p>2.放在body标签中页面内容的后面（通常做法）</p>
<p>会优先加载内容页面，再加载脚本。（白屏时间短，用户体验好）</p>
<h3 id="行内代码与外部文件"><a href="#行内代码与外部文件" class="headerlink" title="行内代码与外部文件"></a>行内代码与外部文件</h3><p>1.推荐将js代码放在外部文件，然后按需引入</p>
<p>​    理由：1.可维护性强，js代码过于分散维护难度会非常高，放到统一的文件下可维护性更高。</p>
<p>​                2.缓存性能，如果多个页面用到同一个脚本，只加载一次就够了。</p>
<p>​                3.外部脚本语法在HTML和XHTML中是一致的。</p>
<h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><p>使用DOM API（不太支持，就不展开了，红宝书P15）</p>
<h3 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a>noscript元素</h3><p>用于指定在浏览器不支持脚本时候显示的内容。如果浏览器支持js脚本，则此元素内的任何内容都不会被渲染。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记02语言基础</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol>
<li><h6 id="JavaScript中的一切都区分大小写"><a href="#JavaScript中的一切都区分大小写" class="headerlink" title="JavaScript中的一切都区分大小写"></a>JavaScript中的一切都区分大小写</h6></li>
<li><h6 id="变量标识符"><a href="#变量标识符" class="headerlink" title="变量标识符"></a>变量标识符</h6><ol>
<li>第一个字符必须是字母、下划线或美元符号</li>
<li>后面的字符必须是字母、下划线、美元符号或者数字</li>
<li>惯例上按照驼峰命名法</li>
</ol>
</li>
<li><h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><ol>
<li>单行注释使用    //</li>
<li>多行注释使用/*    */</li>
</ol>
</li>
<li><h6 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h6><ol>
<li>代码块{}</li>
<li>最好在控制语句中使用代码块</li>
</ol>
</li>
</ol>
<h1 id="Var关键字"><a href="#Var关键字" class="headerlink" title="Var关键字"></a>Var关键字</h1><ol>
<li><h6 id="var声明提升"><a href="#var声明提升" class="headerlink" title="var声明提升"></a>var声明提升</h6><ol>
<li>使用var声明变量还会自动提升到函数作用域顶部</li>
<li>也就是说可以先使用变量再声明它</li>
</ol>
</li>
<li><h6 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h6><ol>
<li>在函数内定义var变量，会成为函数中的局部变量</li>
<li>使用var声明，变量会自动被添加到最近的上下文</li>
<li>在函数内省略var关键字，如name=“gyp”。会创建全局变量（不推荐）</li>
</ol>
</li>
</ol>
<h1 id="Let关键字"><a href="#Let关键字" class="headerlink" title="Let关键字"></a>Let关键字</h1><ol>
<li><h6 id="和var的区别"><a href="#和var的区别" class="headerlink" title="和var的区别"></a>和var的区别</h6><ol>
<li>使用let在全局作用域中声明变量不会成为window对象的属性，而var会</li>
<li>var声明的是函数作用域，let声明的是块作用域</li>
<li>let声明不会提升，如果在定义let之前使用它会出现临时性死区</li>
<li>let在同一作用域下不能被声明两次</li>
</ol>
</li>
<li><h6 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h6><ol>
<li>在let之前，使用var定义for循环的迭代变量会渗透到循环体外。</li>
<li>使用let做for循环的迭代变量不会泄露，因为是块级作用域。</li>
<li>之前使用var，在循环中var变量中始终都是头一个变量，所以在循环体内访问var变量始终都是同一个值</li>
<li>使用let，每个循环都会创建新的迭代变量，所以在循环体内访问let变量是不同的。</li>
</ol>
</li>
</ol>
<h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><ol>
<li>与let基本一致，唯一一个重要区别是const必须在命名变量时赋值，且在后续使用中无法修改其值（定义常量）。</li>
<li>只应用到顶级原语或者对象，如果为const初始化一个对象，那么虽然无法改变const的引用值，但是对象内的键值是可以更改的</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><ol>
<li>对一个值使用typeof返回值</li>
<li>undefined，尚未初始化的变量——undefined</li>
<li>boolean——boolean</li>
<li>string——string</li>
<li>number——number</li>
<li>object，array，null——object</li>
<li>function——function</li>
<li>symbol——symbol</li>
</ol>
<h2 id="undefined（假值）"><a href="#undefined（假值）" class="headerlink" title="undefined（假值）"></a>undefined（假值）</h2><ol>
<li>默认情况下，任何未经初始化的变量都会取得undefined</li>
<li>undefined和未定义是有区别的，但是用typeof调用的话，得到的值都是undefined</li>
</ol>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><ol>
<li>从逻辑上讲，null表示一个空对象指针，这也是给typeof传一个null会返回“object”的原因</li>
<li>undefined是由null派生而来的，所以null==undefined为true</li>
<li>如果确定一个变量将来要保存对象，但是现在没有对象可以保存，最好用null填充它，这样以后查看它是否保存了对象，只要看他是不是null就行了</li>
</ol>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><ol>
<li><p>布尔值只有两个字面值，true和false（区分大小写）</p>
</li>
<li><p>不同类型转换为布尔值转换规则</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>非空字符串</td>
<td>“”（空字符串）</td>
</tr>
<tr>
<td>number</td>
<td>非零数值</td>
<td>0，NaN</td>
</tr>
<tr>
<td>object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>undefined</td>
<td>无</td>
<td>undefined</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Number（使用IEEE754格式）"><a href="#Number（使用IEEE754格式）" class="headerlink" title="Number（使用IEEE754格式）"></a>Number（使用IEEE754格式）</h2><ol>
<li><h6 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h6><ol>
<li>默认为十进制</li>
<li>以0开头会被认为是八进制，但不能超出表示范围，否则会被认为是十进制（例如0175被承认为八进制，089不被承认为八进制）</li>
<li>以Ox（区分大小写）开头会被认为是16进制</li>
<li>在数学操作中都被视为十进制</li>
</ol>
</li>
<li><h6 id="浮点值"><a href="#浮点值" class="headerlink" title="浮点值"></a>浮点值</h6><ol>
<li>要定义浮点值，数值必须包含小数点，小数点至少一位数字</li>
<li>浮点值空间是整数值两倍</li>
<li>浮点值精度为17位小数，但是不如整数精确（IEEE754格式导致的问题）</li>
</ol>
</li>
<li><h6 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h6><ol>
<li>number（）<ol>
<li>布尔值，true为1，false为0</li>
<li>数值，直接返回</li>
<li>null，返回0</li>
<li>undefined，返回NaN</li>
<li>字符串<ol>
<li>如果字符串只包含数值字符，包括前面+-符号，转换为十进制数。（忽略前导0，即不能转换八进制）</li>
<li>如果字符串包含有效浮点格式如“1.1”，转换为对应浮点数</li>
<li>如果字符串包含有效十六进制格式，则会转换为相应的十六进制的十进制格式。</li>
<li>其余情况，返回NaN</li>
</ol>
</li>
<li>对象，调用valueOf（）方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用toString（）方法，再按字符串规则转换。</li>
</ol>
</li>
<li>parseInt（）在需要得到整数时优先使用<ol>
<li>从第一个非空格字符开始转换。如果第一个字符不是数值，+，-符号，则立即返回NaN。所以空字符串也返回NaN。接下来会持续检测，返回一个整数。</li>
<li>可以识别不同的进制格式，包括十六进制，八进制。</li>
<li>可以接受第二个参数，作为底数，进制数，如parseInt（“AF”，16）//175</li>
</ol>
</li>
<li>parseFloat（）<ol>
<li>跟parseInt（）类似，不过会识别浮点数，并且不能识别十进制以外的进制。</li>
</ol>
</li>
</ol>
</li>
<li><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><ol>
<li>表示本来要返回数值的操作失败了</li>
<li>任何涉及NaN操作始终返回NaN</li>
<li>NaN不等于任何值，包括它本身</li>
</ol>
</li>
</ol>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ol>
<li><h6 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h6><table>
<thead>
<tr>
<th>\n</th>
<th>换行</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>退格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制表示的字符</td>
</tr>
<tr>
<td>\unnn</td>
<td>以十六进制表示的Unicode字符</td>
</tr>
</tbody></table>
</li>
<li><h6 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h6><ol>
<li>模板字面量会保持反引号内的空格</li>
</ol>
</li>
<li><h6 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h6><ol>
<li>从技术上来讲，模板字面量不是字符串，是一种特殊的JavaScript语法</li>
<li>通过在${}中使用js表达式实现</li>
</ol>
</li>
<li><h6 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h6><ol>
<li>toString（）<ol>
<li>可用于数组、布尔值、对象和字符串值；null和undefined没有toString方法</li>
<li>当转换为数值类型时，可以接受一个参数作为底数，就是作为几进制输出</li>
</ol>
</li>
<li>String（）<ol>
<li>当传入参数为null或undefined时，返回“null”或“undefined”</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><ol>
<li>对象其实就是一组数据和功能的集合</li>
<li>几个重要的属性和方法<ol>
<li>constrictor:用于创建当前对象的函数。</li>
<li>hasOwnProperty(propertyName):用于判断当前对象实例（不是原型）上是否存在给定属性。</li>
<li>defineProperty(obj，key，{…}):用于给对象的属性添加方法，Vue响应性原理。</li>
<li>valueOf():返回对象对应的数值，字符串，或布尔值</li>
</ol>
</li>
</ol>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><ol>
<li><h6 id=""><a href="#" class="headerlink" title="++"></a>++</h6><ol>
<li>在变量前如++a，在语句求值之前改变，+1</li>
<li>在变量后如a++，在语句求值之后改变，+1</li>
</ol>
</li>
<li><h6 id="–（同上）"><a href="#–（同上）" class="headerlink" title="–（同上）"></a>–（同上）</h6></li>
<li><h6 id="一元加和减"><a href="#一元加和减" class="headerlink" title="一元加和减"></a>一元加和减</h6><ol>
<li>和数学上用途一致</li>
<li>隐式转换加到不同类型中会试图将他们转换为数值类型，如+a</li>
</ol>
</li>
</ol>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><ol>
<li>按位非（~）作用是返回数值的一补数，最终结果时对数值取反再减一</li>
<li>按位与（&amp;）本质上是两个数的每一位对齐</li>
<li>按位或（|）有一则一，没一则零</li>
<li>有符号右移（&gt;&gt;&gt;）所有数值向右移指定位数，符号位也移动</li>
<li>有符号左移（&lt;&lt;&lt;）所有数值向左移指定位数，符号位不变</li>
<li>左移（&lt;&lt;）所有数值向左移指定位数，符号位不变</li>
</ol>
<h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><ol>
<li><h6 id="逻辑非（-）"><a href="#逻辑非（-）" class="headerlink" title="逻辑非（!）"></a>逻辑非（!）</h6></li>
</ol>
<table>
<thead>
<tr>
<th>操作数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>false</td>
</tr>
<tr>
<td>空字符串</td>
<td>true</td>
</tr>
<tr>
<td>非空字符串</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>true</td>
</tr>
<tr>
<td>非0数值</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>true</td>
</tr>
<tr>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>undefined</td>
<td>true</td>
</tr>
</tbody></table>
<p>双非！！，可以求出变量真正对应的布尔值</p>
<h6 id="2-逻辑与（-amp-amp-）"><a href="#2-逻辑与（-amp-amp-）" class="headerlink" title="2.逻辑与（&amp;&amp;）"></a>2.逻辑与（&amp;&amp;）</h6><table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>任意</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>布尔值为true</td>
<td>对象</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>对象</td>
<td>对象</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>null</td>
<td>——</td>
<td>null</td>
</tr>
<tr>
<td>NaN</td>
<td>——</td>
<td>NaN</td>
</tr>
<tr>
<td>undefined</td>
<td>——</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>短路操作符，第一个操作数为false，则第二个操作数被忽略</p>
<h6 id="3-逻辑或（-）"><a href="#3-逻辑或（-）" class="headerlink" title="3.逻辑或（||）"></a>3.逻辑或（||）</h6><table>
<thead>
<tr>
<th>第一个操作数</th>
<th>第二个操作数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>任意</td>
<td>返回第一个操作数</td>
</tr>
<tr>
<td>布尔值为false</td>
<td>对象</td>
<td>返回第二个操作数</td>
</tr>
<tr>
<td>对象</td>
<td>对象</td>
<td>返回第一个操作数</td>
</tr>
<tr>
<td>null</td>
<td>——</td>
<td>null</td>
</tr>
<tr>
<td>NaN</td>
<td>——</td>
<td>NaN</td>
</tr>
<tr>
<td>undefined</td>
<td>——</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>短路操作符，第一个操作数为true，则第二个操作数被忽略。</p>
<h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>乘法（*），除法（/），取模（%）</p>
<h2 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h2><ol>
<li>3**2等价于3的平方</li>
<li>a**等价于a的平方</li>
</ol>
<h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><ol>
<li><h6 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h6><ol>
<li><p>优先级最高：<br>如果有任意一个操作数为字符串，则将所有操作数转换为字符串再拼接。</p>
<p>Infinity加-Infinity=NaN</p>
</li>
</ol>
</li>
<li><h6 id="减法操作符"><a href="#减法操作符" class="headerlink" title="减法操作符"></a>减法操作符</h6></li>
</ol>
<h2 id="比较操作符-gt-lt-lt-gt"><a href="#比较操作符-gt-lt-lt-gt" class="headerlink" title="比较操作符(&gt;,&lt;,&lt;=,&gt;=)"></a>比较操作符(&gt;,&lt;,&lt;=,&gt;=)</h2><ol>
<li>非数值转换为数值比较</li>
<li>都是字符串，则逐个比较字符串对应字符编码</li>
</ol>
<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><ol>
<li>等于和不等于(==/!==)<ol>
<li>两个操作数会先进行强制类型转换</li>
<li>null==undefined(true)</li>
</ol>
</li>
<li>全等和不全等(===/!==)<ol>
<li>不进行强制类型转换，比较值和类型</li>
<li>null===undefined（false）</li>
</ol>
</li>
</ol>
<h2 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h2><ol>
<li><h6 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h6><ol>
<li>格式如a?b:c，a为真则执行b，为假则执行c</li>
<li>可以嵌套如:a?(b?c:d):e</li>
<li>方式简洁优雅，但是不便于阅读</li>
</ol>
</li>
<li><h6 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符(=)"></a>赋值操作符(=)</h6><ol>
<li>将右边的值赋值给左边</li>
<li>乘后赋值（*=）<br>除后赋值（/=）<br>取模后赋值（%=）<br>加后赋值（+=）<br>减后赋值（-=）<br>左移后赋值（&lt;&lt;=）</li>
</ol>
</li>
<li><h6 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h6><ol>
<li>可以用来在一条语句中执行多个操作，如:let num = 1，num1 = 2</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记03变量、作用域与内存</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="RegExp正则"><a href="#RegExp正则" class="headerlink" title="RegExp正则"></a>RegExp正则</h1><ol>
<li><p>支持直接使用let patten = /a/g的方式定义正则表达式</p>
</li>
<li><p>支持使用构造函数let patten = new RegExp(“a”,”i”)定义正则表达式，第一个参数使匹配字符串，第二个参数使模式选择。</p>
<p>注意：因为在构造函数中参数使字符串，所以某些情况下需要二次转义，可以看作每一个”\“前面都要加多一个”\”来转义它本身，才可以正常使用。</p>
</li>
<li><p>模式：</p>
<ol>
<li>i：忽略大小写</li>
<li>g：全局查找</li>
<li>m：多行查找</li>
</ol>
</li>
<li><p>实例方法</p>
<ol>
<li><p>主要方法使exec()</p>
<ol>
<li><p>如果找到了匹配项，则返包含第一个匹配信息的数组。</p>
<p>注意：返回的数组虽然是Array实例，但是包含两个额外的属性，index和input，index是字符串匹配模式的起始位置，input是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素则是与表达式中捕获组匹配的字符串。</p>
</li>
<li><p>没找到则返回null</p>
</li>
<li><p>如果模式设置了全局标记（g），则每次调用exec（）都会在字符串中向前搜索下一个匹配项。</p>
</li>
<li><p>如果没有设置全局标记，则每次都只会返回第一个匹配字符串。</p>
</li>
<li><p>如果设置了黏附标记y，则每一次调用exec（）就只会在lastIndex的位置上寻找匹配项。会覆盖全局标记。通过向前设置lastindex可以查找下一个匹配项。</p>
</li>
</ol>
</li>
<li><p>还有一个是text（）</p>
<ol>
<li>只检测是否匹配，不关心为什么。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="原始包装类型"><a href="#原始包装类型" class="headerlink" title="原始包装类型"></a>原始包装类型</h2><ol>
<li>每当用到某个原始值的方法或者属性时，后台都会创建一个相应的原始值包装数据类型，从而暴露出操作原始值的各种方法。</li>
</ol>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><ol>
<li>要创建一个Boolean对象，就要使用构造函数并传入true或者false</li>
<li>Boolean实例会重写valueOf（）方法，返回一个原始值true或者false</li>
<li>创建一个值为false的Boolean对象，在一个布尔表达式中用&amp;&amp;将这个对象和一个原始值true结合起来，返回的结果是true，因为Boolean对象在被转换的时候被当成了对象，而所有对象转化为Boolean值时都为true。</li>
</ol>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ol>
<li>创建方法直接使用数值赋值即可</li>
<li>实例方法<ol>
<li>toFixed()可以将数值格式化为字符串，接受参数为这个字符串有多少位小数。</li>
<li>toExponential()可以返回以科学技术法表示的数值字符串</li>
<li>isInteger()用于鉴别一个数组的值是否是整数</li>
<li>isSafeInteger()检查是否安全整数，即在IEEE754编码中可以表示</li>
</ol>
</li>
</ol>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol>
<li><p>JavaScript字符</p>
<ol>
<li>JavaScript字符串有16位码元组成。字符串的length属性表示字符串包含多少位16位码元。</li>
<li>chartAt()查找指定索引位置的16位码元，并返回码元对应的字符。</li>
<li>chartCodeAt()方法可以查看指定码元的字符编码（局限：有些字符需要不止16位码元表示，但是这个方法只会每16位解析）</li>
<li>fromChartCode()方法用于根据给定的UTF-16码元船舰字符串中的字符古。接受任意多的数值，并返回所有数值对应的字符凭借起来的字符串。</li>
<li>codePointAt()方法可以突破16位码元的限制</li>
</ol>
</li>
<li><p>字符串操作方法</p>
<ol>
<li>字符串截取<ol>
<li>slice()接受一到两个参数，第一个参数表示起始位置，第二个参数表示结束位置。如果是负数，则当成是倒数。</li>
<li>substr()接受一到两个参数，第一个参数表示起始位置，第二个参数表示从起始位置往后截取多少个字符。如果是负数，第一个参数当成倒数，第二个参数转换为零。</li>
<li>subString()接受一到两个参数，第一个参数表示其实位置，第二个参数表示从起始位置往后截取多少个字符。如果为负数，全部转为0</li>
</ol>
</li>
</ol>
</li>
<li><p>字符串位置方法</p>
<ol>
<li>indexOf()从前往后搜索字符串，返回第一个匹配的字符串索引。</li>
<li>lastIndexOf()从后往前第一个匹配的字符串索引。</li>
</ol>
<p>都接受第二个参数表示开始搜索的位置。</p>
</li>
<li><p>字符串包含方法</p>
<ol>
<li>startWith()    开始于索引0的匹配项</li>
<li>endWith()      结束于字符串末尾的匹配项</li>
<li>includes()      任意位置的匹配项</li>
</ol>
</li>
<li><p>trim()创建一个副本删除最前面和最后面的所有空格。</p>
</li>
<li><p>repeat()接受一个参数，表示要将字符串重复几次。</p>
</li>
<li><p>padStart()和padEnd()</p>
<ol>
<li>接受两个参数，从开头或者结尾填充第二个参数直到字符串长度达到第一个参数的长度。</li>
</ol>
</li>
<li><p>字符串迭代与解构，for-of迭代</p>
</li>
<li><p>字符串大小写转换，toLowerCase(),toUpperCase()</p>
</li>
<li><p>字符串模式匹配方法</p>
<ol>
<li>查找匹配match：pattern.exec(text)等价于text.match(pattern)</li>
<li>查找替换replace:接受两个参数，第一个参数如果是字符串，只会替换一次，如果是正则表达式，则会替换左右被匹配的字符串。</li>
</ol>
</li>
</ol>
<h2 id="Symbol（es6新增）"><a href="#Symbol（es6新增）" class="headerlink" title="Symbol（es6新增）"></a>Symbol（es6新增）</h2><p>Symbol是es6中新引进的一种原始数据类型，组要作用是可以表示独一无二的值。、</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> <strong>使用场景</strong></p>
<p>由于每一个symbol的值都是不相等的，所以使用symbol作为对象的属性名，可以保证属性不重名。这类属性不会被Object.keys()或者for…in遍历到，能够起到保护个别隐私属性的作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">a[s] = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">a.i = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记03变量、作用域与内存</title>
    <url>/2021/12/06/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h1><ol>
<li>原始值：最简单的数据</li>
<li>引用值：由多个值构成的对象</li>
<li>JavaScript不允许直接访问内存的位置，在操作对象的时候实际操作的时对该对象的引用，为此，保存引用值的变量是按引用访问的</li>
</ol>
<h2 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h2><ol>
<li>原始值：原始值不能拥有属性，但尝试给它添加属性不会报错</li>
<li>引用值：引用值可以动态添加属性</li>
<li>原始值的初始化：<ol>
<li>只使用原始字面量形式，如var a = 1</li>
<li>使用new初始化，这会创建一个object类型的实例，但是行为上类似于原始值</li>
</ol>
</li>
</ol>
<h2 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h2><ol>
<li><p>原始值：复制原始值得到的是一个相互独立的副本</p>
</li>
<li><p>引用值：引用值持有的其实是对堆内存中实际值的一个引用，复制引用值实际上是复制了指向堆内存的指针，所以原始引用值和复制的引用值是会互相影响的。（浅复制）</p>
</li>
<li><p>深复制：复制一份独立的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//借用JSON方法：stringify和parse实现深复制</span><br><span class="line">function deepClone(obj)&#123;</span><br><span class="line">    let _obj = JSON.stringify(obj),</span><br><span class="line">        objClone = JSON.parse(_obj);</span><br><span class="line">    return objClone</span><br><span class="line">&#125;    </span><br><span class="line">let a=[0,1,[2,3],4],</span><br><span class="line">    b=deepClone(a);</span><br><span class="line">a[0]=1;</span><br><span class="line">a[2][0]=1;</span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><ol>
<li>ECMAScript中所有函数都是按值传递的。</li>
<li>原始值：和复制值行为一样</li>
<li>引用值：注意！传递参数的时候不是按引用传递，而是按值传递。<ol>
<li>区别在于，如果你在函数内重新定义传入的参数，修改它的属性。</li>
<li>如果是按引用传递，在函数外查看参数的属性应该是会变的。</li>
<li>但是按值传递，函数外的对象属性不会发生变化，对对象的引用没有发生改变。</li>
</ol>
</li>
</ol>
<h2 id="如何确定类型"><a href="#如何确定类型" class="headerlink" title="如何确定类型"></a>如何确定类型</h2><ol>
<li>原始值用typeof确定类型比较好</li>
<li>引用值使用instanceof操作符确定类型，例如：person instanceof Object</li>
</ol>
<h2 id="表示符查找"><a href="#表示符查找" class="headerlink" title="表示符查找"></a>表示符查找</h2><p>当在特定上下文中为读取或写入而引用一个标识符的时候，必须通过搜索确定这个标识符表示什么。搜索从作用域顶端开始，一直查找到全局上下文对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记05集合引用类型Object</title>
    <url>/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><ol>
<li><h5 id="两种创建方式"><a href="#两种创建方式" class="headerlink" title="两种创建方式"></a>两种创建方式</h5><ol>
<li>new Object</li>
<li>使用对象字面量{name:’a’}</li>
</ol>
</li>
<li><h5 id="关于定义对象的“-”出现的地方"><a href="#关于定义对象的“-”出现的地方" class="headerlink" title="关于定义对象的“{”出现的地方"></a>关于定义对象的“{”出现的地方</h5><ol>
<li>出现在表达式上下文中（期待返回值的上下文中），赋值操作符表示后面要期待一个值，因此在左大括号表达一个表达式的开始。</li>
<li>出现在语句上下文中，比如if语句的条件后面，则表示一个语句块的开始</li>
</ol>
</li>
<li><h5 id="属性一般是使用点语法来存取的，例如obj-name-“pa”"><a href="#属性一般是使用点语法来存取的，例如obj-name-“pa”" class="headerlink" title="属性一般是使用点语法来存取的，例如obj.name=“pa”"></a>属性一般是使用点语法来存取的，例如obj.name=“pa”</h5><p>注意：也可以使用中括号存取，例如obj[“name”]=”pa”使用中括号的优点在于如果属性名中包含会导致语法错误的字符，只用中括号可以避免这一点。（fs优化对象值的存取）</p>
</li>
<li><h5 id="属性值可以是字符串或数值-数值会自动转为字符串"><a href="#属性值可以是字符串或数值-数值会自动转为字符串" class="headerlink" title="属性值可以是字符串或数值(数值会自动转为字符串)"></a>属性值可以是字符串或数值(数值会自动转为字符串)</h5></li>
</ol>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ol>
<li><h5 id="两种创建方式-1"><a href="#两种创建方式-1" class="headerlink" title="两种创建方式"></a>两种创建方式</h5><ol>
<li>使用new Array()来创建<ol>
<li>可以传入一个数值，然后length属性就会自动设置成这个值。配合fill函数可以创建一个全部为某一个数的数组</li>
<li>也可以传入要保存的元素</li>
</ol>
</li>
<li>使用数组字面量</li>
</ol>
</li>
<li><h5 id="es6新增的创建数组的方法。"><a href="#es6新增的创建数组的方法。" class="headerlink" title="es6新增的创建数组的方法。"></a>es6新增的创建数组的方法。</h5><ol>
<li>from()用于将类数组结构转化为数组<ol>
<li>第一个参数但是任何可迭代结构</li>
<li>第二个参数可以选择映射函数的参数，这个函数可以直接增强新数组的值</li>
<li>第三个参数用于指定映射函数中this的值</li>
</ol>
</li>
<li>of()用于将一组参数转换为数组实例</li>
</ol>
</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ol>
<li><h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li><p>使用new Map()创建一个空映射</p>
<p>可以给这个构造函数传入一个可迭代对象。需要包含键值对数组。可迭代对象中的每一个键值对都会按照迭代顺序插入到新实例对象中</p>
</li>
</ol>
</li>
<li><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ol>
<li>set()添加键值对</li>
<li>get()查找键对应的值</li>
<li>has()查询是否有这个键</li>
<li>delete()删除某个键值对</li>
<li>clear()删除所有键值对</li>
</ol>
</li>
<li><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ol>
<li>Object只能使用数值。字符串或者符号作为键。</li>
<li>Map可以使用任何JavaScript对象数据类型作为键</li>
<li>在映射中作为键和值对象或其他集合类型，在自己的内容被修改时，映射关系不会改变。</li>
</ol>
</li>
<li><h5 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h5><ol>
<li>映射（map）实例可以提供一个迭代器(Iterator)可以通过entries()方法或者Symbol.iterator属性取得这个迭代器。<ol>
<li>for(let pair of m.entries())</li>
<li>for(let pair of m[Symbol.iterator])</li>
<li>键和值在迭代器遍历的时候是可以修改的，但在映射内部是不可修改的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h1><ol>
<li><h5 id="创建方式-1"><a href="#创建方式-1" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li>使用new WeakMap()关键字实例化一个空的弱映射</li>
</ol>
</li>
<li><h5 id="弱映射中的键只能是object或者继承自object的类型，值没有限制"><a href="#弱映射中的键只能是object或者继承自object的类型，值没有限制" class="headerlink" title="弱映射中的键只能是object或者继承自object的类型，值没有限制"></a>弱映射中的键只能是object或者继承自object的类型，值没有限制</h5></li>
<li><h5 id="操作和Map基本一致，除了没有clear，set-方法返回弱映射实例，因此可以串联设置"><a href="#操作和Map基本一致，除了没有clear，set-方法返回弱映射实例，因此可以串联设置" class="headerlink" title="操作和Map基本一致，除了没有clear，set()方法返回弱映射实例，因此可以串联设置"></a>操作和Map基本一致，除了没有clear，set()方法返回弱映射实例，因此可以串联设置</h5></li>
<li><h5 id="使用弱映射"><a href="#使用弱映射" class="headerlink" title="使用弱映射"></a>使用弱映射</h5><ol>
<li>私有变量<ol>
<li>私有变量会储存在弱映射中，以对象实例为键，以私有成员的字段为值</li>
</ol>
</li>
<li>DOM节点元数据<ol>
<li>因为WeakMap实例不会妨碍垃圾回收机制，所以非常适合保存关联元数据。</li>
<li>当节点从DOM树种被删除后，垃圾回收程序会立即释放内存。（假设没有其他地方引用这个对象）</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。"><a href="#因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。" class="headerlink" title="因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。"></a>因为WeakMap中的键值对随时可能被摧毁，所以没有必要提供迭代键值对的能力。</h5></li>
<li><h5 id="弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。"><a href="#弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。" class="headerlink" title="弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。"></a>弱映射中的弱指的是键不属于正式的引用，不会阻止垃圾回收。但是值是正式的引用。意思是说只要键是存在的，键值对就会存在于映射中。</h5></li>
</ol>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol>
<li><h5 id="创建方式-2"><a href="#创建方式-2" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li>使用new Set()关键字实例化一个空的集合<ol>
<li>可以传入一个可迭代对象，其中包含需要插入到集合的元素。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h5><ol>
<li>add()增加一个值</li>
<li>has()查询一个值</li>
<li>size()取得元素数量</li>
<li>delete()/clear()删除值</li>
</ol>
</li>
<li><h5 id="Set可以包含任何JavaScript数据类型作为值"><a href="#Set可以包含任何JavaScript数据类型作为值" class="headerlink" title="Set可以包含任何JavaScript数据类型作为值"></a>Set可以包含任何JavaScript数据类型作为值</h5><ol>
<li>用作值的对象和其他集合类型在自身改变时不会影响。</li>
</ol>
</li>
<li><h5 id="顺序与迭代-1"><a href="#顺序与迭代-1" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h5><ol>
<li><p>Set会维护值插入时的顺序，因此支持顺序迭代</p>
</li>
<li><p>set实例可以提供一个迭代器(Iterator)，能以插入顺序生成集合内容。</p>
</li>
<li><p>可以通过values()方法以及其别名方法keys()</p>
<p>for(let v of s.values())</p>
</li>
<li><p>或者Symbol.ietrator属性，他引用values()取得这个迭代器</p>
<p>for(let v of s[Symbol.iterator])</p>
</li>
<li><p>set的entires()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现。</p>
</li>
</ol>
</li>
</ol>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><ol>
<li><h5 id="创建方式-3"><a href="#创建方式-3" class="headerlink" title="创建方式"></a>创建方式</h5><ol>
<li>使用new WeakSet()关键字实例化一个空的弱集合<ol>
<li>可以接受一个可迭代的对象，其中需要包含有效的值</li>
<li>弱集合中的值只能是object或继承自object类型</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h5><ol>
<li>add()增加一个值</li>
<li>has()查询一个值</li>
<li>delete()删除一个值</li>
</ol>
</li>
<li><h5 id="弱集合中的值不属于正式引用，不会阻止垃圾回收"><a href="#弱集合中的值不属于正式引用，不会阻止垃圾回收" class="headerlink" title="弱集合中的值不属于正式引用，不会阻止垃圾回收"></a>弱集合中的值不属于正式引用，不会阻止垃圾回收</h5></li>
<li><h5 id="使用弱集合"><a href="#使用弱集合" class="headerlink" title="使用弱集合"></a>使用弱集合</h5><ol>
<li>给对象打标签<ol>
<li>创建WeakSet实例，将需要被打上标签的值放进去，如果这个值的引用被删除了，那么weakSet中对应的值也会被回收。</li>
</ol>
</li>
</ol>
</li>
<li><p>不可迭代值</p>
<ol>
<li>weakSet中的值可以随时销毁，因此没有必要迭代。</li>
</ol>
</li>
</ol>
<h1 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h1><ol>
<li><h5 id="有4中原生集合类型定义了默认迭代器"><a href="#有4中原生集合类型定义了默认迭代器" class="headerlink" title="有4中原生集合类型定义了默认迭代器"></a>有4中原生集合类型定义了默认迭代器</h5><ol>
<li>Array</li>
<li>所有定型数组</li>
<li>Map</li>
<li>Set</li>
</ol>
</li>
<li><h5 id="这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。"><a href="#这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。" class="headerlink" title="这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。"></a>这四种类型都支持顺序迭代，都可以传入for-of循环。都兼容扩展操作符。</h5></li>
<li><h5 id="对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。"><a href="#对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。" class="headerlink" title="对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。"></a>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现赋值。</h5></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记06迭代器与生成器</title>
    <url>/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ol>
<li><h5 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h5><ol>
<li>迭代是循环的一种，可以指定迭代次数，以及迭代要执行的操作，顺序也是事先定好的。</li>
</ol>
</li>
<li><p>可迭代协议</p>
<ol>
<li>实现Iterrable接口（可迭代协议）要求支持迭代的自我识别能力和创建实现Iterable接口的对象能力。在ECMAScript中，这意味着必须暴露一个属性作为默认的迭代器，而这个属性必须使用特殊的Symbol.iterator作为键。这个默认的迭代器属性必须应用一个迭代器工厂函数，调用这个工厂函数必须返回一个迭代器。</li>
</ol>
</li>
<li><p>迭代器模式</p>
<ol>
<li>可迭代对象可以理解为数组或集合这样的集合类型对象。包含与有限元素，且有无歧义的遍历顺序。</li>
</ol>
</li>
<li><p>迭代器协议</p>
<ol>
<li>迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()都会返回一个包含迭代器返回的下一个值的对象。<ol>
<li>迭代器并不知道怎么从可迭代对象中获取下一个值，也不知道可迭代对象有多大。只要迭代器到达done:true状态，后续调用next()对象就一直返回这个值了。</li>
<li>每个迭代器都表示可迭代对象的一次性有序遍历。不同迭代器实例之间没有联系，只会独立第遍历可迭代对象。</li>
</ol>
</li>
</ol>
</li>
<li><p>提前终止迭代器</p>
<ol>
<li>可选的return()方法用于指定迭代器关闭时执行的逻辑。</li>
</ol>
</li>
</ol>
<h1 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h1><ol>
<li><p>生成器基础</p>
<ol>
<li>生成器的形式是一个函数，在函数名称前面加一个*号，例如:function *foo(){…},只要可以定义函数的地方，就可以定义生成器。</li>
<li>调用生成器函数会生成一个生成器对象，生成器对象一开始处于暂停执行的状态。与迭代器相似，生成器对象也实现了Iterator接口，因此具有next()方法。调用这个方法会让生成器开始或回复执行。</li>
<li>next()方法的返回值有一个done和value属性<ol>
<li>函数体为空的函数调用一遍next()就返回done:true状态</li>
</ol>
</li>
<li>生成器对象实现了Iterable接口，他们的默认迭代器是自引用的。</li>
</ol>
</li>
<li><p>通过yield中断执行（重点）</p>
<ol>
<li><p>这是生成器最有用的地方</p>
<ol>
<li>生成器在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行。</li>
<li>yield关键字只能在生成器函数内部使用，用在其他地方会抛出错误。</li>
</ol>
</li>
<li><p>生成器对象作为可迭代对象</p>
<ol>
<li><p>如果把生成器对象当成可迭代对象，那么使用起来会很方便。也可以自定义迭代对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *foo（）&#123;</span><br><span class="line">	yield 1;</span><br><span class="line">	yield 2;</span><br><span class="line">	yield 3</span><br><span class="line">&#125;</span><br><span class="line">for (const x of foo())&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义迭代对象</span><br><span class="line">function *foo（n）&#123;</span><br><span class="line">	while（n--）&#123;</span><br><span class="line">		yield；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (const x of foo(3))&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">//0</span><br><span class="line">//1</span><br><span class="line">//2</span><br></pre></td></tr></table></figure></li>
<li><p>使用yield实现输入和输出</p>
<ol>
<li>yield可以作为函数的中间参数使用。上一次生成器暂停的yield关键字会接收到传给next（）方法的第一个值。（第一次调用next()传入的值不会被使用，因为第一次是开始执行生成器函数）（可以同时用于输入和输出）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *foo（）&#123;</span><br><span class="line">	return yield &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line">let bar = foo()</span><br><span class="line">console.log(bar.next());		//&#123;done:false, value:&#x27;foo&#x27;&#125;</span><br><span class="line">console.log(bar.next(&quot;bar&quot;))	//&#123;done:true, value:&#x27;bar&#x27;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>产生可迭代对象</p>
<ol>
<li>yield的值是关联迭代器返回done:true时的value属性。对于普通迭代器来说，这个值时undefined，对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值。</li>
<li>可以使用*增强yield的行为，让它能够迭代一个可迭代对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *foo()&#123;</span><br><span class="line">	yield *[1,2]</span><br><span class="line">	yield *[3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(const x of foo())&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//1</span><br><span class="line">//2</span><br><span class="line">//3</span><br><span class="line">//4</span><br></pre></td></tr></table></figure></li>
<li><p>使用yield实现递归算法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function *nTimes(n)&#123;</span><br><span class="line">	if(n&gt;0)&#123;</span><br><span class="line">		yield *nTimes(n-1)</span><br><span class="line">		yield n-1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(const x of nTimes(5))&#123;</span><br><span class="line">	console.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>扩展：async、await原理</p>
<p>async函数返回一个Promise对象，当函数执行的时候，一旦遇到awiat就会先返回，等到触发的异步操作完成，才会接着执行函数体后面的的语句。async函数就是Generator函数的语法糖。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记07对象</title>
    <url>/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><ol>
<li><h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><ol>
<li><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><ol>
<li>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。</li>
<li>要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接受3个参数（要个其添加属性的对象，属性的名称和一个描述对象）<ol>
<li>最后一个参数，即描述符对象上的属性可以包含:configurable、enumerable、wirtable和value</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ol>
<li>访问器属性不包含数据值，包含一个获取(getter)函数和一个(setter)函数，不过这两个函数不是必须的。</li>
<li>在读取访问器属性时，会调用获取函数，这个函数的责任是返回一个有效的值。再写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。（Vue响应式原理）</li>
</ol>
</li>
<li><h5 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h5><ol>
<li>Object.defineProperties()可以通过多个描述符一次性定义多个属性。它接受两个参数（要为之添加或修改属性的对象和另一个描述符对象，其属性与一一对应）</li>
</ol>
</li>
<li><h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><ol>
<li>使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。<ol>
<li>这个方法接受两个参数:属性所在的对象和要去的其描述符的属性名。返回值是一个对象，包含访问器属性</li>
</ol>
</li>
<li>ES7新增了Object.getOwnPropertyDescriptors()静态方法<ol>
<li>接受一个对象，并返回这个对象每个属性的特性</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><ol>
<li>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个复制动作。可以简写<ol>
<li>解构赋值不一定与对象属性匹配，赋值的时候可以忽略某些属性，如果引用的属性不存在，则该变量的值为undefined，也可以定义默认值，适用于属性不存在的情况。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><ol>
<li><h5 id="属性值的简写"><a href="#属性值的简写" class="headerlink" title="属性值的简写"></a>属性值的简写</h5><ol>
<li>简写的属性名只要使用变量名就会自动被解释为同名的属性键</li>
</ol>
</li>
<li><h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><ol>
<li>如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能再对象字面量中直接动态命名属性<ol>
<li>中括号包围的对象属性键告诉运行时将其作为JavaScript表达式而不是字符串来求值。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><ol>
<li><p>再给对象定义方法时，通常要写一个方法名、冒号，然后再引用一个匿名函数表达式。</p>
<ol>
<li>新的简写方法可以直接声明函数，例如sayName(){…}，与可计算属性键相互兼容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const methodKey = &quot;foo&quot;</span><br><span class="line">let person = &#123;</span><br><span class="line">	[methodKey](name)&#123;</span><br><span class="line">		alert(&quot;aaa &quot;+name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName(&quot;john&quot;)		//aaa john</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h4><ol>
<li>ES6新增了Object.assign()方法用于合并对象。接受一个目标对象和一个多源对象作为参数，然后将每个源对象中可枚举和自由属性赋值到目标函数。<ol>
<li>这是一种浅拷贝，如果多个源对象有相同的属性，则使用最后一个。此外，从源对象访问器属性中取得的值，比如获取函数，会作为一个静态值赋值给目标对象。如果赋值期间出错，则操作会终止并退出，同时抛出错误。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>前提：使用Object构造函数创建多个有相同接口的对象会比较麻烦。ES6开始正式支持类和继承。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单来说，就是把创建Object对象的过程封装到函数中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 	createPerson（name,age,job）&#123;</span><br><span class="line">	let 0 = new Object</span><br><span class="line">	o.name = name</span><br><span class="line">	o.age = age</span><br><span class="line">	o.job = job</span><br><span class="line">	o.sayName = function()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">	return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = cretePerson(&quot;jianhuo&quot;,19,&quot;geiyepa&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ol>
<li><h5 id="跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。"><a href="#跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。" class="headerlink" title="跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。"></a>跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。</h5><ol>
<li>没有显示地创建对象</li>
<li>属性和方法直接赋值给this</li>
<li>没有return</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 	createPerson（name,age,job）&#123;</span><br><span class="line">	this.name = name</span><br><span class="line">	this.age = age</span><br><span class="line">	this.job = job</span><br><span class="line">	this.sayName = function()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = cretePerson(&quot;jianhuo&quot;,19,&quot;geiyepa&quot;)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的"><a href="#按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的" class="headerlink" title="按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的"></a>按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的</h5></li>
<li><h5 id="要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作"><a href="#要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作" class="headerlink" title="要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作"></a>要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作</h5><ol>
<li>在内存中创建一个新对象</li>
<li>在这个新对象的内部的[[Prototype]]特性被赋值为构造函数的prototype属性</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则返回创建的新对象</li>
</ol>
</li>
<li><h5 id="构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数"><a href="#构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数" class="headerlink" title="构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数"></a>构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数</h5></li>
<li><h5 id="如果不想传参数，那么new的时候后面的括号可以不加。"><a href="#如果不想传参数，那么new的时候后面的括号可以不加。" class="headerlink" title="如果不想传参数，那么new的时候后面的括号可以不加。"></a>如果不想传参数，那么new的时候后面的括号可以不加。</h5></li>
<li><h5 id="构造函数也是函数，和普通函数的唯一区别是调用方式的不同。"><a href="#构造函数也是函数，和普通函数的唯一区别是调用方式的不同。" class="headerlink" title="构造函数也是函数，和普通函数的唯一区别是调用方式的不同。"></a>构造函数也是函数，和普通函数的唯一区别是调用方式的不同。</h5><ol>
<li>使用new操作符调用就是构造函数，不使用new操作符调用就是普通函数</li>
</ol>
</li>
<li><h5 id="构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。"><a href="#构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。" class="headerlink" title="构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。"></a>构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。</h5><ol>
<li>要解决这个问题，可以把函数定义转移到构造函数外面。</li>
</ol>
</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ol>
<li><h4 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h4><ol>
<li>可以看成JavaScript版的继承</li>
<li>只要创建函数，就会为其创建一个prototype属性（指向原型对象）</li>
<li>默认情况下，所有原型对象自动获得一个名为constructor的属性，只会函数本身。</li>
</ol>
</li>
<li><h4 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h4><ol>
<li>再通过对象访问属性是，会按照这个属性的名称开始搜索。顺着原型链一直向上查找，直到object’原型，也就是null。</li>
<li>这就是原型用于多个对象实例间共享属性和方法的原理。</li>
<li>虽然可以通过实例读取原型对象的值，但是不可以通过实例重写这些值。</li>
<li>如果在实例上添加一个与原型对象中同名的属性，那就会再实例上创建这个属性，这个属性会遮住原型对象上的对应属性。（优先级比原型链上的同名属性高）<ol>
<li>即时实例上的属性设置为null，依然会屏蔽，但是使用delete操作符删除属性可以回复。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h4><ol>
<li>有两种方式使用in操作符<ol>
<li>使用for。。。in循环</li>
<li>单独使用<ol>
<li>in操作符会在可以通过对象访问到指定属性时候返回true（包括原型链上的同名属性）</li>
</ol>
</li>
<li>如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()</li>
<li>使用Object.keys()可以获取实例上的属性</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h4><ol>
<li>for-in循环和Object,keys()枚举顺序是不确定的。</li>
<li>Object.getOwnPropertyNames(), Object.getOwnPropertySymbols和Object.assign()的枚举顺序是确定的。</li>
</ol>
</li>
<li><p>每个函数都会创建一个prototype属性，包含应该有特定应用类型的实例共享的属性和方法。实际上这个对象就是通过调用构造函数创建对象的原型。</p>
<ol>
<li>使用原型对象的好处是，再它上面定义的属性和方法可以被对象实例共享。原来再构造函数中直接赋给对象实例的值，可以直接赋值给他们的原型。</li>
</ol>
</li>
<li><p>与构造函数模式不同，使用这种原型模式定义的属性和方法是有所有实例共享的。</p>
</li>
</ol>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><ol>
<li><h4 id="迭代对象属性是一个JavaScript存在已久的难题。"><a href="#迭代对象属性是一个JavaScript存在已久的难题。" class="headerlink" title="迭代对象属性是一个JavaScript存在已久的难题。"></a>迭代对象属性是一个JavaScript存在已久的难题。</h4></li>
<li><p>ES7新增了两个静态的方法，用于将对象内容转换为序列化的——更重要的是可迭代的格式。</p>
<ol>
<li>Object.values()接受一个对象，返回对象值的数组</li>
<li>Object,entires()接受一个对象，返回对象键值对的数组，如[[“aaa”,”bbb”],[“bbb”,”ccc”]]</li>
<li>非字符串会被转化为字符输出，符号属性（symbol）会被忽略</li>
</ol>
</li>
<li><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><ol>
<li>因为从原型上搜索值的过程是动态的，所以即时实例在修改原型前就已经存在，任何时候对原型的修改也会在实例上反映出来<ol>
<li>主要原因是实例和原型的松散联系，实例和原型之间的链接就是简单的指针，而不是保存副本。</li>
<li>虽然随时都能给原型添加属性和方法，并能够立即反映到所有对象实例上，但是这跟重写整个原型是不一样的。实例的[[prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用仍然时最初的原型。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h4><ol>
<li>弱化了想构造函数传递初始化参数的能力，会导致所有实例默认取得相同的属性值。</li>
<li>原型上所有属性都是在实例中共享的。如果这个属性是对象，那么某个实例上对于对象的修改会影响所有实例。</li>
</ol>
</li>
<li><h4 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h4><ol>
<li>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。</li>
</ol>
</li>
<li><h4 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h4><ol>
<li>为了减少代码冗余，也为了美观，直接通过一个包含所有属性和方法的对象字面量来重写原型。</li>
<li>但是这样重写原型会导致constructor属性丢失，从而默认指向Object构造函数<ol>
<li>解决办法一：<ol>
<li>重写时候添加一句constructor:xxx重新指定但是这种方法设置的constructor属性是可枚举的，而默认的此属性是不可枚举的。</li>
</ol>
</li>
<li>解决办法二：<ol>
<li>使用Object.defineProPerty()方法定义constructor属性</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name:&quot;jianhuo&quot;,</span><br><span class="line">	age:21,</span><br><span class="line">	job:&quot;geiyepa&quot;,</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(&quot;gunyuandian&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name:&quot;jianhuo&quot;,</span><br><span class="line">	age:21,</span><br><span class="line">	job:&quot;geiyepa&quot;,</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(&quot;gunyuandian&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//回复constructor属性</span><br><span class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;, &#123;</span><br><span class="line">	enumerable:false,</span><br><span class="line">	value:Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记08继承</title>
    <url>/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>很多面向对象语言都支持两种继承：接口继承和实现继承。JavaScript只支持实现继承，而且是通过原型链方式继承的。这里介绍JavaScript中实现继承的7种方式（新增class方式继承）。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链继承的基本思想是通过原型继承多个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.far=<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.getFar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.far</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.child=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()	<span class="comment">//原型继承father实例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">alert(a.getFar())	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>本质：</p>
<ul>
<li>通过重写子类型的原型对象实现继承</li>
<li>注：原型对象中包含constructor属性一般指回子类型函数本身，重写子类型的原型对象会导致constructor属性丢失。</li>
<li>最终原型链为：a-&gt;child-&gt;father-&gt;Object（所有函数的默认原型）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>父级的实例属性会被子级共享</li>
<li>子级不能向父级传递参数</li>
</ul>
</li>
<li><p>原型与继承的关系</p>
<ol>
<li><p>使用instanceof操作符确定</p>
<ul>
<li><p>如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用isPrototypeOf()方法。</p>
<ul>
<li><p>只要原型链包含这个原型，就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>原型链的问题</p>
<ol>
<li>原型中包含的引用值会在所有实例间共享。在使用原型实现继承时，原型实际上变成了另一个类型实例。</li>
<li>重写子类型对象后，constructor属性会丢失。</li>
</ol>
</li>
<li><p>关于方法</p>
<ol>
<li>子类有些时候需要覆盖父类的方法，或者增设父类没有的方法。为此，有些方法必须在原型复制后再添加到原型上。</li>
<li>如果以对象字面量的方式创建原型会破坏原型链，因为这相当于重写了原型链。</li>
</ol>
</li>
</ol>
<h2 id="借用构造函数继承（经典继承）"><a href="#借用构造函数继承（经典继承）" class="headerlink" title="借用构造函数继承（经典继承）"></a>借用构造函数继承（经典继承）</h2><p>为了解决原型链继承中共享的问题，基本思路是：在子类构造函数中调用父类构造函数。因为函数就是特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新建的对象为上下文执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过call/apply方法，在子类型构造函数内部调用超类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">child</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;aa&quot;</span></span><br><span class="line">	<span class="comment">//打印来自子级的参数</span></span><br><span class="line">	<span class="built_in">console</span>.log(child.name)	<span class="comment">//jojo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	father.apply(<span class="built_in">this</span>,[&#123;<span class="attr">name</span>:<span class="string">&quot;jojo&quot;</span>&#125;])	<span class="comment">//继承，可以传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">alert(a.name)		<span class="comment">//aa</span></span><br></pre></td></tr></table></figure>

<ol>
<li>优点：<ul>
<li>解决了原型链继承中所有属性都会暴露和子级不能向父级传参的问题。</li>
<li>可以在子类构造函数中向父级构造函数传参</li>
</ul>
</li>
<li>缺点：<ul>
<li>必须在构造函数中定义方法，因此函数不能复用</li>
<li>父级的方法对于子级不可见</li>
</ul>
</li>
</ol>
<h1 id="组合继承-伪经典继承"><a href="#组合继承-伪经典继承" class="headerlink" title="组合继承(伪经典继承)"></a>组合继承(伪经典继承)</h1><p>JavaScript中最常见的继承模式，使用instanceof操作符和isPrototype()方法可用于识别基于组合继承的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借用构造函数继承实例属性，原型链继承来继承原型上的方法和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;jojo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">funciton <span class="function"><span class="title">child</span>(<span class="params"></span>)</span>&#123;		<span class="comment">//借用构造函数继承属性</span></span><br><span class="line">	father.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()	<span class="comment">//原型链继承，注意！重写原型导致constructors属性丢失</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">a.sayName()</span><br></pre></td></tr></table></figure>

<ol>
<li>本质：<ul>
<li>使用原型链继承来继承原型上的属性和方法，用组合继承来继承实例属性。这样既可以把方法定义在原型上实现复用，又可以让每个实例都有自己的属性。</li>
</ul>
</li>
<li>优点：<ul>
<li>综合了原型链和借用构造继承的优点</li>
</ul>
</li>
<li>缺点：<ul>
<li>必会调用两次超类型构造函数，一次在创建子类型的原型时，另一次在子类型构造函数内部。</li>
</ul>
</li>
</ol>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种实现方法</span></span><br><span class="line"><span class="comment">//1.自定义函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ob</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	f.prototype.name = <span class="string">&quot;jojo&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ob()</span><br><span class="line"><span class="built_in">console</span>.log(a.name)	<span class="comment">//jojo</span></span><br><span class="line"><span class="comment">//2.使用Object.create方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;jojo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">		<span class="attr">value</span>:<span class="string">&quot;giogio&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">alert(a.name)	<span class="comment">//giogio</span></span><br></pre></td></tr></table></figure>

<ol>
<li>本质：<ul>
<li>ob()式对传入的对象执行了一次浅复制。</li>
</ul>
</li>
<li>优点：<ul>
<li>原型式继承非常适合不需要单独创建构造函数，但是任然需要在对象间共享信息的场合。</li>
</ul>
</li>
<li>缺点：<ul>
<li>和原型链继承一样，属性中包含的引用值会始终在相关的对象间共享。</li>
</ul>
</li>
</ol>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(name)</span><br><span class="line">	clone.sayGood=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wiw = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">	<span class="attr">act</span>:<span class="string">&quot;stand&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> final = father(wiw)	<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line">final.sayGood()</span><br></pre></td></tr></table></figure>

<ol>
<li>本质:<ul>
<li>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</li>
</ul>
</li>
<li>优点：<ul>
<li>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。</li>
</ul>
</li>
<li>缺点:<ul>
<li>通过寄生式继承给对象添加函数会导致函数难以重用。</li>
</ul>
</li>
</ol>
<h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>可以算是应用类型继承的最佳模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	father.call(<span class="built_in">this</span>,name)					<span class="comment">//借用构造函数继承元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(father.prototype)		<span class="comment">//寄生式构造父级原型</span></span><br><span class="line">a.constructor = child						<span class="comment">//重新赋值constructor</span></span><br><span class="line">child.prototype = a</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> child(<span class="string">&quot;jojo&quot;</span>)</span><br><span class="line">b.sayName()		<span class="comment">//jojo</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>本质：</p>
<ul>
<li><p>这个函数实现了接受两个参数：子类构造函数和父类构造函数。</p>
<ul>
<li>在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype对象设置constructor属性，解决由于重写原型导致的默认constructor丢失问题。最后将新创建的对象赋值给子类型原型。</li>
</ul>
</li>
<li><p>寄生式组合继承通过借用构造函数继承属性，但是用混合式原型链继承方法。基本思路就是不通过调用父类构造函数给子类函数原型赋值，而是取得一个父类的副本。</p>
<ul>
<li>说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h2><ol>
<li><p>ES6中的Class可以看作是一个语法糖，他的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰，更加面向对象编程的语法而已。</p>
</li>
<li><p>类和模块的内部默认使用严格模式，所以不需要使用 use strict 指定运行模式。只要将代码写在类或模块之中，那么就只有严格模式可用。</p>
</li>
<li><p>constructor 方法是类的默认方法，通过 new 命令生成对象实例时自动调用该方法。一个类必须有 constructor 方法，如果没有显示定义，一个空的 constructor 方法会被默认添加。</p>
</li>
<li><p>类必须使用 new 来调用，否则就会报错。</p>
</li>
<li><p>实例的属性除非显示定义在其本身（即 this 对象）上，否则都是定义在原型（即 Class ）上。</p>
</li>
<li><p>类的实例共享一个原型对象。</p>
</li>
<li><p>Class表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// =&gt;Class也可以使用表达式的形式定义。</span></span><br><span class="line"><span class="comment">// =&gt;注意这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指当前类。</span></span><br><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类不存在变量提升</p>
</li>
<li><p>ES6不提供私有方法，不支持私有属性。目前有一个提案为class加私有属性。方法是在属性名前，使用#来表示。</p>
<p>（现在支持私有属性和方法了！<strong>使用方法，在constructor之前定义用 # 私有属性，再在constructor中用this.#私有属性进行引用</strong>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有属性测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// 声明</span></span><br><span class="line">  #id</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="comment">/// 赋值</span></span><br><span class="line">    <span class="built_in">this</span>.#id = <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getUserId</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.#id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="string">&#x27;Todd Motto&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user.id); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(user.getUserId()); <span class="comment">// xyz</span></span><br></pre></td></tr></table></figure></li>
<li><p>类的方法内部如果含有 this，它将默认指向类的实例。</p>
</li>
<li><p>name 属性返回 class 后面的类名。</p>
</li>
<li><p>在类的内部可以使用 get 和 set 关键字对某个属性设置存储函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">prop</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;setter&#x27;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inst=<span class="keyword">new</span> MyClass();</span><br><span class="line">inst.prop=<span class="number">123</span>; <span class="comment">// =&gt;setter123</span></span><br><span class="line"><span class="built_in">console</span>.log(inst.prop); <span class="comment">// =&gt;getter</span></span><br></pre></td></tr></table></figure></li>
<li><p>类相当于实例中的原型，所有在类中定义的方法都会被实例继承。如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类调用，称之为“静态方法”。（父类的静态方法可以被子类继承）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.classMethod()); <span class="comment">// =&gt;hello</span></span><br><span class="line"><span class="keyword">let</span> foo=<span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod(); <span class="comment">// =&gt;Uncaught TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure></li>
<li><p>class的静态属性只要在实例属性写法前面加上static关键字就可以了。</p>
</li>
</ol>
<h3 id="class继承中的super"><a href="#class继承中的super" class="headerlink" title="class继承中的super"></a>class继承中的super</h3><p>由于采用了新的语法糖实现继承，class继承方式也更加直观易用。但是其中的super()函数有点不太好理解。</p>
<p>ES6中class可以通过extends关键字实现继承，但同时需要在子类的constructor方法中添加super方法，否则在子类新建实例后调用父类属性或方法的时候会报错。</p>
<p>这是因为子类自己的this对象，需要先通过父类的构造函数完成构造，得到父类的实例属性和方法后再进行自己的构造函数进行构造。而super()可以看作是一个指向离这个类最近的父类的指针函数，通过调用这个函数，子类就可以获得来自父类的实例属性和方法，从而实现继承，从这里可以看出，super()是实现继承的重要一环。</p>
<h4 id="super的用法"><a href="#super的用法" class="headerlink" title="super的用法"></a>super的用法</h4><h6 id="super是一个比较特殊的JavaScript关键词，它可以有不同的用法"><a href="#super是一个比较特殊的JavaScript关键词，它可以有不同的用法" class="headerlink" title="super是一个比较特殊的JavaScript关键词，它可以有不同的用法"></a>super是一个比较特殊的JavaScript关键词，它可以有不同的用法</h6><ol>
<li><p>super方法</p>
<p>当super作为函数调用的时候，代表父类的构造函数。</p>
<p>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">A.prototype.constructor.call(<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure>

<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
</li>
<li><p>super对象</p>
<p>super作为对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记10代理与反射</title>
    <url>/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><ol>
<li><h4 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h4><ul>
<li><p>代理是目标对象的抽象。目标对象既可以直接被操作，也可以通过代理来操作。但是直接操作会绕过代理施予的行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;lihua&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...args)+<span class="string">&quot;好耶！&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">//lihua好耶！</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name)	<span class="comment">//lihua</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h4><ul>
<li>在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</li>
</ul>
</li>
<li><h4 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h4><ul>
<li>使用代理的主要原因是可以定义捕获器。每个处理程序对象都可以包含多个捕获器，每个捕获器对应一种基本操作，可以直接或间接在代理对象上调用。</li>
<li>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前像调用捕获器函数，从而实现拦截并修改相应的行为。</li>
<li>例如，可以定一一个get()捕获器，JavaScript操作以某种形式调用get()时触发。所有这些操作只要发生在代理对象上，就会触发get()捕获器</li>
<li>注意，只有在代理对象上，就会触发。</li>
</ul>
</li>
<li><h4 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h4><ul>
<li><p>所有捕获器都可以访问响应的参数面积与这些参数可以重建被捕获的方法的原始行为。</p>
</li>
<li><p>通过调用全局Reflect对象上（封装了原始行为）的同名方法来轻松重建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;lihua&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...args)+<span class="string">&quot;好耶！&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h4><ul>
<li>代理可以捕获13种不同的基本操作</li>
</ul>
</li>
<li><h4 id="代理的问题和不足"><a href="#代理的问题和不足" class="headerlink" title="代理的问题和不足"></a>代理的问题和不足</h4><ul>
<li>proxy的prototype是undefined，因此不能使用instanceof操作符</li>
</ul>
</li>
<li><h4 id="使用反射API"><a href="#使用反射API" class="headerlink" title="使用反射API"></a>使用反射API</h4><ul>
<li>某些情况下应该优先使用反射API，这些是有一些理由的。</li>
<li>反射API与对象API<ul>
<li>反射API并不限于捕获处理程序</li>
<li>大多数反射API方法在Object类型上对应的方法</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h4><ul>
<li><p>有时候可能需要中断代理对象与目标对象的联系。对于使用new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一致存在。</p>
</li>
<li><p>Proxy也暴露了revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数是幂等的，调用多少次结构都是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;lihua&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(obj,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...args)+<span class="string">&quot;好耶！&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">//lihua好耶！</span></span><br><span class="line">	</span><br><span class="line">revoke()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)<span class="comment">//TypeError,代理已经撤销</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><ul>
<li>目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时会报错。</li>
</ul>
</li>
<li><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4></li>
</ol>
<ul>
<li><p>跟踪属性访问</p>
<p>通过捕获器的get,set和has等操作，可以知道对象属性什么时候被访问、被查询。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;lihua&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(obj,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(args)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...args)</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(args)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...args)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">proxy.name</span><br><span class="line">proxy.age = <span class="number">17</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记09类</title>
    <url>/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li><h5 id="ES6支持单继承。使用extends关键字，就可以继承任何拥有-Construct-和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）"><a href="#ES6支持单继承。使用extends关键字，就可以继承任何拥有-Construct-和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）" class="headerlink" title="ES6支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）"></a>ES6支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承普通构造函数	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> ()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">let</span> <span class="title">e</span> </span>= <span class="keyword">new</span> Engineer ()</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类："><a href="#派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类：" class="headerlink" title="派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类："></a>派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">identifyPrototype</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(id,<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">identifyClass</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(id,<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vehicle()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus()</span><br><span class="line"></span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>)</span><br><span class="line">v.identifyPrototype(<span class="string">&#x27;vehicle&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>)</span><br><span class="line">Vehicle. identifyClass(<span class="string">&#x27;vehicle&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><ol>
<li><h5 id="定义类有两种方式"><a href="#定义类有两种方式" class="headerlink" title="定义类有两种方式"></a>定义类有两种方式</h5><ol>
<li>类声明<ul>
<li>class Person {} 类声明不能提升</li>
</ul>
</li>
<li>类表达式<ul>
<li>const a = class {}</li>
</ul>
</li>
<li>函数收到作用域限制，类收到块作用域限制。</li>
</ol>
</li>
<li><h5 id="JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）"><a href="#JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）" class="headerlink" title="JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）"></a>JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）</h5><ul>
<li>ES6引入了class关键字具有正式定义类的能力。类（class）是ES6中新的基础性语法糖结构。虽然这个类表面上支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。</li>
</ul>
</li>
<li><h5 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h5><ul>
<li>类可以包含构造函数方法、实例方法、获取函数、设置函数、静态类的方法。但是不是必须的，空类也是有效的。</li>
<li>类表达式的名称是可选的。在把类表达式赋值给变量之后，可以通过name属性访问类表达式的名称字符串。但是不能在类表达式作用域外部访问这个标识符。</li>
</ul>
</li>
</ol>
<h1 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h1><p>constructor关键字用于在类定义块内部创建类的构造函数。构造函数的定义不是必须的。</p>
<ol>
<li><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><ul>
<li>使用new操作符实例化Person的操作等于使用new调用其构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使用new和类意味着应该使用constructor函数进行实例化。</li>
<li>使用new调用类的构造函数会执行如下操作。(类实例化时传入的参数会用作构造函数的参数，如过不需要参数，则类名后面的括号也是可选的)<ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象的内部[[prototypr]]指针被赋值为constructor构造函数的prototypr属性。</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ol>
</li>
<li>默认情况下，类构造函数会在执行之后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有什么引用新创建的对象，那么这个对象就会被销毁。不过，如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针没有被修改。</li>
<li>类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，否则会报错。普通构造函数直接调用，则会以全局对象作为this。</li>
</ul>
</li>
<li><h5 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h5><ol>
<li>ECMAScript中没有正式的类这个类型，从各个方面来看，类就是一种特殊的函数</li>
<li>在类上下文中，类本身在使用new调用时就会被当作构造函数。重点在于，类定义中的constructor方法不会被当成构造函数，在对他使用instanceof操作符时会返回false。但是，如果在创建实例时直接将类构造函数方程普通构造函数来使用，那么instanceof操作符的返回值会反转。</li>
<li>可以向其他对象或者函数引用一样把类作为参数传递，也可以立即实例化。</li>
</ol>
</li>
</ol>
<h1 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h1><ol>
<li><h5 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h5><ol>
<li>每次通过new调用类识别符，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加自有属性。至于添加怎么样的属性，没有限制。另外，在构造函数执行完毕之后，仍然可以给实例添加新的成员。</li>
<li>所有成员都不会在原型上共享</li>
</ol>
</li>
<li><h5 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h5><ol>
<li>为了在实例间共享方法，类定义语法把类块中定义的方法作为原型方法。</li>
<li>可以把方法定义在类构造函数中或者类块中，但是不能在类块中给原型添加原始值或对象作为成员数据。</li>
<li>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键。</li>
<li>类定义也支持获取和设置访问器。语法与行为跟普通对象一样。</li>
</ol>
</li>
<li><h5 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h5><ol>
<li>类定义语法支持在原型和类本身上定义生成器的方法</li>
<li>因为支持生成器方法，所以可以通过添加一个默认的迭代器，八十例变成可迭代对象。</li>
<li>也可以只返回迭代器实例。</li>
</ol>
</li>
<li><h5 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h5><ul>
<li>虽然类定义不显示支持在原型或类上添加成员数据，但在类定义外部，可以手动添加。</li>
</ul>
</li>
<li><h5 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h5><ol>
<li>可以在类上定义静态方法。这些方法通常用于执行不特定与实例的操作，也不要求存在类的实例。</li>
<li>类静态成员每一个类上只能有一个</li>
<li>静态类成员在类定义中使用static关键字作为前缀。在静态成员中，this引用类自身。其他所有约定和原型成员一样。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记11函数</title>
    <url>/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定余函数本身紧密绑定</li>
<li>创建函数的方式和区别<ul>
<li>函数表达式 var foo = function() {…}<ul>
<li>只有在JavaScript语句执行到这句话的之后才会创建函数。在这之前调用函数会报错。（没有提升）</li>
</ul>
</li>
<li>函数声明 function foo() {…}<ul>
<li>在JavaScript编译的时候函数声明会被提前，也就是说可以先调用函数再在下面声明函数</li>
</ul>
</li>
</ul>
</li>
<li>箭头函数<ul>
<li>箭头函数是使用胖箭头(=&gt;)语法定义函数表达式的能力。</li>
<li>标准写法是 let a = (x) =&gt; {…}</li>
<li>如果函数只有一条语句的话，可以不要大括号，但是函数会默认将这一句话当成返回值；只有一个参数的时候也可以没有前一个括号</li>
</ul>
</li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ol>
<li><p>闭包是指哪些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparison</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> val1 = obj1[name]</span><br><span class="line">		<span class="keyword">let</span> val2 = obj2[name]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(val1&gt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compare  = createComparison(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123;<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;pa&quot;</span>&#125;)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个例子中的val1和val2引用了来自函数外的变量，在这个内部的匿名函数被返回并在其他的地方使用后，它仍然引用着那个变量。这是因为内部函数的作用域包含createComparison()函数的作用域。</li>
</ul>
</li>
<li><p>在调用一个函数的时候，会为这个函数创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动独享。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域一直向外串起了所有包含函数的活动对象，直到全局上下文才终止。</p>
</li>
<li><p>函数执行的时候，每个执行上下文都会有一个包含其中变量的对象。全局上下文中的叫变量对象，他会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，指在函数执行期间存在。</p>
<ul>
<li>函数内部的代码在访问变量时，就会使用给定的名称从作用域中查找变量。函数执行完毕后，局部活动对象会被摧毁。只剩下全局作用域。但是在闭包中就不一样了。</li>
</ul>
</li>
<li><p>注意：因为闭包会保留他们包含的函数作用域，因此会比其他函数更占用内存，所以要谨慎使用。</p>
</li>
<li><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到子自己的作用域链中。导致在外部函数被销毁时外部函数的活动对象由于仍然被引用，所以不能销毁。就产生了闭包。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记13JSON</title>
    <url>/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013JSON/</url>
    <content><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ol>
<li>理解JSON最关键的一点就是要把它当成一种数据格式而不是编程语言</li>
<li>语法<ol>
<li>JSON语法支持三种类型的值<ul>
<li>简单值（字符串，数值，布尔值，null，都可以在JSON中出现，undefined不可以）</li>
<li>对象</li>
<li>数组</li>
</ul>
</li>
<li>JSON没有变量、函数或对象实例的概念。JSON的所有记号都只为标识结构化数据，虽然它借用了JavaScript的语法。</li>
</ol>
</li>
<li>解析与序列化<ul>
<li>JSON可以直接被解析为可用的JavaScript对象，与解析为DOM文档的XML相比，这个优势非常明显。为此，JavaScript开发者可以非常方便第使用JSON数据。</li>
</ul>
</li>
<li>序列化选项<ul>
<li>stringify()<ul>
<li>过滤结果<ul>
<li>如果第二个参数是一个数组，那么JSON.stringify()返回的结果只会包含该数组中列出的对象属性</li>
<li>如果第二个参数是一个函数，提供的函数接受两个参数：属性名(key)和属性值(value)，可以根据这个key决定要对应属性做什么。<ul>
<li>函数过滤器会应用到要序列化对象所包含的全部对象。</li>
</ul>
</li>
</ul>
</li>
<li>字符串缩进<ul>
<li>第三个参数可以控制缩进和空格<ul>
<li>是数值是，表示缩进空格数</li>
<li>是字符串时，表示要填充到每一行开头的字符串</li>
<li>无论时那种，最大不超过10个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>简单值<ul>
<li>JavaScript字符串与JSON字符串的主要区别就是JSON字符串必须使用双引号（单引号会导致语法错误）</li>
</ul>
</li>
<li>对象<ul>
<li>有两处不同<ul>
<li>JSON没有变量声明（JSON没有变量）</li>
<li>最后没有分号（不需要，因为不是JavaScript语句）</li>
</ul>
</li>
<li>同样，用引号将属性名包围起来才是有效的JSON。</li>
</ul>
</li>
<li>数组<ul>
<li>和对象差不多</li>
</ul>
</li>
<li>JSON对象<ol>
<li>因为JSON时JavaScript语法的子集，所以eval()可以解析、解释并将其作为JavaScript对象和数组返回。</li>
<li>JSON对象<ul>
<li>Stringify()<ul>
<li>将JavaScript序列化为JSON字符串</li>
</ul>
</li>
<li>parse()<ul>
<li>将JSON解析为原生JavaScript值</li>
</ul>
</li>
</ul>
</li>
<li>扩展<ul>
<li>JSON.Stringify(JSON.parse(str))可以实现深复制对象。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记12异步编程</title>
    <url>/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Promise-期约"><a href="#Promise-期约" class="headerlink" title="Promise(期约)"></a>Promise(期约)</h1><ol>
<li><h4 id="promise基础"><a href="#promise基础" class="headerlink" title="promise基础"></a>promise基础</h4><ul>
<li>可以通过new 操作符来实例化一个promise对象。创建新期约的时候需要传入执行器（executor）函数作为参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p)	<span class="comment">//Promise&lt;pending&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="期约状态机"><a href="#期约状态机" class="headerlink" title="期约状态机"></a>期约状态机</h4><ol>
<li>Peomise是一个有状态的对象，可能处于三种状态<ul>
<li>待定（pedding）</li>
<li>兑现（fulfilled），有时也叫解决，（resolved）</li>
<li>拒绝（rejected）</li>
</ul>
</li>
<li>待定（pending）是promise的初始状态，可以转换为另外两种状态，并且一旦转换就不可逆。</li>
<li>另外，promise的状态也不能不被外部的JavaScript代码修改，也不能被外界读取（私有）。</li>
</ol>
</li>
<li><h4 id="解决值、拒绝理由及期约用例"><a href="#解决值、拒绝理由及期约用例" class="headerlink" title="解决值、拒绝理由及期约用例"></a>解决值、拒绝理由及期约用例</h4><ul>
<li>promise的用途是，抽象的标识一个异步操作，并且通知这个操作是否完成</li>
<li>一些情况下，promise封装的异步操作会实际生成某个值，而程序期待promise状态改变的时候可以访问这个值。例如，如果请求范围为200-299的状态码，让promise状态转化为resolved，并且内部可以接受到一个JSON字符串。拒绝同理，只是接受的变成一个拒绝理由。</li>
<li>为了支持这种用例，promise每次转换状态，就会有一个私有的内部值或理由。二者都是可选的，并且默认为undefined。</li>
</ul>
</li>
<li><h4 id="同步-异步执行的二元性"><a href="#同步-异步执行的二元性" class="headerlink" title="同步/异步执行的二元性"></a>同步/异步执行的二元性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)	<span class="comment">//Error:foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Uncaught (in Promise) Error:bar</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子报错的原因是：try。。。catch捕获的是哦同步执行时抛出的错误，因此第一个错误可以捕获，但是第二个Promise中抛出的异常是以异步模式进行的，因此没有捕获。</li>
<li>这个例子中可以看出promise的真正异步特性:他们时同步对象（在同步中执行使用），但是也是异步执行的媒介</li>
<li>代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体的说，就是promise方法。</li>
</ul>
</li>
<li><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><ul>
<li>通过调用一个Promise.resolve()方法，可以实例化一个已处于解决状态的promise。</li>
<li>使用这个方法实际上可以把任何值转化为一个promise</li>
<li>这是一个幂等的方法，即嵌套调用多少次结果都一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p===<span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)))		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，这样会把抛出的错误都包装到已解决的promise中。</li>
</ul>
</li>
<li><h4 id="Promise-rejected"><a href="#Promise-rejected" class="headerlink" title="Promise.rejected()"></a>Promise.rejected()</h4><ul>
<li>和resolved类似，但是不是幂等的，给他传入一个resolve会把这个promise包装成拒绝理由。</li>
</ul>
</li>
<li><h4 id="通过执行函数控制promise状态"><a href="#通过执行函数控制promise状态" class="headerlink" title="通过执行函数控制promise状态"></a>通过执行函数控制promise状态</h4><ul>
<li>由于promise状态是私有的，所以只能在内部进行操作。内部操作在promise的执行器函数中完成。</li>
<li>执行器的两个职责<ul>
<li>初始化promise的异步行为</li>
<li>控制状态的最终转换<ul>
<li>转换是通过调用它的两个函数参数实现的<ul>
<li>reslove()</li>
<li>reject()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>执行器函数是同步执行的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//executor</span></span><br><span class="line"><span class="comment">//promise initialized</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加setTimeout可以推迟切换状态：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve,<span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p)</span><br></pre></td></tr></table></figure>

<ul>
<li>再次强调，promise的状态只能改变一次，且不可逆。任何在状态改变后视图再次改变状态的操作都会无效。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记14网络请求</title>
    <url>/2021/12/23/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p>Fetch API能够执行XHR对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等陷害Web工具中使用。不同之处在于XHR可以选择同步或异步，但是Fetch API只能选择异步。</p>
<ul>
<li><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>fetch()方法是暴露在全局作用域中的</li>
</ul>
</li>
<li><h4 id="分派请求"><a href="#分派请求" class="headerlink" title="分派请求"></a>分派请求</h4><ul>
<li>fetch()只有一个必须参数input，作为请求URL，这个方法返回一个promise，这个对象是API的封装，可以通过他获取响应的资源。<ul>
<li>在只有一个参数的情况下，默认执行get方法</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="读取响应"><a href="#读取响应" class="headerlink" title="读取响应"></a>读取响应</h4><ul>
<li>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。这个方法返回一个promise，会决议为取得资源的完整内容。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://api.it120.cc/MartinGarrixForTest/mock/data/getMsg&#x27;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><h4 id="处理状态码和请求失败"><a href="#处理状态码和请求失败" class="headerlink" title="处理状态码和请求失败"></a>处理状态码和请求失败</h4><ul>
<li>Fetch API支持通过Response的状态码和状态文本属性检查响应状态。<ul>
<li>由于无论返回的响应式多少，只要返回了响应，那么promise都会决议为resolved状态，这在逻辑上是合理的，所以我们还要在已决议的promise中再去判断状态码，从而执行不同的操作。</li>
<li>注意，如果服务器未响应导致浏览器超时，不符合的跨域请求都会导致fetch（）失败，从而导致promise决议为rejected。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h4><ol>
<li>body<ul>
<li>用于指定使用请求体的内容</li>
</ul>
</li>
<li>credentials<ul>
<li>用于指定在外发请求中包含cookie</li>
</ul>
</li>
<li>method<ul>
<li>用于指定HTTP请求方法</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h4><ul>
<li>顾名思义，Request对象就是获取资源请求接口</li>
<li>创建Request对象<ol>
<li>可以通过构造函数初始化Requset对象，为此需要传入一个input，一般是URL</li>
<li>已接受第二个参数，和fetch()一样</li>
<li>复制request对象，使用clone方法复制，这样不会请求标记为已使用。</li>
<li>在fetch()中使用Request对象，在调用fetch()时，可以传入一创建好的Request实例。</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h4><ul>
<li>headers对象时所有外法请求和入栈响应头部的容器。每个外发的Request实例都包含一个空的Header实例，可以通过Request.prototype.headers访问，每一个入栈的Respone实例也一样。</li>
<li>Headers对象与Map的相似之处<ul>
<li>都有get，set，has和delete</li>
</ul>
</li>
<li>Headers的独特之处<ul>
<li>可以使用键值对的形式初始化Headers对象，Map不行。</li>
</ul>
</li>
<li>头部护卫<ul>
<li>不是所有头部都可以被客户端修改</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="常见的Fetch请求模式"><a href="#常见的Fetch请求模式" class="headerlink" title="常见的Fetch请求模式"></a>常见的Fetch请求模式</h4><ul>
<li><p>发送JSON数据</p>
</li>
<li><p>在请求体中发送参数</p>
<ul>
<li>因为请求体支持任意字符串值，所以可以通过它发送请求参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> param = <span class="string">&#x27;username=admin&amp;pwd=admin&amp;deviceId=1&amp;deviceName=1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> paramHearders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">		<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">fetch(<span class="string">&#x27;https://api.it120.cc/MartinGarrixForTest/user/username/login&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">	<span class="attr">body</span>:param,</span><br><span class="line">	<span class="attr">headers</span>:paramHearders</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>发送文件</p>
<ul>
<li>因为请求体支持FormData实现，所以fetch()也可以序列化并发送文件字段中的文字件。</li>
</ul>
</li>
<li><p>加载blob文件（重点！！）</p>
<ul>
<li>Fetch API也能提供Blob类型的响应，而blob又可以兼容多种浏览器API</li>
</ul>
</li>
<li><p>发送跨域请求</p>
<ul>
<li>从不同的源请求资源，响应要包含CORS头部才能保证浏览器收到响应。没有这些头部，跨域请求会失败。</li>
</ul>
</li>
<li><p>中断请求</p>
<ul>
<li>调用AbortController.abort()会中断所有网络传输。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><ul>
<li><p>Web Socket的目标是通过一个长时间链接实现与服务器全双工、双向的通信（持久化推送消息）。在JavaScript中创建WebSocket时，一个HTTP请求会发送到服务器以初始化链接。服务器响应后，链接使用HTTP的Upgrade头部从HTTP协议切换到web Socket协议。这意味着web Socket不能通过标准的HTTP服务器实现，而必须使用支持该协议的服务器。</p>
</li>
<li><p>因为WebSocket使用自定义协议，所以URL方案稍有变化：不能再使用http://或者https://,而要使用ws://或wss://。前者是不安全链接，后者是安全链接</p>
</li>
<li><p>发送和接收数据，使用send（）方法并传入一个字符串、ArrayBuffer或Blob</p>
</li>
<li><p>API</p>
<ul>
<li>要创建一个新的Web Socket，就要实例化一个WebSocket对象并传入提供链接的URL</li>
<li>注意：必须个WebSocket构造函数传入一个绝对URL。同源策略不适用于Web Socket。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>定义web socket协议的时间比定义JavaScript API时间药厂。Web Socket得到了所有主流浏览器的支持。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>使用自定义协议而非HTTP协议的好处是，客户端与服务器之间可以发送十分少量的数据，不会对HTTP造成负担。</li>
<li>非常适合带宽和延迟比较明显的移动端。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习笔记15线程</title>
    <url>/2022/05/08/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="JavaScript线程"><a href="#JavaScript线程" class="headerlink" title="JavaScript线程"></a>JavaScript线程</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>我们都知道，JavaScript是一个单线程的语言，这是由它的用途决定的，一开始JavaScript只是作为网站的脚本语言存在，目的是为了和用户产生交互。如果JavaScript一开始就是多线程的，用户用一个线程删除了dom节点，另一个线程却修改了这个节点，就会产生矛盾。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>但是，在前端高速发展的今天，单纯的单线程同步方式已经不满足前端开发了，于是出现了异步、ajax、定时器等等非单线程的功能，但是JavaScript是一个单线程语言，是如何实现这些的呢？</p>
<h3 id="运行环境是多线程的"><a href="#运行环境是多线程的" class="headerlink" title="运行环境是多线程的"></a>运行环境是多线程的</h3><p>JavaScript本身是单线程的，但是它的运行环境（V8，nodejs）却不是单线程的，这就为JavaScript多线程操作带来了可能。</p>
<p>浏览器由很多的线程：</p>
<ol>
<li>GUI渲染线程</li>
<li>JS引擎线程</li>
<li>定时器触发线程（setTimeout）</li>
<li>浏览器事件线程（onclick）</li>
<li>http异步线程</li>
<li>EventLoop轮询处理线程</li>
</ol>
<p>其中1、2、4为常驻线程。</p>
<p>注意线程1和2是互斥的，也就是说js计算会阻塞GUI渲染，这是因为如果GUI渲染到一半js改变了DOM，就会造成渲染不同步。</p>
<h3 id="线程的分工方式"><a href="#线程的分工方式" class="headerlink" title="线程的分工方式"></a>线程的分工方式</h3><p>JS引擎线程是主线程，我们平时认为JS是单线程就是因为只在这个主线程上运行js代码。</p>
<p>对于线程的分工，就是遇到了需要异步或者其他线程工作的代码，就丢给对应的线程工作，等对应的线程工作完毕，就会通知事件轮询处理线程。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对于以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;	</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">fetch(url).then(	<span class="comment">//三秒后返回请求</span></span><br><span class="line">    <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dom.onclick = <span class="function">()=&gt;</span>&#123;	<span class="comment">//4秒后触发函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>在同步执行阶段：</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220508205736193.png" alt="image-20220508205736193"></p>
<p>可以看出，JS引擎在这次执行中其实至运行了<code>console.log(1)</code>，其他的都交给对应的子线程去辅助执行了。</p>
<p><strong>在异步执行阶段：</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/js%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5.png" alt="js异步执行阶段"></p>
<p>当异步的线程完成了之后，才会将对应的回调加入消息队列</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>less学习笔记01变量</title>
    <url>/2022/05/09/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><p>less是一款预处理语言，可以允许我们以类似于js的方式去使用css。我们使用less去编写css会更加方便。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>less中可以将属性名，选择器和属性值定义为变量，就像js一样。</p>
<p>注意：属性名和选择器定义的变量在使用的时候要以<code>@&#123;name&#125;</code>的方式使用，而属性值变量直接使用<code>@name</code>方式使用就可以了。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@pos:</span> position;</span><br><span class="line"><span class="variable">@a:</span>.a;</span><br><span class="line"><span class="variable">@rel:</span>relative;</span><br><span class="line"><span class="variable">@&#123;a&#125;</span> &#123;</span><br><span class="line">  @&#123;pos&#125;: @<span class="selector-tag">rel</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50vh</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line">  <span class="selector-class">.b</span> &#123;</span><br><span class="line">    @&#123;pos&#125;: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的延迟加载"><a href="#变量的延迟加载" class="headerlink" title="变量的延迟加载"></a>变量的延迟加载</h3><p>在less中变量都是块级作用域的，而且具有延迟加载的特点，即无论在同一个块级作用域中定义同一个变量即此，都以最后一次为标准</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@a:</span>red;</span><br><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="variable">@a:</span>pink;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">@a</span>;</span><br><span class="line">  <span class="variable">@a:</span>blue;</span><br><span class="line">  <span class="selector-class">.b</span>&#123;</span><br><span class="line">    <span class="variable">@a:</span>yellow;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="variable">@a</span>; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><p>less中默认的嵌套规则都是父子嵌套的方式，如果想要使用伪类需要加上<code>&amp;</code>修饰符</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@pos:</span> position;</span><br><span class="line"><span class="variable">@a:</span>.a;</span><br><span class="line"><span class="variable">@rel:</span>relative;</span><br><span class="line"><span class="variable">@&#123;a&#125;</span> &#123;</span><br><span class="line">  @&#123;pos&#125;: @<span class="selector-tag">rel</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50vh</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line">  <span class="selector-class">.b</span> &#123;</span><br><span class="line">    @&#123;pos&#125;: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="comment">//不加&amp;的话会被认为是子级而不是伪类</span></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">      <span class="attribute">background-color</span>: rgb(<span class="number">197</span>, <span class="number">34</span>, <span class="number">61</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>less学习笔记02混合</title>
    <url>/2022/05/09/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E6%B7%B7%E5%90%88/</url>
    <content><![CDATA[<h1 id="Less混合（mixin）"><a href="#Less混合（mixin）" class="headerlink" title="Less混合（mixin）"></a>Less混合（mixin）</h1><p>less的混合是一个强大的工具，在css开发中往往涉及到很多标签需要用到相同或相似的一段代码，这个时候我们就可以使用mixin去定义一段可以复用的代码。</p>
<h2 id="普通混合"><a href="#普通混合" class="headerlink" title="普通混合"></a>普通混合</h2><p>将一段可以复用的代码抽离出来单独命名，在需要使用的地方直接使用这个命名即可。</p>
<p>在mixin中代码加上<code>()</code>可以避免被编译到css中</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.position-center</span> () &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50vh</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="selector-class">.position-center</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30vw</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: rgb(<span class="number">197</span>, <span class="number">34</span>, <span class="number">61</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.c</span> &#123;</span><br><span class="line">    <span class="selector-class">.position-center</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30vw</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: black;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background-color</span>: rgb(<span class="number">197</span>, <span class="number">34</span>, <span class="number">61</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带参数的混合"><a href="#带参数的混合" class="headerlink" title="带参数的混合"></a>带参数的混合</h2><p>可以在混合中使用参数，就像JavaScript一样，也可以给参数默认值，也可以在使用的时候指定参数传参</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.position-center</span> (<span class="variable">@left</span>: <span class="number">30vw</span>, <span class="variable">@color</span>: black) &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="variable">@left</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式*"></a>匹配模式*</h2><p>引入混入的时候，可以把第一个参数当作标识符，从而创建多个同名的<code>mixin</code></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">./mode.less</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="selector-class">.square</span>(B, pink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在匹配模式中，带有<code>@_</code>参数的是默认的<code>mixin</code>，即你不论使用哪一个<code>mixin</code>都会带上这个<code>mixin</code>的内容。</p>
<p>其他的<code>mixin</code>可以使用第一个参数作为标识符进行区分。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mode.less</span></span><br><span class="line"><span class="selector-class">.square</span>(<span class="variable">@_</span>) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span>(B, <span class="variable">@color</span>) &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">40px</span> solid <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span>(T, <span class="variable">@color</span>) &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">40px</span> solid <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="arguments参数列表"><a href="#arguments参数列表" class="headerlink" title="arguments参数列表"></a>arguments参数列表</h2><p>就像JavaScript参数一样，可以用<code>@arguments</code>去使用参数含有的说所有参数组成的列表</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border</span>(<span class="variable">@width</span>, <span class="variable">@style</span>, <span class="variable">@color</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="selector-class">.border</span>(<span class="number">2px</span>, solid, blue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>less学习笔记04其他</title>
    <url>/2022/05/10/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><h2 id="less计算"><a href="#less计算" class="headerlink" title="less计算"></a>less计算</h2><p>less中可以使用计算，规则与css一样</p>
<h2 id="less避免编译"><a href="#less避免编译" class="headerlink" title="less避免编译"></a>less避免编译</h2><p>在less中如果使用了css原生的计算属性，且不希望编译器自动编译（即把这个计算留到浏览器中去编译）</p>
<p>可以使用<code>~&quot;表达式&quot;</code>的方式将整个表达式直接传入css而不经过编译。</p>
]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>less学习笔记03继承</title>
    <url>/2022/05/10/less%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="Less继承"><a href="#Less继承" class="headerlink" title="Less继承"></a>Less继承</h1><p>在less中有继承这个概念，可以类比混合，但是和混合有一定的区别。</p>
<h2 id="继承是什么"><a href="#继承是什么" class="headerlink" title="继承是什么"></a>继承是什么</h2><p>我们通过混合去‘继承’一些代码的时候，如果去看看编译后的css代码就会发现一些问题，通过混合继承的代码会分别在每个标签中重复一遍。</p>
<h3 id="通过混合继承"><a href="#通过混合继承" class="headerlink" title="通过混合继承"></a>通过混合继承</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过混合继承</span></span><br><span class="line"><span class="selector-class">.center</span>() &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="selector-class">.b</span> &#123;</span><br><span class="line">     <span class="comment">//混合的写法</span></span><br><span class="line">    <span class="selector-class">.center</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: BLUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.c</span> &#123;</span><br><span class="line">    <span class="selector-class">.center</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译结果</strong>：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220510104103136.png" alt="image-20220510104103136"></p>
<h3 id="通过继承去继承"><a href="#通过继承去继承" class="headerlink" title="通过继承去继承"></a>通过继承去继承</h3><p><strong>使用继承写法后，所有继承了这段代码的属性都会共用这段代码</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="selector-class">.b</span> :<span class="selector-tag">extend</span>(.center) &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: BLUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.c</span> :<span class="selector-tag">extend</span>(.center) &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译结果</strong>：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220510104350414.png" alt="image-20220510104350414"></p>
<p>可以明显看出，继承是一种代码重用的技术，和混合不同的是，它只适用于静态代码，不能继承混合。而且能过节约大量空间。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>继承只能继承类，不能继承混合</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">10px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> :<span class="selector-tag">extend</span>(.center)&#123;&#125;  <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span>(<span class="variable">@height</span>)&#123;</span><br><span class="line">	<span class="attribute">height</span>:<span class="variable">@height</span>;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">10px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.a</span> :<span class="selector-tag">extend</span>(.center)&#123;&#125;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>在要继承的类上面加上all可以把和这个类相关的例如伪类、伪元素一并继承</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">10px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span> :<span class="selector-tag">extend</span>(.center all)&#123;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>less</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs学习笔记01事件循环</title>
    <url>/2022/05/07/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="Nodejs中的事件循环"><a href="#Nodejs中的事件循环" class="headerlink" title="Nodejs中的事件循环"></a>Nodejs中的事件循环</h1><p>在浏览器环境中的JavaScript有一个事件循环，是一个比较简单的模型。而在Nodejs中也有一个事件循环，不同于浏览器，nodejs环境中的事件循环更为复杂。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/nodejs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF(1).png" alt="nodejs事件循环(1)"></p>
<ol>
<li><p>Timers：用于储存定时器的回调函数（setTImeout,setInterval）</p>
</li>
<li><p>Pending callbacks：执行与操作系统相关的回调函数，比如启动服务器端应用时监听端口的操作就是在这里调用</p>
</li>
<li><p>Idle，prepare：系统内部使用</p>
</li>
<li><p>IO Poll：存储I/O操作的回调函数队列，例如文件读写操作的回调函数</p>
<p><strong>如果事件队列中有回调函数，就执行它们直到清空队列</strong></p>
<p><strong>否则事件循环将在此阶段停留一段时间以等待新的回调函数进入，这个等待取决于以下两个条件：</strong></p>
<ol>
<li>setImmediate队列（check阶段中存在要执行的回调函数）</li>
<li>timers队列中存在要执行的回调函数，在这种情况下，事件循环将一至check阶段，然后移至Closing callbacks阶段，并最终从timers阶段进入下一次循环</li>
</ol>
</li>
<li><p>Check：存储setImmediate API的回调函数</p>
</li>
<li><p>Clonsing callbacks：执行与关闭事件相关的回调，比如关闭数据库链接的回调函数等。</p>
</li>
</ol>
<h2 id="事件循环小测试"><a href="#事件循环小测试" class="headerlink" title="事件循环小测试"></a>事件循环小测试</h2><p>注意:在微任务中nextTick的优先级要比其他的更高</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./loading.html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)          <span class="comment">//2 1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 5 3 6 2 1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs学习笔记02架构</title>
    <url>/2022/05/07/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Nodejs架构"><a href="#Nodejs架构" class="headerlink" title="Nodejs架构"></a>Nodejs架构</h1><p>Nodejs是一个构建在Chrome浏览器V8引擎上的JavaScript运行环境，也是我们是使用过程中直接能调用的API。</p>
<p>Nodejs在底层上其实是由c/c++实现的，也就是说，我们获得的API实际上是由c/c++编写的库提供的。当然JavaScript并不能直接和c/c++通信，因此需要一个“桥梁”。所以nodejs实际上是由三成架构组成的——<strong>nodejs API库，bindings（桥梁）和c/c++底层</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/nodejs%E6%9E%B6%E6%9E%84.png" alt="nodejs架构"></p>
<p>Node bindings是JavaScript与C/C++库之间的桥梁，通过bindings将c/c++实现的库暴露给JavaScript，同时把js传入V8，解析后交给libuv发起非阻塞I/O，并等待事件循环调度。</p>
<p>底层库：</p>
<ol>
<li>V8是JavaScript的虚拟机，为JavaScript提供了在非浏览器端运行的环境</li>
<li>libuv为nodejs提供了跨平台，线程池，异步I/O能力，这是nodejs高效的主要原因</li>
<li>c-ares提供了异步处理DNS相关的能力</li>
<li>http_parser、OpenSSL、zlib提供包括http解析、SSL、数据压缩等能⼒。</li>
</ol>
<p><strong>Nodejs到底是单线程还是多线程</strong></p>
<p>一般来说我们认为JavaScript是单线程的，但是nodejs的底层由c/c++参与，分为了一个主线程和多个子线程，所以我们认为Nodejs其实是多线程的。</p>
<h2 id="nodejs高效的原因"><a href="#nodejs高效的原因" class="headerlink" title="nodejs高效的原因"></a>nodejs高效的原因</h2><ul>
<li><p>非阻塞I/O</p>
<p>I/O就是一个系统的输入与输出，<strong>阻塞I/O在系统接收输入到输出的过程中不可以接收其他输入，非阻塞I/O在系统接收输入到输出的过程中还可以接收其他输入。</strong></p>
<p>实现原理：js执行单线程任务，把需要做的I/O交给libuv，自己马上返回做别的事情，然后libuv在指定的时刻回调就可以了。</p>
</li>
<li><p>事件驱动机制</p>
</li>
</ul>
<h2 id="nodejs线程池"><a href="#nodejs线程池" class="headerlink" title="nodejs线程池"></a>nodejs线程池</h2><p>nodejs实际上是多线程的，默认有4个线程用以处理I/O任务。线程池的大小可以通过<code>UV_THREADPOOL_SIZE</code>这个环境变量来改变 或者在<strong>nodejs代码</strong>中通过 <code>process.env.UV_THREADPOOL_SIZE</code>来重新设置。</p>
<h2 id="nodejs的优劣"><a href="#nodejs的优劣" class="headerlink" title="nodejs的优劣"></a>nodejs的优劣</h2><p>nodejs通过libuv来处理与操作系统的交互，并且因此具备了异步、非阻塞、事件驱动的能力。因此，nodejs能响应大量的并发请求。所以，<strong>nodejs适合运用在高并发、I/O密集、少量业务逻辑的场景（中台）。</strong></p>
<p>如果是 I/O 任务，Node.js 就把任务交给线程池来异步处理，高效简单，因此 Node.js 适合处理I/O密集型任务。但不是所有的任务都是 I/O 密集型任务，当碰到CPU密集型任务时，即只用CPU计算的操作，比如要对数据加解密(node.bcrypt.js)，数据压缩和解压(node-tar)，这时 Node.js 就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着 。我们看如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();<span class="comment">//获取当前时间戳</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)&#123;<span class="comment">//执行长循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1000	3738</span></span><br></pre></td></tr></table></figure>

<p>现在大部分服务器都是多 CPU 或多核的，而 Node.js 只有一个 EventLoop，也就是只占用一个 CPU 内核，当 Node.js 被CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。因此nodejs并不适合CPU密集型任务。</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3+vite实战踩坑</title>
    <url>/2022/05/06/vue3-vite%E5%AE%9E%E6%88%98%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h1 id="Vue3-vite实战踩坑"><a href="#Vue3-vite实战踩坑" class="headerlink" title="Vue3+vite实战踩坑"></a>Vue3+vite实战踩坑</h1><p>一开始的想法是目前个人博客使用的是hexo搭建的静态页面，相对方便但是不好自定义，也没有后台交互，于是想要改进一下，做一个前端vue后端nodejs的个人博客项目，下面就是踩坑记录。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/Vue3+antD+nodejs.png" alt="Vue3+antD+nodejs"></p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>搭建vite项目</strong></p>
<p>网上流行使用vite+vue3的开发模式，使用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm init vite<span class="literal">-app</span> &lt;project<span class="literal">-name</span>&gt;</span><br></pre></td></tr></table></figure>

<p>就可以轻松搭建一个vite项目</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220506095926769.png" alt="image-20220506095926769"></p>
<p>当然，前面轻松后面会换回来的，注意看<code>package.json</code>中的信息，我们发现只有<code>@vue/compiler-sfc</code>这一个依赖，也就是说，这个项目目前只支持单页组件，其他所有的插件都不支持，我们需要自己引入支持。</p>
<p>而且，由于vite版本较低，目前主流的组件库最新版都不兼容这个版本的vite了，所以最好还是将vite升级一下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm uninstall vite</span><br><span class="line">npm install vite</span><br></pre></td></tr></table></figure>

<p><strong>引入antd for vue，引入vue-router</strong></p>
<p><code>antd for vue</code>( “^3.2.3”)按照官网上的指引引入就可以，当然，要先将vite(“^2.9.8”)和vue(“^3.0.4”)升级到最新版本。</p>
<p><code>vue-router</code>最新版(^4.0.15)的写法发生了变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">&#x27;@/components/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">    <span class="attr">history</span>: createWebHistory(),</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="string">&#x27;/index&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/index&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: index,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h2 id="前端功能搭建"><a href="#前端功能搭建" class="headerlink" title="前端功能搭建"></a>前端功能搭建</h2><ol>
<li><h4 id="开局大屏，具有伸缩透视效果。"><a href="#开局大屏，具有伸缩透视效果。" class="headerlink" title="开局大屏，具有伸缩透视效果。"></a>开局大屏，具有伸缩透视效果。</h4><p><strong>依赖</strong>：parallax.js(获取鼠标位置，实时计算每张图片的位移量，当然，缺点就是牺牲了性能，但是好看！)</p>
<p><strong>实现</strong>：</p>
<ul>
<li><p>使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;scene&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;layer&quot; data-depth=&quot;.1&quot;&gt;&lt;img src=&quot;./img/planet2.png&quot; /&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;layer&quot; data-depth=&quot;.5&quot;&gt;&lt;img src=&quot;./img/earth.png&quot; /&gt;&lt;/li&gt;</span><br><span class="line">    &lt;!-- data-depth表示图片深度，深度越深相对唯一越大。 --&gt;</span><br><span class="line">    &lt;div class=&quot;arrowSS&quot; @click=&quot;toIndex&quot;&gt;</span><br><span class="line">        &lt;img href=&quot;#anchorSS&quot; class=&quot;arrow&quot; src=&quot;./img/arrow.png&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>在script中创建实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="built_in">document</span>.getElementById(<span class="string">&quot;scene&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> parallax = <span class="keyword">new</span> Parallax(scene);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>踩坑</strong>：</p>
<ol>
<li><p>由于是全屏的组件，滚轮的存在会特别难看，所以使用<code>overflow-Y:hidden</code>清除滚轮，但是需要下拉到下一个主要内容页，于是定义了一个向下的按钮，还有监听鼠标滚轮。</p>
<p><strong>向下的按钮</strong>：在<code>firefox</code>中，这个按钮的层级非常的低，设置了<code>z-index</code>也是没有用的，所以我们无法点击这个按钮，在<code>chorme</code>中却正常。</p>
<p><strong>监听鼠标滚轮事件</strong>：通过封装<code>mousewheel</code>事件去监听鼠标是否向下滑动，然后使用<code>scrollIntoView</code>进行页面平滑滚动。注意要及时清除监听。</p>
</li>
</ol>
</li>
<li><h4 id="伸缩侧边栏"><a href="#伸缩侧边栏" class="headerlink" title="伸缩侧边栏"></a>伸缩侧边栏</h4><p><strong>依赖</strong>：阿里妈妈icon图标库（好东西），<code>flex</code>布局</p>
<p><strong>实现</strong>：</p>
<ul>
<li>把侧边栏信息抽象出来，利用<code>v-for</code>遍历到页面上面。</li>
</ul>
<p><strong>效果</strong>：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220523100721970.png" alt="image-20220523100721970"></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220523100745667.png" alt="image-20220523100745667"></p>
<p>踩坑：一开始的时候是按照静态页面搭建的，然后修改成使用DOM动态添加样式，虽然方便，代码少，但是vue就没有作用了，最后还是头铁改成了<code>v-for</code>。</p>
</li>
<li><p>展示博客页</p>
</li>
</ol>
<h2 id="后端功能搭建"><a href="#后端功能搭建" class="headerlink" title="后端功能搭建"></a>后端功能搭建</h2><ol>
<li><h4 id="更新博客到数据库接口实现"><a href="#更新博客到数据库接口实现" class="headerlink" title="更新博客到数据库接口实现"></a>更新博客到数据库接口实现</h4><p><strong>依赖</strong>：marked(md to html)，highlight.js，github-markdown-css</p>
<p><strong>实现</strong>：通过<code>readFlieSync</code>去检索指定文件夹下的markdown，然后利用marked把markdown转成html，再通过正则修改，添加上样式cdn，在保存html到数据库里面。</p>
<p><strong>踩坑</strong>：想要把转文件功能抽出来，结果太多函数嵌套，那啥山代码了属于是（流汗黄豆），改造成promise代码总算能看了。原来数据库可以放这么大的数据呀，速度还不慢，牛的。</p>
<p><strong>后续</strong>：应该把数据库操作再抽出来会不会好看一些？</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2022/04/13/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="JavaScript中的事件循环"><a href="#JavaScript中的事件循环" class="headerlink" title="JavaScript中的事件循环"></a>JavaScript中的事件循环</h1><h2 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h2><p>JavaScript是一个单线程的语言，不像Java一样可以同时执行多个任务，在同一时间节点下JavaScript只能执行一个任务。</p>
<p>这就产生了一个问题，当JavaScript去请求网络上的资源或者进行一些耗时但是不需要JavaScript引擎本身去做的事的时候，就会为了等待这个耗时任务的完成而浪费了大量的时间。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/75ed6085ba982cc9da9b524b010da660.png" alt="75ed6085ba982cc9da9b524b010da660"></p>
<p>为了解决这个问题，就产生了异步任务通知回调的模式：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/0acd586791a98689147cdf0957834654.png" alt="0acd586791a98689147cdf0957834654"></p>
<p>当JavaScript在等待异步任务执行的这段时间内可以先去执行其他不相关的同步任务，这样就能节省大量时间，等到异步任务完成的时候再去通知异步任务的后续任务进行处理，而进行“通知”的，就是时间循环。把异步任务的回调部分交给事件循环，等待何时的时机再交还给js线程执行。</p>
<p>事件循环是由一个队列组成的，异步任务的回调遵循先进先出，在js引擎空闲的时候会一轮轮地被取出，所以叫做循环。</p>
<p>而根据任务类型的不同，分为宏任务和微任务。</p>
<h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>属于宏任务的有：</p>
<ul>
<li>script（整体的代码）</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate(nodejs)</li>
<li>IO</li>
</ul>
<p>属于微任务的有：</p>
<ul>
<li>process.nextTick(nodejs)</li>
<li>promise.then()</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<h2 id="为什么要分宏任务和微任务"><a href="#为什么要分宏任务和微任务" class="headerlink" title="为什么要分宏任务和微任务"></a>为什么要分宏任务和微任务</h2><p>通俗的讲这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。</p>
<p>区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。</p>
<h2 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h2><p>浏览器的事件循环是由一个宏任务队列和多个微任务队列组成的。</p>
<p>首先执行第一个宏任务也就是全局JavaScript脚本代码。在这个宏任务执行中产生的宏任务和微任务分别进入宏任务队列和微任务队列。执行完同步任务之后，将当前的微任务列表清空，完成一次事件循环。</p>
<p>然后从宏任务中取出一个宏任务，执行，然后再将当前存在的微任务清空，一次往复。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2022/03/19/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><blockquote>
<p>维基百科上说柯里化（Currying）是将一个接收多个参数的函数转换为只接受一个参数（最初函数的第一个参数），并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<h2 id="通过一个例子解释"><a href="#通过一个例子解释" class="headerlink" title="通过一个例子解释"></a>通过一个例子解释</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个 sum 方法，当使用下面的语法调用时，能正常工作</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Outputs 5</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// Outputs 5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//正常写法</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">arguments</span>.length === <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//函数柯里化写法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，函数柯里化将这个函数拆分成为多段的函数，每一个阶段都只接受一个参数，逐步得出最终答案。那么为什么需要这样做呢，这样做有什么好处吗？</p>
<h2 id="柯里化的优点"><a href="#柯里化的优点" class="headerlink" title="柯里化的优点"></a>柯里化的优点</h2><ol>
<li><p><strong>参数复用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常正则验证字符串 reg.test(txt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">reg, txt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test&#x27;</span>)       <span class="comment">//false</span></span><br><span class="line">check(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = curryingCheck(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>)      <span class="comment">// true</span></span><br><span class="line">hasNumber(<span class="string">&#x27;testtest&#x27;</span>)   <span class="comment">// false</span></span><br><span class="line">hasLetter(<span class="string">&#x27;21212&#x27;</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面的这种做法，正常来说直接调用check进行校验就可以了，但是如果我需要多次校验不同的规则就需要每次都定义规则，使用柯里化之后可以解决复用问题。</p>
</li>
<li><p><strong>提前确认</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//就是把isSupport这个参数给先确定下来了，避免每次都要判断</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">isSupport, element, event, handler</span>) </span>&#123;</span><br><span class="line">    isSupport = isSupport || <span class="built_in">document</span>.addEventListener;</span><br><span class="line">    <span class="keyword">if</span> (isSupport) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element.attachEvent(<span class="string">&#x27;on&#x27;</span> + event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>延迟运行</strong></p>
<p>最常见的就是bind，实现的机制就是利用柯里化的延迟运行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thisArg = thisArg || <span class="built_in">window</span></span><br><span class="line">    <span class="keyword">var</span> thisFunc = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thisFunc.apply(thisArg, arg)</span><br><span class="line">    &#125;</span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>通用函数：（使用‘over’参数终止）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCurrying</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> curryFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ([...arguments][<span class="number">0</span>] === <span class="string">&quot;over&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到结束标记，收集所有参数交给原始函数</span></span><br><span class="line">                <span class="keyword">return</span> func(...args)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有获取结束标记，利用闭包保存所有参数</span></span><br><span class="line">                args.push(...arguments)</span><br><span class="line">                <span class="comment">//返回一个用于在中间接收数据的中间函数</span></span><br><span class="line">                <span class="keyword">return</span> curryFunc</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curryFunc</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>微搭低代码搭建简易扫码系统</title>
    <url>/2022/01/03/%E5%BE%AE%E6%90%AD%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%89%AB%E7%A0%81%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="搭建前提"><a href="#搭建前提" class="headerlink" title="搭建前提"></a>搭建前提</h2><ol>
<li>找陆哥分配一个团队子账号，后续用这个子账号在团队账号中进行开发。</li>
<li>对微搭平台搭建项目过程有一定了解</li>
</ol>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>通过微信扫码进入小程序或web端，同时能够获取对应的产品信息显示在页面上。</li>
<li>初步想法分为Web端搭建和小程序搭建<ul>
<li>Web端：优势是可以直接请求跳转对应的页面，同时携带请求信息。</li>
<li>小程序端。</li>
</ul>
</li>
</ol>
<h3 id="Web端搭建过程"><a href="#Web端搭建过程" class="headerlink" title="Web端搭建过程"></a>Web端搭建过程</h3><h5 id="技术前提："><a href="#技术前提：" class="headerlink" title="技术前提："></a>技术前提：</h5><ol>
<li>微信扫码的机制是，如果扫描出来的是一个网址，则会自动跳转到该网址</li>
<li>经过测试，扫码出来的url自带后缀如?id=xxx形式不影响跳转结果，同时会保留后缀</li>
</ol>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ol>
<li>将二维码设置为网址+id的url形式如<a href="http://www.abc.com/?id=1">http://www.abc.com?id=1</a></li>
<li>扫码后在网址的生命周期内获取url并解析id，请求后台数据并进行显示</li>
</ol>
<h6 id="展示页面"><a href="#展示页面" class="headerlink" title="展示页面"></a>展示页面</h6><ol>
<li><p>创建空白应用</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103100613298.png" alt="image-20220103100613298"></p>
</li>
<li><p>搭建静态页面（根据具体需求进行搭建，这里仅展示本项目需求）</p>
<ol>
<li><p>在变量-变量管理中可以设置好需要绑定的变量，后面需要用到就自行设置</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101743365.png" alt="image-20220103101743365"></p>
</li>
<li><p>轮播图搭建</p>
<ol>
<li><p>在组件中选择轮播图组件</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101142993.png" alt="image-20220103101142993"></p>
</li>
<li><p>在大纲树中选择轮播图组件，在右侧栏中为每一个图片空位添加绑定的数据</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101232512.png" alt="image-20220103101232512"></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103101340165.png" alt="image-20220103101340165"></p>
</li>
</ol>
</li>
<li><p>列表项搭建</p>
<ol>
<li><p>在组件中选择列表项添加到项目中</p>
</li>
<li><p>为列表项绑定对应数据</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103102301713.png" alt="image-20220103102301713"></p>
</li>
<li><p>设置列表项样式，最简单的方式就是两个宽度为50%，向左向右浮动</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103102009355.png" alt="image-20220103102009355"></p>
</li>
</ol>
</li>
<li><p>展示卡搭建</p>
<ol>
<li><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103102423465.png" alt="image-20220103102423465"></li>
<li>其他步骤同上</li>
</ol>
</li>
</ol>
</li>
<li><p>（核心）在首页页面的声明周期钩子onPageLoad/onPageShow处解析url，获取id</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103039110.png" alt="image-20220103103039110"></p>
</li>
<li><p>通过id请求数据并绑定对应数据显示在页面中</p>
<p>这里采用微搭自带数据源搭建方案，详情参考后面后端搭建部分</p>
</li>
<li><p>创建返回首页按钮</p>
</li>
</ol>
<h6 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h6><ol>
<li><p>创建新的空白页</p>
</li>
<li><p>可以选择区块模板快速搭建</p>
</li>
<li><p>设置输入框输入id查询</p>
<ol>
<li><p>一种实现方法</p>
<p>为输入框绑定一个变量，同时给他添加输入改变事件，执行变量赋值绑定变量</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103441767.png" alt="image-20220103103441767"></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103426252.png" alt="image-20220103103426252"></p>
</li>
<li><p>为下面的按钮绑定自定义事件，让他进行url+前面输入的id跳转</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103103752393.png" alt="image-20220103103752393"></p>
</li>
</ol>
</li>
<li><p>设置扫码按钮启用微信浏览器扫码功能</p>
<ol>
<li><p>设置按钮绑定启用扫码功能，关闭自动处理</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104128747.png" alt="image-20220103104128747"></p>
</li>
<li><p>为扫码成功绑定自定义事件实现跳转</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104154753.png" alt="image-20220103104154753"></p>
</li>
<li><p>扫码成功后绑定的方法中会自动在event参数中注入扫码信息，具体自己分析</p>
</li>
</ol>
</li>
</ol>
<h4 id="后端搭建"><a href="#后端搭建" class="headerlink" title="后端搭建"></a>后端搭建</h4><ol>
<li><p>在微搭控制台-数据源-新建自建数据源</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104754591.png" alt="image-20220103104754591"></p>
</li>
<li><p>在数据源字段添加对应数据（自建数据源有数个自带的字段无法删改，不过影响不大，可以忽略）</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103104951906.png" alt="image-20220103104951906"></p>
</li>
<li><p>在方法模块中可以通过云函数操作数据库，本项目中自带的方法已经足够了，就不演示了</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103105153870.png" alt="image-20220103105153870"></p>
</li>
</ol>
<h4 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h4><ol>
<li><p>在前端中需要调用后端的地方调用数据源</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103110405307.png" alt="image-20220103110405307"></p>
</li>
<li><p>获取结果之后绑定到之前为前端页面绑定的数据</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103110626633.png" alt="image-20220103110626633"></p>
</li>
</ol>
<p>最终结果（使用微信扫描）：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103163153760.png" alt="image-20220103163153760"></p>
<p>记录一些细节问题：</p>
<ul>
<li>微搭自带扫码方法自动处理是会自动跳转的，但是如果跳转的目标页面有报错则会终止跳转，这个报错似乎是无法避免的，类似于React版本兼容性问题，这就造成了在模拟中能成功跳转，但是发布后无法成功跳转。所以后面采用自定义方法跳转的办法。</li>
<li>由于输入框绑定的值是在表单提交（submit）中生效的数据，对于只有一个输入框的表单来说有点麻烦，所以采用输入值改变绑定值的方法实现，理论上性能不如表单提交，但是更方便。</li>
<li>低代码编辑器中想要使用异步，必须要在生命周期钩子前加asyn异步</li>
</ul>
]]></content>
      <categories>
        <category>微搭低代码</category>
      </categories>
      <tags>
        <tag>团队工作</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2022/04/14/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h1><p>在ES6以前，JavaScript中没用引入类（class）的概念，通过构造函数来创建实例。ES6之后虽然实现了class类的概念，但是实质上还是依靠原型和原型链的。</p>
<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>由于JavaScript中没有类的概念，为了实现继承已有的方法，JavaScript产生了一种模式叫构造函数模式，在这个模式中，通过构造一个新的函数，能够继承构造函数已经拥有的方法。</p>
<p>但是这么做有一个缺陷，当我们创建了一百个新实例的时候，其实在JavaScript中创建了100个新的构造函数的副本，而一般来说，有很多部分都是重复的，我们能不能把这也重复的函数或属性放到一个地方，构造函数实例的时候只要保持对它的引用就可以了。于是原型与原型链诞生了。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在JavaScript中，每当定义一个函数数据类型（普通函数、类）的时候，都会自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</p>
<p>![器材申请 (1)](<a href="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E5%99%A8%E6%9D%90%E7%94%B3%E8%AF%B7">https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/器材申请</a> (1).png)</p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，同一设置到原型对象中。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li><h4 id="proto-和constructor"><a href="#proto-和constructor" class="headerlink" title="__proto__和constructor"></a>__proto__和constructor</h4><p>每个对象数据类型（普通的对象、实例、prototype）都自带一个属性__proto__，属性值是当前实例所属类的原型（prototype）。原型对象中有一个属性constructor，它指向函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A()</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__===A.prototype)	<span class="comment">//ture</span></span><br><span class="line"><span class="built_in">console</span>.log(A.prototype.constructor===A)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//es5方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a) === A.prototype)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>![器材申请 (2)](<a href="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E5%99%A8%E6%9D%90%E7%94%B3%E8%AF%B7">https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/器材申请</a> (2).png)</p>
</li>
<li><h4 id="何为原型链"><a href="#何为原型链" class="headerlink" title="何为原型链"></a>何为原型链</h4><p>在JavaScript中万物都是对象，而对象之间也是有联系的。对象之间的继承关系，在JavaScript中式通过prototype对象指向父类对象，直到指向Object对象为止（因为万物都是对象，而对象是由Object构造函数构造的）这样就形成了一个原型指向的链条，也就是原型链。</p>
<p>当我们去访问对象的一个属性或者方法的时候，它会优先在对象自身中寻找，如果有则直接使用，没有的话就会去到上一级原型对象上寻找，一直往上寻找直到到达原型链顶端（Object）为止。<strong>Object是JavaScript中所有对象数据类型的基类（最顶层的类）在Object.prototpe上没有__proto__这个属性</strong></p>
<p>![器材申请 (3)](<a href="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E5%99%A8%E6%9D%90%E7%94%B3%E8%AF%B7">https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/器材申请</a> (3).png)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写DOM转json格式</title>
    <url>/2022/04/22/%E6%89%8B%E5%86%99DOM%E8%BD%ACjson%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="手写dom节点结构转json数据"><a href="#手写dom节点结构转json数据" class="headerlink" title="手写dom节点结构转json数据"></a>手写dom节点结构转json数据</h1><p>注意点：dom结构中的全部是类数组结构，如果想要使用数组的api需要使用<code>Array.from</code>将其转化为数组结构。注意<code>nodeType</code>和文字节点中的多余空格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">domToTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.body</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dealDom</span>(<span class="params">dom</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(dom)</span></span><br><span class="line">        <span class="keyword">const</span> obj = &#123;</span><br><span class="line">            <span class="attr">tag</span>: dom.nodeName.toLowerCase().replace(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果DOM的nodeType为1说明是元素节点，我们需要深入</span></span><br><span class="line">        <span class="keyword">if</span> (dom.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//处理dom的属性</span></span><br><span class="line">            <span class="keyword">let</span> attrs = dealAttrs(dom.attributes)</span><br><span class="line">            <span class="keyword">if</span> (attrs) obj.attributes = attrs</span><br><span class="line">            <span class="comment">//筛选出nodeTupe不为3且文本内容不为空的子DOM节点，并且进行递归</span></span><br><span class="line">            obj.children = <span class="built_in">Array</span>.from(dom.childNodes).filter(<span class="function"><span class="params">m</span> =&gt;</span> !(m.nodeType === <span class="number">3</span> &amp;&amp; m.nodeValue.trim() === <span class="string">&#x27;&#x27;</span>)).map(<span class="function"><span class="params">m</span> =&gt;</span> dealDom(m))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dom.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个节点是个文字节点，就将这个节点的content赋值，赋值之前记得去除空格</span></span><br><span class="line">            obj.content = dom.textContent.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理DOM属性</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dealAttrs</span>(<span class="params">attributes</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">let</span> attrs = <span class="built_in">Array</span>.from(attributes)</span><br><span class="line">        attrs.forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            obj[attr.name] = attr.value</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> attrs.length ? obj : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dealDom(dom)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(domToTree())</span><br></pre></td></tr></table></figure>

<p>这是一个从body节点入手，将这个dom树转化为json数据的函数</p>
]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise.all、Promise.Race</title>
    <url>/2022/01/03/%E6%89%8B%E5%86%99Promise-all%E3%80%81Promise-Race/</url>
    <content><![CDATA[<h1 id="手写Promise-all"><a href="#手写Promise-all" class="headerlink" title="手写Promise.all()"></a>手写Promise.all()</h1><p>分析：原生Promise.all的作用，接收一个数组，数组内为Promise，Promise.all会自动执行所有数组内的Promise，返回一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Promise</span>.all([promise,promise2]).then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result.message)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103213459296.png" alt="image-20220103213459296"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//resolve(&#x27;1&#x27;)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Promise</span>.all([promise,promise2]).then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result.message)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220103214542617.png" alt="image-20220103214542617"></p>
<p>思路：获取所有的Promise，都执行then，把结果放到数组，一起返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>._all = <span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [], promiseCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.map(<span class="function">(<span class="params">v,i</span>) =&gt;</span> &#123;</span><br><span class="line">            v.then(</span><br><span class="line">                <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    promiseCount++</span><br><span class="line">                    results[i] = res</span><br><span class="line">                    <span class="keyword">if</span>(promiseCount === promises.length)&#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(results)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="手写Promsie-race"><a href="#手写Promsie-race" class="headerlink" title="手写Promsie.race"></a>手写Promsie.race</h1><p>分析：race和all差不多，不过一个是获取所有结果，race是获取最早执行的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>._race = <span class="function"><span class="params">promises</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">            promise.then(</span><br><span class="line">                <span class="function"><span class="params">res</span> =&gt;</span> resolve(res),</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> reject(err)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写call、apply和bind</title>
    <url>/2022/02/22/%E6%89%8B%E5%86%99call%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h2 id="手写Call"><a href="#手写Call" class="headerlink" title="手写Call"></a>手写Call</h2><h5 id="Call干了什么"><a href="#Call干了什么" class="headerlink" title="Call干了什么"></a>Call干了什么</h5><p>​    Call()是函数原型方法，Call获取一系列的参数，第一个参数被绑定为被调用函数的this。可以理解为call把函数放到了第一个参数对象里面然后进行调用。第二个及以后的参数是传进这个被执行函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在函数原型上定义一个方法，接收作为this的参数和后续的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context,...arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.判断context是否为空，为空则将this绑定为window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//因为这是函数原型的方法，所以在这个方法中的this就指向需要调用的函数本身</span></span><br><span class="line">    <span class="comment">//3.将函数放到context（this）中去</span></span><br><span class="line">    context.p = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//4.调用这个函数，根据this的默认指向规则，会指向这个context</span></span><br><span class="line">    <span class="keyword">const</span> result = context.p(...arg)</span><br><span class="line">    <span class="comment">//5.记得删除p，避免改变了这个对象</span></span><br><span class="line">    <span class="keyword">delete</span> context.p</span><br><span class="line">    <span class="comment">//6.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;whh&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name+b+c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callName.myCall(a,<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;ee&quot;</span>))		<span class="comment">//whhddee</span></span><br></pre></td></tr></table></figure>

<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><h5 id="apply干了什么"><a href="#apply干了什么" class="headerlink" title="apply干了什么"></a>apply干了什么</h5><p>​    apply（）和call（）一样是函数原型方法，作用与call（）类似，只是接收的参数换成了this的指向和一个参数数组，也就是说原来在call（）中需要一个个输入的函数参数可以整理成数组传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在函数原型上定义一个方法，接收作为this的参数和后续的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context,arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.判断context是否为空，为空则将this绑定为window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//因为这是函数原型的方法，所以在这个方法中的this就指向需要调用的函数本身</span></span><br><span class="line">    <span class="comment">//3.将函数放到context（this）中去</span></span><br><span class="line">    context.p = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//4.调用这个函数，根据this的默认指向规则，会指向这个context</span></span><br><span class="line">    <span class="keyword">const</span> result = context.p(...arg)</span><br><span class="line">    <span class="comment">//5.记得删除p，避免改变了这个对象</span></span><br><span class="line">    <span class="keyword">delete</span> context.p</span><br><span class="line">    <span class="comment">//6.返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;whh&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyName</span>(<span class="params">b,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name+b+c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(applyName.myApply(a,[<span class="string">&quot;dd&quot;</span>,<span class="string">&quot;ee&quot;</span>]))		<span class="comment">//whhddee</span></span><br></pre></td></tr></table></figure>

<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><h5 id="bind干了什么？"><a href="#bind干了什么？" class="headerlink" title="bind干了什么？"></a>bind干了什么？</h5><p>​    bind（）和apply（），call（）的区别在于bind只为函数绑定了this，和传入参数，但是却没有立刻执行它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.在函数原型上定义一个方法，接收作为this的参数和后续的参数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context,arg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//2.判断context是否为空，为空则将this绑定为window</span></span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//3.因为这是函数原型的方法，所以在这个方法中的this就指向需要调用的函数本身</span></span><br><span class="line">    <span class="keyword">var</span> thisFunc = <span class="built_in">this</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.因为需要构造函数，所以不能用匿名函数</span></span><br><span class="line">    <span class="keyword">let</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thisFunc.apply(context,arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.需要将原函数的prototype赋值给绑定函数</span></span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="comment">//6.返回函数</span></span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检验</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">text</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a+b+<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = text.myBind(person,[<span class="string">&#x27;i &#x27;</span>,<span class="string">&#x27;am &#x27;</span>])</span><br><span class="line">func()				<span class="comment">//i am abc</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写instanceof</title>
    <url>/2022/04/06/%E6%89%8B%E5%86%99instanceof/</url>
    <content><![CDATA[<h1 id="手写instanceof"><a href="#手写instanceof" class="headerlink" title="手写instanceof"></a>手写instanceof</h1><p>instanceof是JavaScript中一种检查构造函数的prototype属性是否在另一个实例对象上出现过的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _instanceof = <span class="function">(<span class="params">left,right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取实例对象的原型链</span></span><br><span class="line">	<span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(proto===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">//当构造函数的原型出现在实例对象的原型链中</span></span><br><span class="line">		<span class="keyword">if</span>(proto===right.prototype)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//向下查找实例对象的原型链</span></span><br><span class="line">		proto = proto.__proto__</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B</span><br><span class="line"><span class="built_in">console</span>.log(_instanceof(b,A))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写freeze</title>
    <url>/2022/04/11/%E6%89%8B%E5%86%99freeze/</url>
    <content><![CDATA[<h1 id="手写Object-freeze"><a href="#手写Object-freeze" class="headerlink" title="手写Object.freeze"></a>手写Object.freeze</h1><p>有时候再JavaScript中我们期望一个对象的值不要被改变或删节，我们需要找到一个方法将这个对象“冻结”起来。</p>
<p>我们需要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(object)</span><br></pre></td></tr></table></figure>

<p>这个API能阻止对象中的属性被删除或者增加</p>
<p>然而对于对象中已经存在的属性，我们也要阻止它们被修改，这个时候就需要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(object,p,&#123;...&#125;)</span><br></pre></td></tr></table></figure>

<p>这个API允许我们为对象中的元素设置一些拦截器方法，我们可以再这个地方设置对象的属性为不可写的，这样对象就不会被改变啦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _objectFreeze = <span class="function"><span class="params">object</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断传入参数是否为对象</span></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">        <span class="comment">// Object.seal()方法可以让对象不能被扩展、删除属性等等。</span></span><br><span class="line">        <span class="comment">// 遍历对象中的属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">in</span> object) &#123;</span><br><span class="line">            <span class="comment">// 修改对象中属性的特性&#x27;可写&#x27;为false</span></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(object, p, &#123;</span><br><span class="line">                <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 实现深冻结</span></span><br><span class="line">            _objectFreeze(object[p]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Object.seal可以实现使这个对象不能添加或删除属性</span></span><br><span class="line">    <span class="built_in">Object</span>.seal(object);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写fetch控制并发数</title>
    <url>/2022/03/10/%E6%89%8B%E5%86%99fetch%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="fecth控制并发数"><a href="#fecth控制并发数" class="headerlink" title="fecth控制并发数"></a>fecth控制并发数</h1><p>面试题，实现一个带并发数限制的fetch请求函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendResquest</span>(<span class="params">urls, max</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> pending_count = <span class="number">0</span>, <span class="comment">//并发数</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//当前请求的位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先把请求池填满</span></span><br><span class="line">    <span class="keyword">while</span> (pending_count &lt; max) &#123; </span><br><span class="line">        _fetch(urls[idx++])</span><br><span class="line">    &#125; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了实现并发，需要嵌套调用fetch</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">_fetch</span>(<span class="params">url</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (!url) <span class="keyword">return</span>; </span><br><span class="line">        pending_count++; </span><br><span class="line">		<span class="built_in">console</span>.log(url+<span class="string">&#x27;:start，并发数:&#x27;</span>+pending_count)</span><br><span class="line">		<span class="keyword">await</span> fetch(url)</span><br><span class="line">		pending_count--</span><br><span class="line">		<span class="built_in">console</span>.log(url+<span class="string">&#x27;:end，并发数:&#x27;</span>+pending_count)</span><br><span class="line">		<span class="comment">//此fetch执行完毕，切换下一个fetch</span></span><br><span class="line">		_fetch(urls[idx++])</span><br><span class="line">		<span class="keyword">if</span>(!pending_count)&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&quot;执行完毕&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证</span></span><br><span class="line"><span class="keyword">let</span> urls = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>:<span class="number">7</span>&#125;, <span class="function">(<span class="params">v, k</span>) =&gt;</span> k);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> fetch = <span class="function"><span class="keyword">function</span> (<span class="params">idx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> timeout = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1e4</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(idx)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> max = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> callback = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;run callback&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">sendResquest(urls, max, callback)</span><br></pre></td></tr></table></figure>



<p>promise.all版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myall = <span class="function">(<span class="params">promises, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//定义当前并发数，和计数器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pendingCount = <span class="number">0</span>, idx = <span class="number">0</span>, result = []</span><br><span class="line">        <span class="comment">//先将请求池填满</span></span><br><span class="line">        <span class="keyword">while</span> (pendingCount &lt; target) &#123;</span><br><span class="line">            _promise(promises[idx++])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//请求promise函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_promise</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//递归终止条件</span></span><br><span class="line">            <span class="keyword">if</span> (!promise) <span class="keyword">return</span></span><br><span class="line">            <span class="comment">//当前请求开始，并发数+1</span></span><br><span class="line">            pendingCount++</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;请求&#x27;</span> + promise + <span class="string">&#x27;开始,当前并发数&#x27;</span> + pendingCount)</span><br><span class="line">            <span class="comment">//使用Prmise.then去异步完成Promise</span></span><br><span class="line">            promise.then(</span><br><span class="line">                <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//这一个Promise决议成功，将它加入结果数组</span></span><br><span class="line">                    result.push(res)</span><br><span class="line">                    <span class="comment">//当前请求结束，并发数-1</span></span><br><span class="line">                    pendingCount--</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;请求&#x27;</span> + promise + <span class="string">&#x27;结束,当前并发数&#x27;</span> + pendingCount)</span><br><span class="line">                    <span class="comment">//当前请求结束，下一个请求开始</span></span><br><span class="line">                    _promise(promises[idx++])</span><br><span class="line">                    <span class="comment">//如果并发数归零，说明全部决议，返回结果数组</span></span><br><span class="line">                    <span class="keyword">if</span> (pendingCount === <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">&#x27;请求全部结束&#x27;</span>)</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//这个Promise拒绝，直接返回reject</span></span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;请求&#x27;</span> + promise + <span class="string">&#x27;异常！&#x27;</span>)</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写jsonp</title>
    <url>/2022/04/06/%E6%89%8B%E5%86%99jsonp/</url>
    <content><![CDATA[<h1 id="手写jsonp"><a href="#手写jsonp" class="headerlink" title="手写jsonp"></a>手写jsonp</h1><p>浏览器存在跨域限制，就是说在不同协议、不同域名、不同端口的情况下默认是不能访问跨域的接口的。但是有时有需要跨域访问，为了解决这个问题，产生了jsonp。</p>
<p>jsonp的原理是浏览器中的script标签是不受跨域限制的，也就是说可以请求跨域的脚本文件。只要后端配合脚本文件上的url就可以实现跨域通信。</p>
<h5 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>jsonp 跨域<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#x27;btnId&#x27;</span>&gt;</span>跨域请求按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="comment">//处理回调的数据</span></span></span><br><span class="line"><span class="javascript">	<span class="function"><span class="keyword">function</span> <span class="title">dataFn</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript">	</span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> _btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btnId&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">//在请求的链接上加上回调函数的名称，后端直接向回调函数中传值</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> url = <span class="string">&#x27;http://localhost:8083/api?callback=dataFn&#x27;</span></span></span><br><span class="line"><span class="javascript">	_btn.onclick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">let</span> _script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span></span><br><span class="line"><span class="javascript">		_script.setAttribute(<span class="string">&#x27;src&#x27;</span>,url)</span></span><br><span class="line"><span class="javascript">		_script.setAttribute(<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;text/javascript&#x27;</span>)</span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.querySelector(<span class="string">&#x27;body&#x27;</span>).appendChild(_script)</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收请求参数，拼接上数据，返回javascript脚本文件</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/api&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// let _d = [1,2,3,4]</span></span><br><span class="line">	<span class="keyword">let</span> data = req.query.callback + <span class="string">&quot;(&#123;&#x27;name&#x27;:&#x27;lihua&#x27;&#125;)&quot;</span></span><br><span class="line">	<span class="comment">//拼接完成后返回的其实是&quot;dataFn(&#123;&#x27;name&#x27;:&#x27;lihua&#x27;&#125;)&quot;</span></span><br><span class="line">	<span class="comment">//在前端中被当成可执行的JavaScript代码，于是前端执行dataFn(&#123;&#x27;name&#x27;:&#x27;lihua&#x27;&#125;)</span></span><br><span class="line">	res.send(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8083</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;8083,项目中间件&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将网页挂载在静态页面上</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/public&#x27;</span>,express.static(<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8081</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;http server running at http://127.0.0.1:8081&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写new</title>
    <url>/2022/01/11/%E6%89%8B%E5%86%99new/</url>
    <content><![CDATA[<h1 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h1><h3 id="new是什么"><a href="#new是什么" class="headerlink" title="new是什么"></a>new是什么</h3><p>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person1)  <span class="comment">// Person &#123;name: &quot;Tom&quot;, age: 20&#125;</span></span><br><span class="line">t.sayName() <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出</p>
<ul>
<li>new通过构造函数Person创建出来的实例可以访问到构造函数中的属性</li>
<li>new通过构造函数Person创建出来的实例可以访问到构造函数原型链中的属性（即实例于构造函数通过原型链连接了起来）</li>
</ul>
<p>现在在构建函数中显示加上返回值，并且这个返回值是一个原始类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用</p>
<p>下面在构造函数中返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// Test &#123; name: &#x27;xxx&#x27; &#125;</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">26</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> t = <span class="keyword">new</span> Test(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t) <span class="comment">// &#123; age: 26 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(t.name) <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>从上面的演示中，我们可以看到new关键字主要做了一下工作：</p>
<ul>
<li>创建一个新的对象obj</li>
<li>将对象与构建函数中通过原型链连接起来</li>
<li>将构造函数中的this绑定到新建的对象obj上</li>
<li>根据构造函数返回值的类型做判断，如果是原始值则会忽略，如果是对象，则正常处理</li>
</ul>
<h3 id="手写new操作符"><a href="#手写new操作符" class="headerlink" title="手写new操作符"></a>手写new操作符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">Func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.新对象原型指向构造函数原型对象</span></span><br><span class="line">    obj.__proto__ = Func.prototype</span><br><span class="line">    <span class="comment">// 3.将构建函数的this指向新对象</span></span><br><span class="line">    <span class="keyword">let</span> result = Func.apply(obj, args)</span><br><span class="line">    <span class="comment">// 4.根据返回值判断</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mynew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    obj.__proto__ = func.prototype</span><br><span class="line">    <span class="keyword">let</span> result = func.apply(obj, args)</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p = mynew(Person, <span class="string">&quot;huihui&quot;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p) <span class="comment">// Person &#123;name: &quot;huihui&quot;, age: 123&#125;</span></span><br><span class="line">p.say() <span class="comment">// huihui</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写promise</title>
    <url>/2022/01/02/%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>promise是ES6中非常重要的内容，可以说，promise终结了回调地狱的难题，在面试中经常会考Promise的相关原理，因此掌握Promise的底层原理十分重要。</p>
<h2 id="初始结构"><a href="#初始结构" class="headerlink" title="初始结构"></a>初始结构</h2><ol>
<li><p>正常情况下是通过new Promise方法来创建新的promise，因此手写Promise时可以使用class。</p>
</li>
<li><p>一个Promise接收一个参数，这个参数是一个函数</p>
</li>
<li><p>在这个函数内接收两个参数resolve，reject</p>
</li>
<li><p>状态转换</p>
<p>promise有三种状态，pending，fulfilled，rejected</p>
<ul>
<li>其中默认初始状态为pending</li>
<li>fulfilled和rejected只能通过pending转换过来，且不可逆</li>
</ul>
</li>
<li><p>结果参数</p>
<ul>
<li>当Promise完成执行函数后，会产生一个结果参数，我们需要根据这个结果参数来确定Promise接下来转换的状态</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//promise的基本结构</span></span><br><span class="line"><span class="comment">//原生的promise一般会用new来创建实例，所以这里采用class的方式模拟promise</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建静态属性</span></span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;待定&#x27;</span>; <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;成功&#x27;</span>; <span class="keyword">static</span> REJECTED = <span class="string">&#x27;拒绝&#x27;</span>;</span><br><span class="line">    <span class="comment">//new Promise对象是需要传入一个参数，这个参数是一个函数,所以需要在constructor接收一个函数参数并自动执行它。</span></span><br><span class="line">    <span class="comment">//接收的函数内也可以传入两个参数，resolve和reject</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//默认的状态为pending</span></span><br><span class="line">        <span class="built_in">this</span>.status = myPromise.PENDING</span><br><span class="line">        <span class="comment">//默认结果传参</span></span><br><span class="line">        <span class="built_in">this</span>.result = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//注意由于在执行构造函数中的this在类函数中会丢失，需要重新指定this</span></span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于在类内resolve和reject两个参数还没有定义，需要创造两个参数</span></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.FULFILLED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.REJECTED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在将结果参数传入给resolve和reject时，会发现this指向异常（调用this.status的时候并没有调用this.constructor里面的this.status）</p>
<p>原因：</p>
<ul>
<li>在创建新实例的时候确实创建了新的this.status</li>
<li>但是目前我们是在新实例被创建后再在外部环境下执行resolve方法，此时this就会丢失</li>
</ul>
<p>解决方法：</p>
<ul>
<li>在执行resolve，reject前为其绑定this</li>
</ul>
<h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>Promise.then是Promise中一个非常重要的功能，第一参数执行resolve方法，第二个参数执行reject方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">        onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">        onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行异常"><a href="#执行异常" class="headerlink" title="执行异常"></a>执行异常</h2><p>在Promise中报错是不会被直接抛出的，如果在执行过程中出现报错，则会直接转换状态为rejected并且在结果参数中输出报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.result = <span class="literal">null</span></span><br><span class="line"><span class="comment">//执行前判断生成的实例有没有报错，有就直接reject</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//注意由于在执行构造函数中的this在类函数中会丢失，需要重新指定this</span></span><br><span class="line">    func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Error</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.reject(<span class="built_in">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Promise.then中如果传入的参数不是函数是会被静默忽略掉的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断参数类型，非函数参数转换为函数</span></span><br><span class="line">    onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">        onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">        onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>Promise中的回调函数是异步执行的，并且执行顺序是同步&gt;微内核任务（Promsie）&gt;宏内核任务（SetTimeout）</p>
<p>在这里使用setTimeout模拟异步</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="comment">//异步执行，注意Promise中的回调是异步执行的，并且是微内核，即执行顺序为同步&gt;Promise&gt;setTimeout</span></span><br><span class="line"><span class="comment">//then内部的函数应该使用一个数组保存起来，直到Promise完成响应之后再执行，否则then检测到此时状态为peding则会不执行</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断参数类型，非函数参数转换为函数</span></span><br><span class="line">        onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回调保存"><a href="#回调保存" class="headerlink" title="回调保存"></a>回调保存</h2><p>Promise在执行异步任务的时候由于then不是异步的，所以需要先用数组保存then中的函数，等待Promise决议完成之后再执行对应的函数</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>我们常常在Promise中使用Promise.then().then()，这就是链式调用，这是解决回调地狱的关键。</p>
<ol>
<li><p>通常来说，调用.then()返回的是一个新的Promise，对于这个返回值，有</p>
<ul>
<li>将这个新Promise传递到下一个then中</li>
<li>如果返回一个普通的值，则将这个普通的值传递到下一个then中</li>
</ul>
</li>
<li><p>当我们在第一个then()中return了一个参数（参数未知，需要判断）。这个return出来的新的promsie就是onFulfilled（）或者onRejected（）的值</p>
</li>
<li><p>为了满足上述的要求，就需要一个额外的函数用来判断返回值，并做出响应</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//禁止循环引用，会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">        <span class="comment">//出现循环则直接抛出错误</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">//x为普通值，则直接返回解决；若x为对象或者函数且不为null，则判断是否仍然是promise</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//取得函数的下一个then</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="comment">//如果下一个then仍然是函数，则说明还有下一层，默认为Promise</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.call(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//由于结果依旧是promise,继续向下解析</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//拒绝之后后续的所有Promise都会被拒绝</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="完整的仿写Promise"><a href="#完整的仿写Promise" class="headerlink" title="完整的仿写Promise"></a>完整的仿写Promise</h2><p>功能：resolve，reject，then，异步执行，链式调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//promise的基本结构</span></span><br><span class="line"><span class="comment">//原生的promise一般会用new来创建实例，所以这里采用class的方式模拟promise</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建静态属性</span></span><br><span class="line">    <span class="keyword">static</span> PENDING = <span class="string">&#x27;待定&#x27;</span>; <span class="keyword">static</span> FULFILLED = <span class="string">&#x27;成功&#x27;</span>; <span class="keyword">static</span> REJECTED = <span class="string">&#x27;拒绝&#x27;</span>;</span><br><span class="line"><span class="comment">//new Promise对象是需要传入一个参数，这个参数是一个函数,所以需要在constructor接收一个函数参数并自动执行它。</span></span><br><span class="line"><span class="comment">//接收的函数内也可以传入两个参数，resolve和reject</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//默认的状态为pending</span></span><br><span class="line">    <span class="built_in">this</span>.status = myPromise.PENDING</span><br><span class="line">    <span class="comment">//默认结果传参</span></span><br><span class="line">    <span class="built_in">this</span>.result = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//创建临时数组用于在Promise还没有决议前保存then中的待执行函数</span></span><br><span class="line">    <span class="built_in">this</span>.resolveCallbacks = []</span><br><span class="line">    <span class="built_in">this</span>.rejectCallbacks = []</span><br><span class="line">    <span class="comment">//执行前判断生成的实例有没有报错，有就直接reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注意由于在执行构造函数中的this在类函数中会丢失，需要重新指定this</span></span><br><span class="line">        func(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">Error</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.reject(<span class="built_in">Error</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于在类内resolve和reject两个参数还没有定义，需要创造两个参数</span></span><br><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//在node环境中使用process.nextTick可以设置为微任务</span></span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.FULFILLED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">            <span class="comment">//执行待执行的函数</span></span><br><span class="line">            <span class="built_in">this</span>.resolveCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">result</span>)</span> &#123;</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前状态，只有状态为pending时才可以转换状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = myPromise.REJECTED</span><br><span class="line">            <span class="built_in">this</span>.result = result</span><br><span class="line">            <span class="comment">//执行待执行的函数</span></span><br><span class="line">            <span class="built_in">this</span>.rejectCallbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//then函数</span></span><br><span class="line"><span class="comment">//异步执行，注意Promise中的回调是异步执行的，并且是微内核，即执行顺序为同步&gt;Promise&gt;setTimeout</span></span><br><span class="line"><span class="comment">//then内部的函数应该使用一个数组保存起来，直到Promise完成响应之后再执行，否则then检测到此时状态为peding则会不执行</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFULFILLED,onREJECTED</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//判断参数类型，非函数参数转换为函数</span></span><br><span class="line">        onFULFILLED = <span class="keyword">typeof</span> onFULFILLED === <span class="string">&#x27;function&#x27;</span> ? onFULFILLED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        onREJECTED = <span class="keyword">typeof</span> onREJECTED === <span class="string">&#x27;function&#x27;</span> ? onREJECTED : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.PENDING)&#123;</span><br><span class="line">            <span class="built_in">this</span>.resolveCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//获取解决的结果</span></span><br><span class="line">                <span class="keyword">let</span> x = onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">                <span class="comment">//在这个函数中判断返回的值，并作不同处理</span></span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">this</span>.rejectCallbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.FULFILLED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onFULFILLED(<span class="built_in">this</span>.result)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status === myPromise.REJECTED)&#123;</span><br><span class="line">            <span class="comment">//异步执行</span></span><br><span class="line">            process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> x = onREJECTED(<span class="built_in">this</span>.result)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//禁止循环引用，会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">        <span class="comment">//出现循环则直接抛出错误</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">//x为普通值，则直接返回解决；若x为对象或者函数且不为null，则判断是否仍然是promise</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//取得函数的下一个then</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="comment">//如果下一个then仍然是函数，则说明还有下一层，默认为Promise</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.call(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//由于结果依旧是promise,继续向下解析</span></span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">//状态转换只有一次，且不能逆转</span></span><br><span class="line">                    <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//拒绝之后后续的所有Promise都会被拒绝</span></span><br><span class="line">                    reject(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(called)<span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第一步&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二步&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第五步&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(<span class="string">&#x27;第四步&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result)),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result.message))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第三步&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码（原生Promise）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第一步&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二步&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;第五步&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(<span class="string">&#x27;第四步&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise1.then(</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result)),</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span> (<span class="built_in">console</span>.log(result.message))</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;第三步&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>从测试代码中可以发现，异步调用中的微内核任务没有实现。同时还有Promise.all(),Promise.race(),Promise值穿透等等功能待实现，Promise是一个复杂但是十分有用的技术，多阅读源码可以有效提高自己的代码水平。</p>
]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写n个数组求交集</title>
    <url>/2022/04/06/%E6%89%8B%E5%86%99n%E4%B8%AA%E6%95%B0%E7%BB%84%E6%B1%82%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h1 id="n个数组求交集"><a href="#n个数组求交集" class="headerlink" title="n个数组求交集"></a>n个数组求交集</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用...收集待处理的数组</span></span><br><span class="line"><span class="keyword">const</span> get = <span class="function">(<span class="params">...arrs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//利用reduce每次收集返回值作为下一个total的特性，遍历整个参数数组，以第一个参数为起点进行匹配</span></span><br><span class="line">	<span class="keyword">let</span> toSet = arrs.reduce(<span class="function">(<span class="params">total,arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//每次都保留能够与total数组匹配的值，再返回给total</span></span><br><span class="line">		<span class="keyword">return</span> arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> total.includes(item))</span><br><span class="line">	&#125;)</span><br><span class="line">    <span class="comment">//此时结果数组中可能含有重复的值，将其剔除</span></span><br><span class="line">	<span class="keyword">return</span> [...new <span class="built_in">Set</span>(toSet)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(get(arr1,arr2,arr3))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现图片懒加载</title>
    <url>/2022/04/06/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="手写图片的懒加载"><a href="#手写图片的懒加载" class="headerlink" title="手写图片的懒加载"></a>手写图片的懒加载</h1><p>在前端项目中，网页加载优化是一个很重要的能力，由于前端网页中往往存在大量的图片，而有些图片并不会在一开始就被用户看见，这些图片如果都在网页加载的时候渲染的话会拖慢渲染时间，我们可以对其设置，等到用户看见这张图片的时候（图片进入浏览器视图窗口）再进行加载。</p>
<p>方式一：使用IntersectionObserver这个JavaScript API（推荐）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;img&quot;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(images)</span></span><br><span class="line"><span class="javascript"><span class="comment">//利用IntersectionObserver这个API去检测图片是否出现再视口内</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//遍历每一个发生变化的观察者节点</span></span></span><br><span class="line"><span class="javascript">	entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">if</span>(entry.isIntersecting)&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//找出对应的图片节点</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> image = entry.target</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> dataset = <span class="string">&#x27;https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg&#x27;</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//为图片添加地址</span></span></span><br><span class="line"><span class="javascript">			image.setAttribute(<span class="string">&#x27;src&#x27;</span>,dataset)</span></span><br><span class="line"><span class="javascript">			<span class="comment">//触发一次加载函数后取消观察者节约资源</span></span></span><br><span class="line"><span class="javascript">			observer.unobserve(image)</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">	&#125;)</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//为每一个图片节点注册观察者</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(image <span class="keyword">of</span> images)&#123;</span></span><br><span class="line"><span class="javascript">	observer.observe(image)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>方式二：使用getBoundingClientRect检测元素于页面顶端的距离或者dom.offsetTop检测dom元素距离父元素的高度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	&lt;p&gt;本例调用的函数会执行一个计算，然后返回结果：&lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;img&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">getTop</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	 <span class="comment">// 可视窗口的高度</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">for</span>(image <span class="keyword">of</span> images)&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="keyword">let</span> set = image.getBoundingClientRect()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="keyword">if</span>(viewHeight&gt;=set.top)&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="built_in">console</span>.log(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">const</span> dataset = <span class="string">&#x27;https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/e83bca5f1d1e6bf359d1f75727968c11_720w.jpg&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">//为图片添加地址</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">			image.setAttribute(<span class="string">&#x27;src&#x27;</span>,dataset)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">//节流函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params">fn,delay</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">let</span> vaild = <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="keyword">if</span>(!vaild) <span class="keyword">return</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		vaild = <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			fn()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			vaild = <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,delay)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> getImageTop = save(getTop,<span class="number">300</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, getImageTop)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写reduce、用reduce实现map</title>
    <url>/2022/01/04/%E6%89%8B%E5%86%99reduce%E3%80%81%E7%94%A8reduce%E5%AE%9E%E7%8E%B0map/</url>
    <content><![CDATA[<h1 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h1><p>reduce是JavaScript原生的数组操作方法，功能强大</p>
<p><strong>reducer</strong> 函数接收4个参数:</p>
<ol>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
</ol>
<p>您的 <strong>reducer</strong> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reduce用法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.reduce(<span class="function">(<span class="params">acc,cur,idx,arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc+cur</span><br><span class="line">&#125;,<span class="number">1</span>))</span><br><span class="line"><span class="comment">//22</span></span><br></pre></td></tr></table></figure>

<p>原生实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最好不要使用箭头函数，因为this指向会不正确</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">func,init</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this指向调用reduce方法的数组</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//初始的累计器需要额外赋值，没有的话默认为数组的第一项</span></span><br><span class="line">    <span class="keyword">var</span> total = init!=<span class="literal">null</span>?init:arr[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//这里要注意如果没有指定初始值和指定初始值为0是不同的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = (init!=<span class="literal">null</span>?<span class="number">0</span>:<span class="number">1</span>);i&lt;arr.length;i++)&#123;</span><br><span class="line">        total = func(total, arr[i], i, arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用map实现reduce</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最好不要使用箭头函数，因为this指向会不正确</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span>(<span class="params">func,init</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this指向调用reduce方法的数组</span></span><br><span class="line">    <span class="keyword">var</span> arr = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//初始的累计器需要额外赋值，没有的话默认为数组的第一项</span></span><br><span class="line">    <span class="keyword">var</span> total = init || arr[<span class="number">0</span>]</span><br><span class="line">    arr.map(<span class="function">(<span class="params">v,i</span>) =&gt;</span> &#123;</span><br><span class="line">        i!=init?total = func(total, v, i, arr):<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用reduce实现map</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用reduce实现map</span></span><br><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span>(<span class="params">func,thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">total,cur,idx,arr</span>) =&gt;</span> &#123;</span><br><span class="line">        result[idx] = func.call(thisArg,cur,idx,arr);\</span><br><span class="line">        <span class="comment">//这里并不关心累加器的值，但是为了让reduce从第一个元素开始遍历，为累加器赋初始值0</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _mapArr = arr._map(<span class="function"><span class="keyword">function</span>(<span class="params">v, i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v+i+<span class="built_in">this</span>.length;</span><br><span class="line">&#125;, arr2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_mapArr);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写数据类型的判断</title>
    <url>/2022/04/07/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="手写数据类型判断"><a href="#手写数据类型判断" class="headerlink" title="手写数据类型判断"></a>手写数据类型判断</h1><p>typeof可以正确识别包括：undefined、boolean，number、string、symbol、function等类型的数据，但是对于其他的数据会认为是object，所以仅通过typeof来判断数据类型是不太准确的。</p>
<p>obj.toString()可以返回一个带有数据类型的字符串，但是toString大多数被重写过，为了正确的使用，使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> data !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> <span class="keyword">typeof</span> data</span><br><span class="line">	<span class="comment">//Object.prototype.toString这个方法返回一个带对象类型的形如[object Array]字符串</span></span><br><span class="line">	<span class="comment">//直接使用obj.toString()的话，有可能方法被重写过</span></span><br><span class="line">	<span class="keyword">let</span> res = <span class="built_in">Object</span>.prototype.toString.call(data)</span><br><span class="line">	<span class="comment">//正则匹配转化为小写用toLowerCase()</span></span><br><span class="line">	<span class="keyword">return</span> res.match(<span class="regexp">/\ (.+)]$/</span>)[<span class="number">1</span>].toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(typeOf([]))			<span class="comment">//Array</span></span><br><span class="line"><span class="built_in">console</span>.log(typeOf(<span class="keyword">new</span> <span class="built_in">Date</span>))	<span class="comment">//Date</span></span><br><span class="line"><span class="built_in">console</span>.log(typeOf(<span class="number">0</span>))			<span class="comment">//number</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写数组扁平化</title>
    <url>/2022/04/06/%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<h1 id="手写数组扁平化"><a href="#手写数组扁平化" class="headerlink" title="手写数组扁平化"></a>手写数组扁平化</h1><p>数组扁平化是前端常考的面试题之一，目的是要将一个多重嵌套的数组的值取出放到同一个数组中。</p>
<h3 id="ES5方法（递归）"><a href="#ES5方法（递归）" class="headerlink" title="ES5方法（递归）"></a>ES5方法（递归）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组扁平化</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,[<span class="number">6</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = []</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i]))&#123;</span><br><span class="line">			result = result.concat(flatten(arr[i]))</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			result.push(arr[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br><span class="line"><span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6方法（解构赋值）"><a href="#ES6方法（解构赋值）" class="headerlink" title="ES6方法（解构赋值）"></a>ES6方法（解构赋值）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组扁平化</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,[<span class="number">6</span>]]]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//每次检测到arr中含有数组，将arr解构再拼接上数组</span></span><br><span class="line">	<span class="keyword">while</span>(arr.some(<span class="function"><span class="params">m</span> =&gt;</span> <span class="built_in">Array</span>.isArray(m)))&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(arr)</span><br><span class="line">		arr = [].concat(...arr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>手写深复制</title>
    <url>/2022/01/10/%E6%89%8B%E5%86%99%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h1><p>在JavaScript中拷贝分为两种，浅拷贝和深拷贝。首先深复制和浅复制只针对像 Object, Array 这样的复杂对象的。简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。</p>
<ul>
<li>浅拷贝：将b对象拷贝到a对象中，但是不包括b内的子对象</li>
<li>深拷贝：将b对象拷贝到a对象中，包括b内的子对象</li>
</ul>
<h3 id="实现深拷贝的两种方案"><a href="#实现深拷贝的两种方案" class="headerlink" title="实现深拷贝的两种方案"></a>实现深拷贝的两种方案</h3><h5 id="JSON转换"><a href="#JSON转换" class="headerlink" title="JSON转换"></a>JSON转换</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>

<p>缺点：如果对象里面有函数，函数无法被拷贝下来</p>
<h5 id="遍历函数深拷贝"><a href="#遍历函数深拷贝" class="headerlink" title="遍历函数深拷贝"></a>遍历函数深拷贝</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//考虑对象中存在循环引用</span></span><br><span class="line">    <span class="keyword">let</span> cache = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个缓存，记录已经有过的引用</span></span><br><span class="line">    <span class="keyword">if</span> (!deepClone.cache) &#123;</span><br><span class="line">        deepClone.cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache = deepClone.cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache.has(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑对象中存在set数据类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Set</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        cache.set(obj, temp);</span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            temp.add(deepClone(item));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="comment">//考虑对象中存在map数据类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        cache.set(obj, temp);</span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">            temp.set(key, deepClone(item));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">        <span class="comment">//考虑对象中存在正则类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用对象的构造函数，创建一个新的引用</span></span><br><span class="line">        <span class="keyword">const</span> temp = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">        cache.set(obj, temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            temp[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">array</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="attr">object</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">arrayOfObjs</span>: [&#123; <span class="attr">a</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">b</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">c</span>: <span class="number">30</span> &#125;],</span><br><span class="line">    <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;]),</span><br><span class="line">    <span class="attr">map</span>: <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        [<span class="string">&quot;a&quot;</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="string">&quot;b&quot;</span>, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;],</span><br><span class="line">    ]),</span><br><span class="line">    <span class="attr">regExp</span>: <span class="regexp">/[a-z]/</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">circular</span>: obj,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.circular = obj2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cloned = deepClone(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj, cloned);</span><br><span class="line"><span class="built_in">console</span>.log(cloned === obj);</span><br><span class="line"><span class="built_in">console</span>.log(cloned.array === obj.array);</span><br><span class="line"><span class="built_in">console</span>.log(cloned.object === obj.object);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloned.arrayOfObjs === obj.arrayOfObjs);</span><br><span class="line"><span class="built_in">console</span>.log(cloned.arrayOfObjs[<span class="number">0</span>] === obj.arrayOfObjs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="keyword">const</span> it = cloned.set.values();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line"><span class="keyword">const</span> cSet = it.next();</span><br><span class="line"><span class="comment">// console.log(cSet);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it2 = obj.set.values();</span><br><span class="line">it2.next();</span><br><span class="line">it2.next();</span><br><span class="line">it2.next();</span><br><span class="line"><span class="keyword">const</span> oSet = it2.next();</span><br><span class="line"><span class="comment">// console.log(oSet);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cSet.value === oSet.value);</span><br></pre></td></tr></table></figure>

<h2 id="扩展：直接赋值、浅拷贝和深拷贝的区别"><a href="#扩展：直接赋值、浅拷贝和深拷贝的区别" class="headerlink" title="扩展：直接赋值、浅拷贝和深拷贝的区别"></a>扩展：直接赋值、浅拷贝和深拷贝的区别</h2><ul>
<li><p><strong>直接赋值</strong></p>
<ol>
<li>如果是基本数据类型，得到的会是一个新值，会在栈内存中开辟一个空间储存赋值的值，所以不用考虑浅拷贝和深拷贝</li>
<li>而引用数据类型的直接赋值，得到的是一个地址的引用，就会出现改变第一个数据，第二个数据也会跟着改变。</li>
</ol>
</li>
<li><p><strong>浅拷贝</strong></p>
<p>浅拷贝就是为了解决直接赋值产生的问题，让赋值后的对象拿到的是新的引用地址和新的值。但是由于浅拷贝只能拷贝一层的基本数据类型，多层后就无法拷贝了。因此使用这种方法的话只有第一层的基本数据类型得到了拷贝。</p>
<p>浅拷贝的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _shallowClone = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.hasOwnProperty(key)) &#123;</span><br><span class="line">            obj[key] = target[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(obj);</span><br><span class="line">obj1.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>深拷贝</strong></p>
<p>深拷贝是在浅拷贝的基础上对引用数据类型的每一层属性都进行拷贝，这样就能得到一个全新的、完全不相关的对象了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/03/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="列举一些常见的排序算法"><a href="#列举一些常见的排序算法" class="headerlink" title="列举一些常见的排序算法"></a>列举一些常见的排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡算法的原理：</p>
<ol>
<li>比较相邻的元素，如果第一个比第二个大（升序），就交换</li>
<li>对每一对相邻元素做同样的工作，这样一次遍历，至少保证最后的数最大</li>
<li>对所有元素重复这个步骤</li>
</ol>
<p>冒泡算法图解：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1640863-20190629100410328-1690166625.png" alt="1640863-20190629100410328-1690166625"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序原理：</p>
<ol>
<li>每次寻找序列中最小的数，放到序列末尾</li>
<li>重复这个步骤</li>
</ol>
<p>选择排序原理图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1640863-20190630095656834-1630686887.png" alt="1640863-20190630095656834-1630686887"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序原理：</p>
<ol>
<li>将每一个元素在已排序的序列中插入对应的位置</li>
</ol>
<p>原理图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1640863-20190630104028889-1986666691.gif" alt="1640863-20190630104028889-1986666691"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序原理：</p>
<ol>
<li>挑选一个元素作为基准</li>
<li>重排序列，比基准大的放右边，比基准小的放左边</li>
<li>递归地将分好的两个区再次应用这个规则</li>
</ol>
<p>原理图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1640863-20190630215616679-611890662.png" alt="1640863-20190630215616679-611890662"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left,</span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">&#x27;number&#x27;</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">//分区操作</span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,                      <span class="comment">//设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序原理：</p>
<ol>
<li>将数组拆分称多个小的数组并排序</li>
<li>再将这几个分开的数组两两组合排序</li>
</ol>
<p>原理图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1640863-20190630224318783-93124229.gif" alt="1640863-20190630224318783-93124229"></p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">//采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法效率的比较"><a href="#算法效率的比较" class="headerlink" title="算法效率的比较"></a>算法效率的比较</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1640863-20190630224620390-2089680622.png" alt="1640863-20190630224620390-2089680622"></h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统01-进程与线程</title>
    <url>/2022/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F01-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是具有独立功能的程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>一个进程由数据段，程序段和PCB组成</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ol>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的过程</li>
<li>并发性：内存中由多个进程实体，各进程可以并发地执行</li>
<li>独立性：进程是能独立运行、独立获取资源、独立接收调度的基本单位。进程是资源分配、接收调度的基本单位。</li>
<li>异步性：操作系统要提供“进程同步机制”来解决异步的问题</li>
<li>结构性：每个进程都会配置一个PCB。从结构上看，进程就是由程序段、数据段、PCB组成</li>
</ol>
<h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><p>进程是程序的一次执行过程，是一个动态地过程，所以需要有不同的状态来表示当前进程。</p>
<h4 id="状态（五状态模型）"><a href="#状态（五状态模型）" class="headerlink" title="状态（五状态模型）"></a>状态（五状态模型）</h4><ol>
<li>创建态</li>
<li>运行态：CPU √ 其他所需资源 √</li>
<li>就绪态：CPU X 其他所需资源 √</li>
<li>阻塞态：CPU X 其他所需资源 X</li>
<li>终止态</li>
</ol>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/bac75870ed8213f3c10f2ecc2f7cb9d.png" alt="bac75870ed8213f3c10f2ecc2f7cb9d"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制是用于实现进程状态的转换的</p>
<h4 id="进程控制使用原语实现"><a href="#进程控制使用原语实现" class="headerlink" title="进程控制使用原语实现"></a>进程控制使用原语实现</h4><ul>
<li>原语用关/开中断实现，即在原语执行过程中，不允许中断</li>
<li>原语是一种特殊的程序，只运行在核心态</li>
<li>原语的执行必须一气呵成，不可以中断</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>在多进程处理器中，不同的进程之间可能需要进行通信。下面提供了三种通信方式</p>
<h4 id="共享储存"><a href="#共享储存" class="headerlink" title="共享储存"></a>共享储存</h4><ul>
<li>设置一个共享空间</li>
<li>不同进程要互斥地访问共享空间</li>
<li>有两种方式，一种基于数据结构（低级），另一种基于存储去的共享（高级）</li>
</ul>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><ul>
<li>设置一个特殊的共享文件（管道，其实就是一个缓冲区域）</li>
<li>一个管道只能实现半双工通信，两个管道才能实现全双工</li>
<li>各个进程要互斥访问管道（p,v操作）</li>
<li>写满时候，不能再写。读空时，不能再读</li>
<li>没写满，不能读。没读空，不能写</li>
</ul>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><ul>
<li>传递结构化的消息（消息头/消息体，类似于计算机网络中的报文）</li>
<li>系统提供“发送/接收原语”</li>
<li>有两种方式，一种消息直接挂到接收方的消息队列里面，另一种消息先发到中间件（信箱）</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul>
<li>线程是处理及调度的单位</li>
<li>在多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程之间共享进程的资源</li>
<li>由于共享内存地址空间，统一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程的切换</li>
<li>不同进程中的线程切换，会引起进程的切换</li>
<li>切换同进程内的线程，系统开销会很小</li>
<li>切换进程，系统开销比较大</li>
</ul>
<h2 id="进程的同步和互斥"><a href="#进程的同步和互斥" class="headerlink" title="进程的同步和互斥"></a>进程的同步和互斥</h2><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程是并发进行的，这就带来了异步问题，例如，进程1需要获得进程2的计算结果，如何能保证进程1一定在进程2之后才执行呢？也就是说，各进程的工作推进需要遵循一定的先后顺序。</p>
<h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>进程对于临界资源的访问，需要互斥地进程。即同一时间段内只允许一个进程访问该资源</p>
<p>需要遵循的原则：</p>
<ol>
<li>空闲让进：只要临界资源空闲，且有进程请求资源，则分配资源</li>
<li>忙则等待：如果临界资源已被占用，则将进程挂起，等待资源释放</li>
<li>有限等待：进程挂起时间不能太长，否则会造成进程饥饿</li>
<li>让权等待：优先级高的进程优先使用资源</li>
</ol>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>在实现进程的同步互斥中，人们找到一种比较理想的实现方式，就是信号量机制。</p>
<p>首先规定临界资源的可用数量，用一个公共信号量表示他，每个进程在请求资源的时候，都对该信号量减一（p操作），同时检测此时信号量是否为负（没有可用资源），为负则挂起，不为负数则请求成功。等待进程完成之后，再对信号量加一（v操作），从而实现进程的互斥。</p>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><ol>
<li>S.value表示某种资源数，S.L指向等待资源的队列</li>
<li>P操作中，一定是先S.value–，之后可能需要执行block原语</li>
<li>V操作中，一定是先S.value++，之后可能需要执行wakeup原语</li>
<li>注意：要能够自己推断在什么条件下需要执行block或者wakeup</li>
<li>可以用记录型信号量实现系统资源的“申请”和“释放”</li>
<li>可以用记录型信号量实现进程互斥、进程同步</li>
</ol>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>按某种算法选择一个进程将处理机分配给它</p>
<h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h3><p>高级调度（作业调度）<br>    从后备队列中选择合适的作业将其调入内存，并为其创建进程<br>中级调度（内存调度）<br>    从观其队列中选择合适的进程将其数据调回内存<br>低级调度（进程调度）<br>    从就绪队列中选择一个进程为其分配处理机器</p>
<h3 id="三层调度的联系、对比"><a href="#三层调度的联系、对比" class="headerlink" title="三层调度的联系、对比"></a>三层调度的联系、对比</h3><p>高级调度<br>    外存-&gt;内存（面向作业）<br>中级调度<br>    外存-&gt;内存（面向进程）<br>低级调度<br>    内存-&gt;CPU<br>补充知识<br>    为减轻系统负载，提高资源的利用率，暂时不执行的进程会被调到外存从而变成“挂起态”<br>    七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”，如图二</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/fd03e5db5a7015edaaa8b5248f74944.png" alt="fd03e5db5a7015edaaa8b5248f74944"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度和空间复杂度算法</title>
    <url>/2022/04/11/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h1><p>时间复杂度和空间复杂度是用来衡量一个算法计算消耗资源量级的一种方法。</p>
<h2 id="大O符号表示法"><a href="#大O符号表示法" class="headerlink" title="大O符号表示法"></a>大O符号表示法</h2><ol>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶存在且不是1，那么我们就去除以这个项目相乘的常数</li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> n = <span class="number">10</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		n += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中for循环中的代码会执行n遍，因此他消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示他的时间复杂度</p>
<h3 id="平方阶O-n-2"><a href="#平方阶O-n-2" class="headerlink" title="平方阶O(n^2)"></a>平方阶O(n^2)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            n +=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两层的循环，外层100次和内层100次，总共需要100的平方次也就是O(n^2)</p>
<h3 id="对数阶O-log-n"><a href="#对数阶O-log-n" class="headerlink" title="对数阶O(log n)"></a>对数阶O(log n)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n=<span class="number">1</span>,i=<span class="number">100</span></span><br><span class="line">    <span class="keyword">while</span>(n&lt;i)&#123;</span><br><span class="line">        n*=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个代码可以看出，在while循环里面，每次都将n乘以2.假设循环x次之后，i就大于n了，也就是说2的x次方等于n，2^x=n,即x = log2^n,时间复杂度为：O(logn)</p>
<h3 id="线性对数阶O-n-logN"><a href="#线性对数阶O-n-logN" class="headerlink" title="线性对数阶O(n logN)"></a>线性对数阶O(n logN)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;i)&#123;</span><br><span class="line">            n*=<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="常数阶O-1-1"><a href="#常数阶O-1-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i=<span class="number">1</span>,j=<span class="number">2</span></span><br><span class="line">++i</span><br><span class="line">j++</span><br><span class="line"><span class="keyword">let</span> m = i+j</span><br></pre></td></tr></table></figure>

<p>这段代码中只有三个变量开辟了内存空间，也就是空间复杂度为常数级O(1)</p>
<h3 id="线性阶O-n-1"><a href="#线性阶O-n-1" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(n)</span><br></pre></td></tr></table></figure>

<p>在这段代码中第一行new了一个数组出来，这个数据占用的大小为n，所以时间复杂度为O(n)</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/04/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是一种文本模式，可以用于匹配字符串，由于高效简洁的规则学习之后可以极大的提高效率。</p>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><ol>
<li><p><strong>调用RegExp</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`<span class="subst">$&#123;a&#125;</span>`</span>,<span class="string">&#x27;g&#x27;</span>)<span class="comment">//第一个参数为匹配值，第二个参数为匹配规则</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/c/</span>,<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用字面量</strong>（推荐）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/abc/g</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="built_in">eval</span>(<span class="string">`/<span class="subst">$&#123;num&#125;</span>/g`</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="正则表达式相关的函数"><a href="#正则表达式相关的函数" class="headerlink" title="正则表达式相关的函数"></a>正则表达式相关的函数</h2><ol>
<li><p><strong>test()</strong></p>
<p>作用：检测一个字符串是否含有能够匹配的子串</p>
<p>基本语法：</p>
<p><strong>objReg.test(objStr)</strong><br><strong>objReg 必选项 RegExp对象名称</strong><br><strong>objStr 要进行匹配检测的字符串</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;avs&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/</span>)</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str))	<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>match()</strong></p>
<p>作用：使用正则表达式模式对字符串进行查找，并将包含所有查找结果作为数组返回</p>
<p>基本语法：</p>
<p><strong>stringObj.match(regExp)</strong></p>
<p><strong>stringObj为字符串必选</strong></p>
<p>**rgExp为正则表达式必选项 **</p>
<p>返回值：能匹配返回结果数组，不能则返回null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abcbsdaabba&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab/</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg))		<span class="comment">// [ &quot;ab&quot;, &quot;ab&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>replace()</strong></p>
<p>作用：返回根据匹配规则进行文字替换后的字符串的复制（不改变原字符串）</p>
<p>基本语法：</p>
<p><strong>stringObj.replace(rgExp, replaceText)</strong> </p>
<p><strong>字符串stringObj</strong></p>
<p><strong>rgExp正则表达式</strong></p>
<p>**replaceText所替换的内容 **</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abcdefgab&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab/</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg,<span class="string">&#x27;qq&#x27;</span>))		<span class="comment">// qqcdefgqq</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>search()</strong></p>
<p>作用：返回于正则表达式查找内容匹配的第一个子字符串的位置</p>
<p>基本语法：</p>
<p><strong>stringObj.search(rgExp)</strong></p>
<p><strong>stringObj 必选项</strong> </p>
<p>**rgExp正则表达式 **</p>
<p>返回值：如果找到匹配返回索引，找不到匹配返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aasddsa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/s/</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/f/</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str.search(reg1))		<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(reg2))		<span class="comment">//-1</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>exec()</strong></p>
<p>作用：返回字符串中第一个匹配的内同和子匹配结果的数组。同时记录匹配的位置，每次匹配的时候都会从上一次匹配的位置开始</p>
<p>基本语法：</p>
<p>**objReg.exec(string) **</p>
<p>**objReg.exec(string) **</p>
<p>**string，要进行匹配的字符串 **</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aasddsa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;d&gt;\w&#123;2&#125;)/g</span><span class="regexp">//</span>(?&lt;d&gt;\w)中的?&lt;d&gt;指定这一个捕获组的名称为d</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str))</span><br><span class="line"><span class="comment">//[&quot;aa&quot;,groups: &#123;d:&#x27;aa&#x27;&#125;,index:0,input:&quot;aasddsa&quot;,length:2]</span></span><br><span class="line"><span class="comment">//[&quot;sd&quot;,groups: &#123;d:&#x27;sd&#x27;&#125;,index:0,input:&quot;aasddsa&quot;,length:2]</span></span><br><span class="line"><span class="comment">//[&quot;ds&quot;,groups: &#123;d:&#x27;ds&#x27;&#125;,index:0,input:&quot;aasddsa&quot;,length:2]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>matchAll()</strong></p>
<p>作用：全局匹配字符串</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//使用matchAll匹配全局的字符串</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>wokalimashita<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reg = <span class="regexp">/&lt;(h[1-6])&gt;([\s\S]+?)&lt;\/\1&gt;/gi</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> match = <span class="built_in">document</span>.body.innerHTML.matchAll(reg)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> count = []</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(i <span class="keyword">of</span> match)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(i[<span class="number">2</span>])</span></span><br><span class="line"><span class="javascript">        count.push(i[<span class="number">2</span>])</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.table(count)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220405172538220.png" alt="image-20220405172538220"></p>
</li>
</ol>
<h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><ul>
<li><p><strong>原子表[]和原子组()</strong></p>
<p>在正则匹配中由原子表和原子组的匹配规则，它们的定义是</p>
<p>原子表[]：在原子表中任意匹配一位（[^]在原子表开头加上^可以用于排除原子表中的匹配项）</p>
<ol>
<li><p>原子表字符不解析：放在原子表里面的所有字符都会被当成字符解析，而不具备原子表外的特殊含义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aas.+a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/[.+]/g</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/.+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))	<span class="comment">//[ &quot;.&quot;, &quot;+&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg2))	<span class="comment">//[ &quot;aas.+a&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p>匹配所有内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aas.+a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/[\s\S]+/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))</span><br></pre></td></tr></table></figure></li>
</ol>
<p>原子组()：在原子组中匹配所有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;121212&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/[12]/</span></span><br><span class="line"><span class="keyword">let</span> reg3 = <span class="regexp">/(12|34)/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))		<span class="comment">//[ &quot;1&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg3))		<span class="comment">//[ &quot;12&quot;, &quot;12&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>字符边界^开头和$结尾</strong></p>
<p>在正则匹配中如果想规定匹配是否从头开始或者到尾结束，可以使用^和$。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;123456123456&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\d&#123;8&#125;/</span></span><br><span class="line"><span class="keyword">let</span> reg3 = <span class="regexp">/\d&#123;8&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))		<span class="comment">//[ &quot;12345612&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg3))		<span class="comment">//[ &quot;56123456&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>\w和\W的区别</strong></p>
<p>在正则匹配中\w表示匹配任意数字字母或下划线，那么\W表示匹配任意非数字字母或下划线的字符。其他通配符同理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;1515asd_@&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\W+/</span></span><br><span class="line"><span class="keyword">let</span> reg3 = <span class="regexp">/\w+/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))		<span class="comment">//[ &quot;@&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg3))		<span class="comment">//[ &quot;1515asd_&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>汉字与字符属性</strong></p>
<p>在正则匹配中是有不同的语言系统的，它们之间的匹配规则也不一样，一些同属性的符号也是可以通过属性来匹配的。使用\p{属性}进行匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;我是李华,123&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/\p&#123;sc=Han&#125;+/gu</span>  <span class="comment">//汉字是unicode系统要加u匹配</span></span><br><span class="line"><span class="keyword">let</span> reg3 = <span class="regexp">/\p&#123;P&#125;/gu</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))		<span class="comment">//[ &quot;我是李华&quot; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg3))		<span class="comment">//[ &quot;,&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>批量使用正则表达式校验</strong></p>
<p>在正则匹配中我们可以同时对一个字符串匹配多个规则，达到多重独立验证的目的；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//使用正则批量匹配完成密码强度验证</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;note&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> input1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#input&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> note = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#note&#x27;</span>)</span></span><br><span class="line"><span class="javascript">input1.addEventListener(<span class="string">&quot;keyup&quot;</span>,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> value = e.target.value;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> reg = [<span class="regexp">/[A-Z]/</span>,<span class="regexp">/[a-z]/</span>,<span class="regexp">/\p&#123;P&#125;/u</span>]</span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> level = <span class="number">0</span>,str = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">	reg.map(<span class="function"><span class="params">m</span> =&gt;</span> m.test(value)?level++:<span class="number">0</span>)</span></span><br><span class="line"><span class="javascript">	<span class="keyword">switch</span>(level)&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">case</span> <span class="number">0</span> :&#123;</span></span><br><span class="line"><span class="javascript">			str=<span class="string">&quot;弱唉&quot;</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">case</span> <span class="number">1</span> :&#123;</span></span><br><span class="line"><span class="javascript">			str=<span class="string">&quot;中&quot;</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">case</span> <span class="number">2</span> :&#123;</span></span><br><span class="line"><span class="javascript">			str=<span class="string">&quot;强啊&quot;</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">case</span> <span class="number">3</span> :&#123;</span></span><br><span class="line"><span class="javascript">			str=<span class="string">&quot;强啊&quot;</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">break</span></span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(value,level)</span></span><br><span class="line"><span class="javascript">	note.innerText = str</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>$和$&amp;(匹配的内容),$`(匹配的内容的之前的内容),$’(匹配的内容的之后的内容)</strong></p>
<p>正则匹配中可以用$符号去指代匹配的内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;$$adsaa$$dsa $$3213$$fsdf&#x27;</span></span><br><span class="line"><span class="keyword">let</span> result = str.replace(<span class="regexp">/\$\$(\w+)\$\$(\w+)/g</span>,<span class="string">&quot;$1-$2&quot;</span>)<span class="comment">//其中$1$2指代的是第几个原子组的匹配内容</span></span><br><span class="line"><span class="built_in">console</span>.log(result)		<span class="comment">//adsaa-dsa 3213-fsdf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;==absc$$&#x27;</span>	</span><br><span class="line"><span class="keyword">let</span> result1 = str1.replace(<span class="regexp">/[a-z]+/g</span>,<span class="string">&quot;$`&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result1)	<span class="comment">//====$$</span></span><br><span class="line"><span class="keyword">let</span> result2 = str1.replace(<span class="regexp">/[a-z]+/g</span>,<span class="string">&quot;$&#x27;&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result2)	<span class="comment">//==$$$$</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>?=断言匹配,?&lt;=断言匹配,?!,断言匹配?&lt;!断言匹配</strong></p>
<p>?=断言匹配是匹配内容后面的内容的，?&lt;=断言匹配时匹配内容前面的内容的</p>
<p>?!匹配后面不是什么?&lt;=匹配前面不是什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;你好123你好&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/你好/g</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg))		<span class="comment">//[ &quot;你好&quot;, &quot;你好&quot; ]</span></span><br><span class="line"><span class="keyword">let</span> reg1 = <span class="regexp">/你好(?=\d)/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1))	<span class="comment">//[ &quot;你好&quot; ]</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/(?&lt;=\d)你好/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg2))	<span class="comment">//[ &quot;你好&quot; ]</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>小测验</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.cn.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baidu.com&quot;</span>&gt;</span>百度1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://baidu.com.cn&quot;</span>&gt;</span>百度2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> arr = <span class="built_in">document</span>.body.innerHTML</span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> result = arr.matchAll(<span class="regexp">/&lt;a.*href=([&quot;&#x27;])(.*?)\1&gt;(.*?)&lt;/g</span>)</span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> count = []</span></span><br><span class="line"><span class="javascript">	<span class="keyword">for</span>(i <span class="keyword">of</span> result)&#123;</span></span><br><span class="line"><span class="javascript">		count.push(&#123;<span class="attr">link</span>:<span class="string">`<span class="subst">$&#123;i[<span class="number">2</span>]&#125;</span>`</span>,<span class="attr">title</span>:<span class="string">`<span class="subst">$&#123;i[<span class="number">3</span>]&#125;</span>`</span>&#125;)</span></span><br><span class="line"><span class="javascript">	&#125;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(count)</span></span><br><span class="line"><span class="javascript">    <span class="comment">//[	Object &#123; link: &quot;https://www.baidu.cn.com&quot;, title: &quot;百度&quot; &#125;,</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">//	Object &#123; link: &quot;https://baidu.com&quot;, title: &quot;百度1&quot; &#125;,</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">//	Object &#123; link: &quot;http://baidu.com.cn&quot;, title: &quot;百度2&quot; &#125;]</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈BFC</title>
    <url>/2022/03/29/%E6%B5%85%E8%B0%88BFC/</url>
    <content><![CDATA[<h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><p>BFC（Block Formatting Context），中文称块级格式化上下文，是页面中的一块渲染区域，有别于页面的其他地方，它有一套属于自己的渲染规则，它决定了元素如何对齐内容进行布局，以及与其他元素的关系和相互作用。</p>
<p>简而言之：BFC就是一个独立的布局环境，BFC内部的元素布局与外部互不影响</p>
<h2 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h2><table>
<thead>
<tr>
<th>元素或属性</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>根元素</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>left、right</td>
</tr>
<tr>
<td>position</td>
<td>absolute、fixed</td>
</tr>
<tr>
<td>overflow</td>
<td>auto、scroll、hidden</td>
</tr>
<tr>
<td>display</td>
<td>inline-block、table-cell</td>
</tr>
</tbody></table>
<h2 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h2><ol>
<li>内部的BOX会在垂直方向上一个接着一个地放置</li>
<li>BOX垂直方向上的距离由margin决定。属于同一个BFC的两个相邻的BOX的margin会重叠。</li>
<li>每个盒子的左外边框紧挨着包含块的左边框，即使是浮动元素也是如此</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素</li>
<li>计算BFC的高度时候，浮动子元素也参与计算</li>
</ol>
<h2 id="BFC的应用"><a href="#BFC的应用" class="headerlink" title="BFC的应用"></a>BFC的应用</h2><ul>
<li><p>解决子元素使用浮动父元素高度坍塌的问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid pink;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305204614141.png" alt="image-20220305204614141"></p>
<h4 id="使用BFC后"><a href="#使用BFC后" class="headerlink" title="使用BFC后"></a>使用BFC后</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    //触发BFC，规则上计算高度的时候浮动子元素也会被包含在内</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">10px</span> solid pink;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305204724251.png" alt="image-20220305204724251"></p>
</li>
<li><p>浮动元素覆盖正常元素（可用于实现两栏、三栏自适应布局）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305211642477.png" alt="image-20220305211642477"></p>
<h4 id="使用BFC后-1"><a href="#使用BFC后-1" class="headerlink" title="使用BFC后"></a>使用BFC后</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220305211912897.png" alt="image-20220305211912897"></p>
</li>
<li><p>单行文本超出省略</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本例调用的函数会执行一个计算，然后返回结果：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">	<span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">		<span class="attribute">width</span>:<span class="number">50vw</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">overflow</span>:hidden;</span></span><br><span class="line"><span class="css">		<span class="attribute">white-space</span>: nowrap;	<span class="comment">/*规定文本不进行换行*/</span></span></span><br><span class="line"><span class="css">		<span class="attribute">text-overflow</span>: ellipsis;	<span class="comment">/*当对象内文本溢出时显示省略标记（...）*/</span></span></span><br><span class="line"><span class="css">	&#125;	</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存机制</title>
    <url>/2022/04/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了节约网络的资源，加速浏览。浏览器会对最近请求过的一些文档进行存储，当访问者再次请求这个页面的时候，浏览器就可以从本地加载文档，而不用等待网络中的文档，可以加速页面的预览。</p>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器的缓存策略分为两种，强制缓存和协商缓存，并且缓存策略都是通过设置http Header来实现的</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>设置过期的具体时间，在这个时间内再次请求，则命中强缓存</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>设置过期的时间段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max-age = 300</span><br></pre></td></tr></table></figure>

<p>代表在这个请求正确返回之后的300秒内再次请求，则命中强缓存</p>
<h5 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h5><ol>
<li>Expires是http1.0的产物，Cache-Control是http1.1的产物</li>
<li>Cache-Control优先级更高</li>
<li>Expires更多的是为了兼容旧环境</li>
<li>Expires有一个缺陷，就是过期时间是服务器的具体时间，但是如果客户端的事件和服务器的时间相差比较大，那么Expires的过期时间就不一定准确。</li>
</ol>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><h5 id="ETag和If-None-match"><a href="#ETag和If-None-match" class="headerlink" title="ETag和If-None-match"></a>ETag和If-None-match</h5><p>Etag是上一次加载资源的时候，服务器返回的respone header，是一种对该资源的唯一标识，只要资源发生了变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求的时候，会将上一次返回的Etag值放到request header里的If-None-match里面，服务器接收到If-None-match，会和源文件的Etag值比较，如果相同。则命中协商缓存。</p>
<h5 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h5><p>Last-Modified是该资源文件最后一次更改时间，服务器会在response  header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request  header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。</p>
<h5 id="两者的区别-1"><a href="#两者的区别-1" class="headerlink" title="两者的区别"></a>两者的区别</h5><ol>
<li>在方式上，Etag是对资源的一种唯一标识，而Last-Modified是对资源更改时间的标识</li>
<li>在精确度上Etag更高，因为Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改。</li>
<li>在性能上Last-Modified更好，因为Etag每次文件改变都要重新计算</li>
<li>Etag优先级更高</li>
</ol>
<h2 id="浏览器缓存的过程"><a href="#浏览器缓存的过程" class="headerlink" title="浏览器缓存的过程"></a>浏览器缓存的过程</h2><ol>
<li>浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求并下载下来，并把响应头和该请求的返回时间一并缓存</li>
<li>下一次加载资源的时候，先比较当前时间和上一次返回200时的时间差，如果没有超过Cache-Control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取文件；如果过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；</li>
<li>服务器收到请求后，优先根据etag的值判断被请求的文件有没有做修改，没有则命中协商缓存，返回304；发生改变则返回新的文件和新的Etag</li>
</ol>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/1588986700552-360c5db2-a839-46c6-9ad2-66b9a2195607.png" alt="1588986700552-360c5db2-a839-46c6-9ad2-66b9a2195607"></p>
<h2 id="用户行为对于缓存机制的影响"><a href="#用户行为对于缓存机制的影响" class="headerlink" title="用户行为对于缓存机制的影响"></a>用户行为对于缓存机制的影响</h2><ul>
<li>地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制</li>
<li>F5刷新，浏览器会设置max-age=0,跳过强缓存判断，会进行协商缓存判断</li>
<li>ctrl+F5刷新，跳过强制缓存和协商缓存，直接从服务器拉取资源。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><h5 id="内存缓存和硬盘缓存有什么区别"><a href="#内存缓存和硬盘缓存有什么区别" class="headerlink" title="内存缓存和硬盘缓存有什么区别"></a>内存缓存和硬盘缓存有什么区别</h5><table>
<thead>
<tr>
<th>区别</th>
<th>内存缓存</th>
<th>硬盘缓存</th>
</tr>
</thead>
<tbody><tr>
<td>储存内容</td>
<td>JS，字体，图片等</td>
<td>CSS等</td>
</tr>
<tr>
<td>读取速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>时效性</td>
<td>进程关闭则清空</td>
<td>可以缓存较长时间</td>
</tr>
<tr>
<td>空间</td>
<td>空间小</td>
<td>空间大</td>
</tr>
</tbody></table>
<h5 id="浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？"><a href="#浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？" class="headerlink" title="浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？"></a>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</h5><p>判断是否命中强制缓存：当命中强制缓存时，状态码为200, 请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。from  memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory  &gt; disk。</p>
<h5 id="为什么CSS会放在硬盘缓存中？"><a href="#为什么CSS会放在硬盘缓存中？" class="headerlink" title="为什么CSS会放在硬盘缓存中？"></a>为什么CSS会放在硬盘缓存中？</h5><p>因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。</p>
<h5 id="那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？"><a href="#那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？" class="headerlink" title="那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？"></a>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</h5><p>这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器跨域</title>
    <url>/2022/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="浏览器跨域"><a href="#浏览器跨域" class="headerlink" title="浏览器跨域"></a>浏览器跨域</h1><h3 id="跨域的定义"><a href="#跨域的定义" class="headerlink" title="跨域的定义"></a>跨域的定义</h3><p>跨域是指从一个域名的网页去请求另一个域名的资源，就会发生跨域。只要协议，域名，端口有任何一个不同就算做跨域。</p>
<p>浏览器执行JavaScript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</p>
<p>对于端口和协议的不同，只能通过后台来解决。</p>
<h3 id="浏览器为什么要限制跨域"><a href="#浏览器为什么要限制跨域" class="headerlink" title="浏览器为什么要限制跨域"></a>浏览器为什么要限制跨域</h3><p><strong>安全问题</strong>：如果一个网页可以随意的访问另外一个网站的资源，那么就有可能再客户完全不知情的情况下获取客户的个人资料从而出现安全问题</p>
<h3 id="为什么要进行跨域"><a href="#为什么要进行跨域" class="headerlink" title="为什么要进行跨域"></a>为什么要进行跨域</h3><p>设想一个场景，一个公司有很多的子域，这些子域之间进行访问资源的时候就需要进行跨域</p>
<h3 id="跨域的解决办法"><a href="#跨域的解决办法" class="headerlink" title="跨域的解决办法"></a><strong>跨域的解决办法</strong></h3><ol>
<li><h5 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h5><p>CORS允许浏览器向跨域的服务器发出XMLHttpRequest请求，克服了AJAX只能同源使用的限制。</p>
<p><strong>CORS需要服务器和浏览器都支持</strong>目前所有浏览器都支持CORS。整个CORS通信完全由浏览器自动进行，对于开发者来说，CORS通信与普通的AJAX通信没有任何区别，代码完全一致。浏览器一旦发现AJAX进行跨域请求，就会自动添加一些请求头，有时还会额外请求，但用户不会感知。因此，实现CORS通信的关键时服务器端要支持。</p>
</li>
<li><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p><strong>原理</strong>：通过script标签引入一个js文件（script标签不受跨域限制），这个js 文件载入成功后会执行我们在url中指定的函数，并且会把我们需要的json数据作为参数传入。JSONP需要服务器进行配合，返回一个可执行的js我呢见，其中包含所需数据。</p>
<p><strong>优点</strong>：兼容性好</p>
<p><strong>缺点</strong>：它只支持GET请求而不支持POST等其他类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何让进行Javascript调用的问题。</p>
<h6 id="手写一个简单的JSONP例子"><a href="#手写一个简单的JSONP例子" class="headerlink" title="手写一个简单的JSONP例子"></a>手写一个简单的JSONP例子</h6><p>服务端部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//	因为我们是利用script标签的src请求这个接口地址http://127.0.0.1:8081/，所以我们需要设置响应头为js格式</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/javascript&#x27;</span> &#125;);</span><br><span class="line">    <span class="comment">//然后返回js格式代码回去</span></span><br><span class="line">    response.end(<span class="string">&#x27;var a=1&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="number">8081</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><h5 id="通过修改document-domain来跨子域"><a href="#通过修改document-domain来跨子域" class="headerlink" title="通过修改document.domain来跨子域"></a>通过修改document.domain来跨子域</h5><p><strong>原理</strong>：通过修改域名设置成相同的主域就可以跨域</p>
<p>document.domain是有限制的，我们只能设置成高一级的域名或者自身，且主域必须相同。所以只适用不同子域的框架间交互</p>
</li>
<li><h5 id="使用window-name进行跨域"><a href="#使用window-name进行跨域" class="headerlink" title="使用window.name进行跨域"></a>使用window.name进行跨域</h5><p><strong>原理</strong>：Window对象的name属性有个特点：即在一个窗口的生命周期内，该窗口所有载入的网页共享一个window.name，且每个页面对window.name都有读写权限</p>
<p>在网页中使用一个隐藏的iframe来充当中间人，让这个iframe去请求数据，然后再网页中获取这个iframe的数据。还必须把这个iframe的src设成跟a.html页面同一个域才行，否则根据同源策略，获取不到iframe的数据。</p>
</li>
<li><h5 id="使用h5的window-postMessage进行跨域"><a href="#使用h5的window-postMessage进行跨域" class="headerlink" title="使用h5的window.postMessage进行跨域"></a>使用h5的window.postMessage进行跨域</h5><p><strong>原理</strong>：<strong>window.postMessage</strong>(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>
<p>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。</p>
<p>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。</p>
</li>
<li><h5 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h5><p><strong>原理</strong>：web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</p>
<p>web sockets原理：在<a href="http://lib.csdn.net/base/javascript">js</a>创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划</title>
    <url>/2022/01/24/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划，简称DP，将问题分解为互相重叠的子问题，通过反复求解子问题解决原问题就是动态规划，如果某一问题有很多重叠子问题，使用动态规划来解决是比较有效的。</p>
<p>求接动态规划的核心问题就是穷举，但是这类问题穷举存在重叠子问题，直接求解效率回十分低下。动态规划问题一定回具备最优子结构，才能通过子问题的最值得到原问题的最值。另外，虽然动态规划的核心是穷举求最值，但是穷举所有可行解并不是一件容易的事，只有列出正确的”状态转移方程”，才能正确的穷举。重叠子问题、最有子结构、状态转移方程就是动态规划的三要素。</p>
<h4 id="动态规划和其他算法的区别："><a href="#动态规划和其他算法的区别：" class="headerlink" title="动态规划和其他算法的区别："></a>动态规划和其他算法的区别：</h4><ol>
<li>动态规划和分治的区别：动态规划和分治都有最优子结构 ，但是分治的子问题不重叠</li>
<li>动态规划和贪心的区别：动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优解，所以它永远是局部最优，但是全局的解不一定是最优的。</li>
<li>动态规划和递归的区别：递归和回溯可能存在非常多的重复计算，动态规划可以用递归加记忆化的方式减少不必要的重复计算</li>
</ol>
<h4 id="解动态规划题目的步骤"><a href="#解动态规划题目的步骤" class="headerlink" title="解动态规划题目的步骤"></a>解动态规划题目的步骤</h4><ol>
<li>根据重叠子问题定义状态</li>
<li>寻找最优子结构推导状态转移方程</li>
<li>确定dp初始状态</li>
<li>确定输出值</li>
</ol>
<h4 id="力扣509-斐波那契数"><a href="#力扣509-斐波那契数" class="headerlink" title="力扣509. 斐波那契数"></a>力扣<a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><ul>
<li>思路：对于除了第一二个数外的数，都是由前两个数求和而得出，因此有状态转移方程dp[i] = dp[i-1]+dp[i-2]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">const</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//自底向上计算每个状态</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="力扣62-不同路径"><a href="#力扣62-不同路径" class="headerlink" title="力扣62. 不同路径"></a>力扣<a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4><ul>
<li>思路:由于在每个位置只能向下或者向右， 所以每个坐标的路径和等于上一行相同位置和上一列相同位置不同路径的总和，状态转移方程：<code>f[i][j] = f[i - 1][j] + f[i][j - 1]</code>;</li>
<li>复杂度:时间复杂度<code>O(mn)</code>。空间复杂度<code>O(mn)</code>，优化后<code>O(n)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>)); <span class="comment">//初始dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="comment">//初始化列</span></span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="comment">//初始化行</span></span><br><span class="line">        f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态压缩</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">1</span>; r &lt; n; r++) &#123;</span><br><span class="line">            cur[r] = cur[r - <span class="number">1</span>] + cur[r];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h4><ul>
<li>思路：和62题一样，区别就是遇到障碍直接返回0</li>
<li>复杂度：时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>，状态压缩之后是o(n)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">const</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="built_in">Array</span>(m)</span><br><span class="line">        .fill()</span><br><span class="line">        .map(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>)); <span class="comment">//初始dp数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] === <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//初始列</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][i] === <span class="number">0</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//初始行</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">//遇到障碍直接返回0</span></span><br><span class="line">            dp[i][j] = obstacleGrid[i][j] === <span class="number">1</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态压缩</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span> (<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">let</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="built_in">Array</span>(n).fill(<span class="number">0</span>); <span class="comment">//用0填充，因为现在有障碍物，当前dp数组元素的值还和obstacleGrid[i][j]有关</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//第一列 暂时用1填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//注意条件，遇到障碍物dp[j]就变成0，这里包含了第一列的情况</span></span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//只有当j&gt;0 不是第一列了才能取到j - 1</span></span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><ul>
<li>思路：<code>dp[i]</code> 表示<code>i</code>的完全平方和的最少数量，<code>dp[i - j * j] + 1</code>表示减去一个完全平方数<code>j</code>的完全平方之后的数量加1就等于<code>dp[i]</code>，只要在<code>dp[i]</code>, <code>dp[i - j * j] + 1</code>中寻找一个较少的就是最后<code>dp[i]</code>的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numSquares = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [...Array(n)].map(<span class="function">(<span class="params">_</span>) =&gt;</span> <span class="number">0</span>); <span class="comment">//初始化dp数组 当n为0的时候</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i; <span class="comment">// 最坏的情况就是每次+1 比如: dp[3]=1+1+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; i - j * j &gt;= <span class="number">0</span>; j++) &#123;<span class="comment">//枚举前一个状态</span></span><br><span class="line">            dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - j * j] + <span class="number">1</span>); <span class="comment">// 动态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2022/04/14/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="JavaScript中的闭包"><a href="#JavaScript中的闭包" class="headerlink" title="JavaScript中的闭包"></a>JavaScript中的闭包</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。导致外部函数被销毁的时候由于内部对象仍然被引用，所以会将这个内部对象一直保持的现象，就叫做闭包。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>闭包指的是哪些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparison</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> val1 = obj1[name]</span><br><span class="line">		<span class="keyword">let</span> val2 = obj2[name]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(val1&gt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compare  = createComparison(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123;<span class="attr">name</span>:<span class="string">&quot;jojo&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;stand&quot;</span>&#125;)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>这个例子中的val1和val2引用了来自函数外的变量，在这个内部的匿名数被返回并在其他的地方中使用的时候，它依然引用着这个变量。这是应为内部函数的作用域包含createComparison（）函数的作用域。</p>
<p>在调用一个函数的时候，会为这个函数创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域一直向外串起了所有包含函数的活动对象，直到全局上下文才终止。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>函数执行的时候，每个执行上下文都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部的上下文中的叫活动对象，只在函数的执行期间存在。</p>
<p>函数内部的代码在访问变量的时候，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被摧毁。只剩下全局作用域。但是在闭包中，由于返回的函数保持着对局部活动对象的引用，此时垃圾回收机制会被阻止回收被引用的变量，因为如果这个变量被销毁了，那么函数的引用将会报错。这样就产生了没有被回收的外部变量。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>由于闭包会保留它们包含的函数作用域，因此会比其他函数更加占用内存，所以要谨慎地使用闭包。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>面经摘抄01</title>
    <url>/2022/03/07/%E9%9D%A2%E7%BB%8F%E6%91%98%E6%8A%8401/</url>
    <content><![CDATA[<h1 id="面经摘抄"><a href="#面经摘抄" class="headerlink" title="面经摘抄"></a>面经摘抄</h1><p>从各大网站面经中学习到的不错的问题</p>
<ol>
<li><h5 id="讲了讲有哪些宏任务和微任务，以及它们的循环方式"><a href="#讲了讲有哪些宏任务和微任务，以及它们的循环方式" class="headerlink" title="讲了讲有哪些宏任务和微任务，以及它们的循环方式"></a>讲了讲有哪些宏任务和微任务，以及它们的循环方式</h5><p>宏任务：JavaScript大部分代码，SetTimeout，setInterval，setImmediate（Nodejs环境）</p>
<p>微任务：Promise.then，Promise,catch，Promise.finally，process.nextTick(Nodejs环境)</p>
<p>循环方式如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/v2-e6dd78c74cb671dd9408c2273308a265_1440w.jpg" alt="v2-e6dd78c74cb671dd9408c2273308a265_1440w"></p>
<h6 id="思考：如何实现这种循环？"><a href="#思考：如何实现这种循环？" class="headerlink" title="思考：如何实现这种循环？"></a>思考：如何实现这种循环？</h6><p>考虑到事件循环是在一个队列中的顺序循环，所以可以考虑使用链表这种数据结构存储任务，既保证队列，又保证顺序，再将宏任务和微任务的规则用代码实现。</p>
</li>
<li><h5 id="垂直水平居中方式"><a href="#垂直水平居中方式" class="headerlink" title="垂直水平居中方式"></a>垂直水平居中方式</h5><ul>
<li><p>使用绝对定位脱离文档流的方法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220307201830955.png" alt="image-20220307201830955"></p>
</li>
<li><p>使用flex弹性定位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100vw</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220307202159649.png" alt="image-20220307202159649"></p>
</li>
</ul>
</li>
<li><h5 id="Set、Map、WeakMap、WeakSet-区别（各自的-API，WeakMap-和-WeakSet-可迭代吗，JS-垃圾回收机制对-WeakMap-和-WeakSet-的影响）"><a href="#Set、Map、WeakMap、WeakSet-区别（各自的-API，WeakMap-和-WeakSet-可迭代吗，JS-垃圾回收机制对-WeakMap-和-WeakSet-的影响）" class="headerlink" title="Set、Map、WeakMap、WeakSet 区别（各自的 API，WeakMap 和 WeakSet 可迭代吗，JS 垃圾回收机制对 WeakMap 和 WeakSet 的影响）"></a>Set、Map、WeakMap、WeakSet 区别（各自的 API，WeakMap 和 WeakSet 可迭代吗，JS 垃圾回收机制对 WeakMap 和 WeakSet 的影响）</h5><p>WeakMap和WeakSet相比与Map和Set就像是低配版，它们对于键值对或值的关联性不够紧密，当键值对的值发生变化的时候，Weak的关联会断开。</p>
<p>WeakMap和WeakSet不可以迭代，因为它们的结构松散，随时可能发生改变，迭代没有意义。js垃圾回收机制也不受影响，如果是Map和Set会阻止垃圾回收，只要它们还保留着引用。</p>
</li>
<li><h5 id="Vue-组件间通信方式"><a href="#Vue-组件间通信方式" class="headerlink" title="Vue 组件间通信方式"></a>Vue 组件间通信方式</h5><ul>
<li><p>prop（父传子）</p>
</li>
<li><p>emit（子传父）</p>
</li>
<li><p>this.$parent（Vue3中被废弃）</p>
</li>
<li><p>事件总线bus</p>
<p>在项目创建一个额外的js文件作为通信中间件</p>
</li>
<li><p>VueX</p>
<p>Vue官方推荐使用的方式，不过如果项目不大没有必要。</p>
</li>
</ul>
</li>
<li><h5 id="Vue-中-key-的作用，为什么有高效性？"><a href="#Vue-中-key-的作用，为什么有高效性？" class="headerlink" title="Vue 中 key 的作用，为什么有高效性？"></a>Vue 中 key 的作用，为什么有高效性？</h5><p>Vue中的Key可以用来唯一确定一个DOM元素，从而使diff算法更加高效。</p>
<p>因为Vue实现了一套虚拟DOM系统，具体原理就是因为当页面做出变化的时候每次都直接修改真实DOM会比较浪费资源，所以Vue中每次页面发生变化的时候都是优先在虚拟DOM中产生变化，然后diff算法会去逐一比较同一层次的真实DOM和虚拟DOM，然后以最小量的方式去修改真实DOM，Key的作用就是在diff算法中使Vue更容易定位DOM。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/20191118120109728.png" alt="20191118120109728"></p>
</li>
<li><h5 id="单行文本省略，多行文本省略分情况实现"><a href="#单行文本省略，多行文本省略分情况实现" class="headerlink" title="单行文本省略，多行文本省略分情况实现"></a>单行文本省略，多行文本省略分情况实现</h5><p>单文本</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>; </span><br><span class="line">    <span class="comment">/*设置文字在一行显示，不能换行*/</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/*规定当文本溢出时，显示省略符号来代表被修剪的文本*/</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis; </span><br><span class="line">    <span class="comment">/*文字长度超出限定宽度，则隐藏超出的内容*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="async和await的原理"><a href="#async和await的原理" class="headerlink" title="async和await的原理"></a>async和await的原理</h5><p>async函数返回一个Promise对象，当函数执行的时候，一旦遇到awiat就会先返回，等到触发的异步操作完成，才会接着执行函数体后面的的语句。async函数就是Generator函数的语法糖。<a href="https://stoneocean.top/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/">详见</a></p>
</li>
<li><h5 id="Http0-9，Http1-0，Http2-0，Http3-0简介"><a href="#Http0-9，Http1-0，Http2-0，Http3-0简介" class="headerlink" title="Http0.9，Http1.0，Http2.0，Http3.0简介"></a>Http0.9，Http1.0，Http2.0，Http3.0简介</h5><p>Http0.9是一个初期基本协议，只有get请求，只用于获取html</p>
<p>Http1.0支持 HEAD，POST 方法，支持状态码，但是规定只能短链接，频繁请求会使网络负担大</p>
<p>Http1.1支持了TCP长连接，同时引入Cookie网络安全机制</p>
<p>Http2.0支持二进制传输，使用HPACK算法压缩头部，可以同时在一个连接中发送多个请求（多路复用）。</p>
<p><strong>HPACK实现原理</strong>：两张表，动态表和静态表</p>
<ol>
<li>静态表是将头部的信息如请求协议get用1表示，post用2表示，对照静态表将原本的字符串压缩成数字。</li>
<li>动态表是将剩下由用户定义的变量用哈夫曼编码优化</li>
</ol>
<p>Http3.0添加QUIC协议，基于UDP协议，之前的版本都只支持TCP协议，如果网络不好或者频繁切换网络环境的话TCP会一直断开重连，UCP协议解决了。</p>
<p>1.<strong>线头阻塞问题</strong>：TCP协议重如果又数据丢包，需要等待重传，浪费后续资源</p>
<p><strong>原理</strong>：QUIC协议在遇到某个stream传输失败的时候不会阻塞等待，而是继续向下接收数据，因为有一个计数变量，所以哪怕到达顺序不一样也能还原，因为没有线头阻塞，这在文件流传输等不要求高可靠性的场景下很有用。</p>
<p>2.<strong>切换网络时候保持连接</strong>：从4g切换为5g时候，TCP协议会重连，但是UDP协议通过内建协议不必重连。</p>
<p><strong>原理</strong>：QUIC建立协议的时候会随机产生一个64位的ID，接收方确认不依靠ip地址，而是依靠这个ID，所以哪怕网络环境变化，只要ID没变，链接就可以保持。</p>
</li>
<li><h5 id="Nodejs使用Proxy代理跨域的原理"><a href="#Nodejs使用Proxy代理跨域的原理" class="headerlink" title="Nodejs使用Proxy代理跨域的原理"></a>Nodejs使用Proxy代理跨域的原理</h5><p>在浏览器中跨域访问是被禁止的，但是在服务器中没有这个限制，所以我们想要在前端实现跨域请求的话可以把请求发送到自己的服务端，再让服务端去请求目标服务器，这样就不会有跨域的限制。</p>
<h6 id="配置代码："><a href="#配置代码：" class="headerlink" title="配置代码："></a>配置代码：</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dev&#123;</span><br><span class="line">    <span class="attr">proxyTable</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">            <span class="attr">target</span>:<span class="string">&#x27;http://192.168.0.1&#x27;</span>,<span class="comment">//要代理的域名</span></span><br><span class="line">            <span class="attr">changeOrigin</span>:<span class="literal">true</span>,<span class="comment">//允许跨域</span></span><br><span class="line">            pathRewrite：&#123;</span><br><span class="line">                ‘/api<span class="string">&#x27;:&#x27;</span><span class="string">&#x27;,//这个是定义要访问的路径</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：以这种写法，会将请求中所有带有/api字段替换掉，因此在代理数量比较多的时候容易出问题。</p>
</li>
<li><h5 id="JavaScript异步发展史"><a href="#JavaScript异步发展史" class="headerlink" title="JavaScript异步发展史"></a>JavaScript异步发展史</h5><p>JavaScript本身是单线程语言，也就是同步的，这意味着有可能会阻塞，当有一个任务需要的时间较长的时候，后面的代码会需要等待他完成后才能执行。而异步方式不会，异步代码不需要阻塞，可以优先让其他任务执行。</p>
<p>异步发展史有：回调函数——&gt;Promise——&gt;Generator——&gt;async/await</p>
<ol>
<li><p>回调函数：callback</p>
<p>就是在需要异步的地方用回调函数还函数的末尾调用其他函数。</p>
<p>优势：简单</p>
<p>缺点：回调地狱</p>
</li>
<li><p>Promise是ES6最重要的内容之一，他在一定程度上解决了回调地狱。</p>
<p>优势：状态只会改变一次，任何时候都可以得到结果</p>
<p>缺点：无法取消Promise，当处于pending状态时候，无法得知进展到哪一个阶段，错误不能够被try catch</p>
</li>
<li><p>Generator又称为生成器，就是使用function* func()这种方式去定义函数，这样生成的函数就是生成器，他的特点就是可以使用yield打断点，每次执行到yield的时候，函数都会暂停，并返回一个值，直到next（）命令才向下执行。</p>
</li>
<li><p>async/await其实就是Generator的一个语法糖。使用方式是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">await</span> readFile(A,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="观察者模式vs发布订阅模式"><a href="#观察者模式vs发布订阅模式" class="headerlink" title="观察者模式vs发布订阅模式"></a>观察者模式vs发布订阅模式</h5><p>在23中设计模式中并没有发布订阅模式，这个模式其实可以看成时观察者模式的变种。</p>
<p>总所周知，观察者模式中只要被观察的对象发生了改变，就会通知观察者发生变化（Vue采用了这种方式实现响应式原理）</p>
<p>而在发布订阅模式中，观察者和被观察者时不直接通信的。它们之间通过第三者进行间接通信，可以说观察者模式两者是松耦合的，而发布订阅模式是完全解耦的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/v2-540a78ba3127b0c6882adc668e7a3535_r.jpg" alt="v2-540a78ba3127b0c6882adc668e7a3535_r"></p>
</li>
<li><h5 id="webpack中loader和plugin的区别"><a href="#webpack中loader和plugin的区别" class="headerlink" title="webpack中loader和plugin的区别"></a>webpack中loader和plugin的区别</h5><p>loader是用于加载某些资源文件的，因为webpack本身只能打包commonjs规范的js文件，这就需要用到loader对其他类型的文件进行转化。</p>
<p>plugin是用于扩展webpack的功能的，loader也算是变相扩展了webpack的内容。plugin的功能更加的丰富，而不仅局限与资源的加载，并且整个编译周期都有用。</p>
</li>
<li><h5 id="哈希表的原理和哈希算法的原理"><a href="#哈希表的原理和哈希算法的原理" class="headerlink" title="哈希表的原理和哈希算法的原理"></a>哈希表的原理和哈希算法的原理</h5><p>哈希表hash table(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。</p>
<p>而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>
<p>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 哈希表又叫做散列表，分为“开散列” 和“闭散列”。</p>
</li>
<li><h5 id="浏览器缓存-强缓存、协商缓存-为什么cache-control优先级更高"><a href="#浏览器缓存-强缓存、协商缓存-为什么cache-control优先级更高" class="headerlink" title="浏览器缓存,强缓存、协商缓存,为什么cache-control优先级更高"></a>浏览器缓存,强缓存、协商缓存,为什么cache-control优先级更高</h5><p>浏览器缓存分为强缓存和协商缓存，当存在缓存时，客户端第一次向服务器请求数据时，客户端会缓存到内存或者硬盘当中，当第二次获取相同的资源，强缓存和协商缓存的应对方式有所不同。</p>
<h6 id="强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存-硬盘中间读取"><a href="#强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存-硬盘中间读取" class="headerlink" title="强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取"></a>强缓存：当客户端第二次向服务器请求相同的资源时，不会向服务器发送请求，而是直接从内存/硬盘中间读取</h6><h6 id="协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存-硬盘中读取"><a href="#协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存-硬盘中读取" class="headerlink" title="协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取"></a>协商缓存：当客户端第二次向服务器请求相同的资源时，先向服务器发送请求”询问”该请求的文件缓存在本地与服务器相比是否更改，如果更改，则更新文件，如果没有就从内存/硬盘中读取</h6><h6 id="强缓存由服务器的响应头里-cache-control-和-expires-两个字段决定，协商缓存由-last-modified-和-etag两个字段决定。"><a href="#强缓存由服务器的响应头里-cache-control-和-expires-两个字段决定，协商缓存由-last-modified-和-etag两个字段决定。" class="headerlink" title="强缓存由服务器的响应头里 cache-control 和 expires 两个字段决定，协商缓存由 last-modified 和 etag两个字段决定。"></a>强缓存由服务器的响应头里 cache-control 和 expires 两个字段决定，协商缓存由 last-modified 和 etag两个字段决定。</h6><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/20200901103330879.jpg" alt="20200901103330879"></p>
</li>
<li><h5 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h5><h6 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h6><ul>
<li>200 OK，表示从客户端发来的请求被正确处理</li>
<li>204 No content，表示请求成功，但是响应报文不包含主体部分</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<h6 id="3XX重定向"><a href="#3XX重定向" class="headerlink" title="3XX重定向"></a>3XX重定向</h6><ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的URL</li>
<li>303 see other，表示资源存在着另一个URL，应使用get方法定向获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redrect，临时重定向，和302含义相同</li>
</ul>
<h6 id="4XX客户端错误"><a href="#4XX客户端错误" class="headerlink" title="4XX客户端错误"></a>4XX客户端错误</h6><ul>
<li>400 badrequest，请求报文存在语法错误</li>
<li>401 unauthorized，表示需要权限（token）</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
<li>405 请求行中指定的请求方法不能被用于请求相应的资源。</li>
</ul>
<h6 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h6><ul>
<li>500 internal sever error，表示服务器端在执行请求的时候发生了错误</li>
<li>503 service unavailable，表示服务器暂时处于超负荷或者在停机维护，无法处理请求</li>
</ul>
</li>
<li><h5 id="Vue的-nextTick用法"><a href="#Vue的-nextTick用法" class="headerlink" title="Vue的$nextTick用法"></a>Vue的$nextTick用法</h5><p>当在Vue中完成了赋值操作而视图更新没有完成时，是获取不到最新DOM的，这个时候如果想要操作DOM就要使用$nextTick去异步延迟到DOM更新完成后再操作。</p>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><p>Vue分了三种情况来延迟调用</p>
<ol>
<li><p>promise.then延迟调用</p>
<p>如果这个浏览器支持原生promise，那么使用Promise.then延迟函数</p>
</li>
<li><p>MutationObserver监听变化</p>
</li>
<li><p>setTimeout延迟器</p>
</li>
</ol>
</li>
<li><h5 id="实现全排列算法"><a href="#实现全排列算法" class="headerlink" title="实现全排列算法"></a>实现全排列算法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length</span><br><span class="line">  <span class="keyword">let</span> res = [] <span class="comment">// 所有排列结果</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 【全排列算法】</span></span><br><span class="line"><span class="comment">   * 说明：arrange用来对arr中的元素进行排列组合，将排列好的各个结果存在新数组中</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>tempArr：排列好的元素</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>leftArr：待排列元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> arrange = <span class="function">(<span class="params">tempArr, leftArr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tempArr.length === len) &#123; <span class="comment">// 这里就是递归结束的地方</span></span><br><span class="line">      <span class="comment">// res.push(tempArr) // 得到全排列的每个元素都是数组</span></span><br><span class="line">      res.push(tempArr.join(<span class="string">&#x27;&#x27;</span>)) <span class="comment">// 得到全排列的每个元素都是字符串</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      leftArr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = [].concat(leftArr)</span><br><span class="line">        temp.splice(index, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 此时，第一个参数是当前分离出的元素所在数组；第二个参数temp是传入的leftArr去掉第一个后的结果</span></span><br><span class="line">        arrange(tempArr.concat(item), temp) <span class="comment">// 这里使用了递归</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arrange([], arr)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;结果：&#x27;</span>, func([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]))</span><br></pre></td></tr></table></figure></li>
<li><h5 id="数组方法中会改变原数组的方法和不会改变原数组的方法"><a href="#数组方法中会改变原数组的方法和不会改变原数组的方法" class="headerlink" title="数组方法中会改变原数组的方法和不会改变原数组的方法"></a>数组方法中会改变原数组的方法和不会改变原数组的方法</h5><p>会改变数组的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br><span class="line">forEach()</span><br></pre></td></tr></table></figure>

<p>不会改变数组的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">filter()</span><br><span class="line">concat()</span><br><span class="line">slice()</span><br><span class="line">map()</span><br></pre></td></tr></table></figure></li>
<li><h5 id="常见的移动端适配方案"><a href="#常见的移动端适配方案" class="headerlink" title="常见的移动端适配方案"></a>常见的移动端适配方案</h5><ol>
<li><p>媒体查询<code>@media</code></p>
<ul>
<li><p>通过查询设备的宽高来适配不同的屏幕，执行不同的css代码</p>
</li>
<li><p>优点：简单，响应式</p>
</li>
<li><p>缺点：多套css代码，维护量大</p>
</li>
<li><pre><code class="css">/* 适配iphone6 plus*/
@media screen and (min-width:414px) &#123;
    //写上区别于默认的代码样式即可
    .top p &#123;
        font-size: 20px;
        top: 43px;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>flex布局</p>
<p>flex布局本来都是响应式的，只要布局合理，就可以适配</p>
</li>
<li><p>动态rem</p>
<p>因为rem是根据根元素的字体大小的比例的单位，只要我们修改默认根元素的尺寸，那么所有采用rem的长度都会随之改变</p>
</li>
<li><p>vw</p>
<p>响应式的比例单位，但是兼容性不太好</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面经摘抄</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2022/03/19/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p>防抖和节流是JavaScript中经常遇到的性能优化问题。</p>
<p>在前端开发中我们经常需要绑定一些高频率触发的事件，例如滚动条滚动事件。但是这种事件触发频率实在太高了，如果每次触发都进行响应会极大地消耗浏览器的资源，为此，我们需要一种方法在一段时间内只触发一次事件，其余的触发事件进行忽略，这样就可以节省资源。</p>
<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>防抖是性能优化的一种思路，<strong>在第一次触发事件的时候，不立即执行函数，而是设定一个时间段，例如200ms，然后：</strong></p>
<ul>
<li>如果这段时间内没有再次触发事件，则倒计时结束执行此函数</li>
<li>如果这段时间内再次触发事件，则倒计时刷新并重复前面的步骤</li>
</ul>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，只会执行一次函数。</p>
<p><strong>实现</strong>：需要计时的需求，就用setTimeout来实现，考虑维护全局纯净，可以使用闭包来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">//借助闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer) </span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn,delay) <span class="comment">// 简化写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这个防抖函数，我们可以传入需要执行的函数和间隔时间，他会帮我们自动进行防抖</p>
<h2 id="节流（throrrle）"><a href="#节流（throrrle）" class="headerlink" title="节流（throrrle）"></a>节流（throrrle）</h2><p>节流是性能优化的另一种思路，<strong>设计一种类似阀门一样定期开放的函数，允许函数首先执行一次，然后再让它一段时间内失效，过了这段时间后再重新激活。</strong></p>
<p><strong>效果</strong>：如果短时间内大量触发同一事件，<strong>在函数执行一次之后，该函数在指定的时间期限内不再工作</strong>，直至过了这段时间才重新生效。</p>
<p><strong>实现</strong>：同样借助setTimeout来做一个简单的实现，加上一个状态位来表示当前函数是否处于工作状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">           <span class="comment">//休息时间 暂不接客</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span></span><br><span class="line">        valid = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn()</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写系列</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>面经摘抄02</title>
    <url>/2022/04/11/%E9%9D%A2%E7%BB%8F%E6%91%98%E6%8A%8402/</url>
    <content><![CDATA[<h1 id="面经摘抄02"><a href="#面经摘抄02" class="headerlink" title="面经摘抄02"></a>面经摘抄02</h1><ol>
<li><h5 id="重绘和回流以及如何减少回流"><a href="#重绘和回流以及如何减少回流" class="headerlink" title="重绘和回流以及如何减少回流"></a>重绘和回流以及如何减少回流</h5><p>重绘：当前页面中元素样式的改变并不影响它在文档流中的位置，也就是说布局没有发生改变的时候</p>
<p>回流：任何会改变元素几何信息的操作，都会触发回流，回流是影响浏览器新能的关键因素。</p>
<ol>
<li>js更改DOM元素（增删改）</li>
<li>样式表的添加或者删除</li>
<li>窗口大小改变</li>
<li>字体大小改变</li>
<li>激活伪类，如:hover(hover颜色除外)</li>
<li>改变样式属性（颜色，透明度除外）</li>
<li>更改元素的className</li>
<li>位置的计算（对如offsetHeight或者getComputerdStyle之类的元素进行测量）</li>
<li>修改页面上的内容，例如输入框中的文本、用户输入</li>
</ol>
<p>如何减少回流：</p>
<p>css：</p>
<ul>
<li>避免设置多层内联样式</li>
<li>如果需要设置动画效果，最好将元素脱离正常的文档流</li>
<li>避免使用css表达式</li>
</ul>
<p>JavaScript</p>
<ul>
<li>避免频繁操作演示，最好将样式列表定义为class并一次性改变样式</li>
<li>避免频繁操作DOM</li>
<li>可以先将元素设置为不可见：display：none,操作结束后再把它显示出来。 </li>
<li>通过硬件加速可以是渲染图层提升为复合图层。</li>
</ul>
</li>
<li><h5 id="内存泄露的原因和解决方案"><a href="#内存泄露的原因和解决方案" class="headerlink" title="内存泄露的原因和解决方案"></a>内存泄露的原因和解决方案</h5><p>通俗点说就是指由于疏忽或者错误造成程序未能释放已经不再使用的内存，从而造成内存上的浪费。</p>
<ol>
<li><p>意外的全局变量：在函数内部没有使用var声明变量，导致创建一个全局变量。</p>
<p>解决方案：使用严格模式编写，使用eslint纠错</p>
</li>
<li><p>计时器和回调函数timers：定时器在使用的时候会生成一个唯一的标识符用于操作这个计时器，如果调用了计时器之后不管他，就会导致标识符一直存在</p>
<p>解决方案：当不需要再使用计时器的时候调用ckeartimeout或者clearInterval</p>
</li>
<li><p>js闭包</p>
<p>闭包在IE6下会造成内存泄漏，但是现在已经无须考虑了。值得注意的是闭包本身不会造成内存泄漏，但闭包过多很容易导致内存泄漏。闭包会造成对象引用的生命周期脱离当前函数的上下文，如果闭包如果使用不当，可以导致环形引用（circular reference），类似于死锁，只能避免，无法发生之后解决，即使有垃圾回收也还是会内存泄露。</p>
</li>
<li><p>DOM泄露</p>
<p>给DOM对象添加的熟悉感是一个对象的引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;id&#x27;</span>).diyProp = a;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="JavaScript为什么是单线程的"><a href="#JavaScript为什么是单线程的" class="headerlink" title="JavaScript为什么是单线程的"></a>JavaScript为什么是单线程的</h5><p>这与JavaScript的用途有关，JavaScript最初是被设计为浏览器的脚本语言，而浏览器的作用就是和用户交互，以及操作DOM。这决定了它只能是单线程的，否则会带来很严重的冲突问题。比如，JavaScript在一个线程中删除了一个DOM节点，但是另一个线程却修改了这个DOM节点，浏览器应该以哪一个线程的结果为准？</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完 全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
</li>
<li><h5 id="事件委托的原理以及优缺点"><a href="#事件委托的原理以及优缺点" class="headerlink" title="事件委托的原理以及优缺点"></a>事件委托的原理以及优缺点</h5><p>原理：JavaScript事件代理是通过把事件处理器添加到上一个上级元素，这样就比米娜了将事件处理器添加到多个子级的元素上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的上级元素而将事件委托给上级元素来触发处理函数。这主要得益于浏览器的事件冒泡机制。</p>
<p>优点：</p>
<ol>
<li>减少事件注册，节省内存。</li>
<li>在table上代理所有td的click事件</li>
<li>简化了DOM节点更新的时候，相应的事件的更新</li>
<li>不用在新添加的li上绑定click事件</li>
</ol>
<p>缺点：</p>
<ol>
<li>事件委托基于冒泡，对于不冒泡的事件不支持</li>
<li>层级过多，冒泡过程中，可能会被某层阻止</li>
<li>把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。、</li>
</ol>
</li>
<li><h5 id="tree-shaking原理"><a href="#tree-shaking原理" class="headerlink" title="tree-shaking原理"></a>tree-shaking原理</h5><p>简单来说，tree-shaking的本质就是在打包过程中消除无用的代码。tree-shaking思想出现得很早，但在JavaScript中得到有效应用是ES6之后。</p>
<p>因为在ES6之前，代码的引用是CommonJS规范的动态的<code>require</code>,这样的话代码是在被使用的时候才会引入，这样导致代码打包的时候编译器不好判断是否能删除。</p>
<p>而ES6之后引入使用的ES6 Modules是<code>import</code>纯静态引入，代码在打包的时候就可以扫描代码，用到的留下，没有用到的就删除，从而优化打包后的体积。</p>
<p>CommonJS和ES6 Module的主要区别</p>
<p>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>
<p>2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>
<p>3、CommonJs 是单个值导出，ES6 Module可以导出多个</p>
<p>4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层</p>
<p>5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined</p>
</li>
<li><p><strong>文字跑马灯</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    * &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>:<span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>:<span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.block</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#65b4ae</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">white-space</span>: nowrap;</span></span><br><span class="line"><span class="css">        <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.words</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: fit-content;</span></span><br><span class="line"><span class="css">        <span class="attribute">animation</span>:move <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding-left</span>:<span class="number">50px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.words</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: absolute; </span></span><br><span class="line"><span class="css">        <span class="attribute">right</span>:<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">content</span>:<span class="built_in">attr</span>(text);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> move &#123;</span></span><br><span class="line"><span class="css">        <span class="number">0%</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="number">100%</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/*将字幕完全隐藏*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--原理：利用单行文字可以设置超出部分隐藏，同时css中transform只对标签中的值起作用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;words&quot;</span> <span class="attr">text</span>=<span class="string">&quot;HOW YOU LIKE THAT&quot;</span>&gt;</span></span><br><span class="line">            HOW YOU LIKE THAT</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>原理如下</p>
<p><img src="C:\Users\Martin\Downloads\文字跑马灯原理.png" alt="文字跑马灯原理"></p>
</li>
<li><p><strong>环绕跑马灯</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* 页面初始化 */</span></span></span><br><span class="line"><span class="css">    * &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#414141</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* content为内容部分 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#414141</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: wheat;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="comment">/* cover为边框部分 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.cover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: inherit;</span></span><br><span class="line"><span class="css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 圆角 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/* background-color: pink; */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* transition: all 3s; */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 核心代码 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, <span class="built_in">rgb</span>(<span class="number">1</span>, <span class="number">255</span>, <span class="number">234</span>), <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">251</span>, <span class="number">14</span>), <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">238</span>, <span class="number">255</span>));</span></span><br><span class="line"><span class="css">        <span class="comment">/*添加动画 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">animation</span>: color <span class="number">3s</span> linear infinite;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> <span class="attribute">color</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>原理如下</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E7%8E%AF%E7%BB%95%E8%B7%91%E9%A9%AC%E7%81%AF%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="环绕跑马灯原理图"></p>
</li>
<li><p><strong>如何区分箭头函数和普通函数</strong></p>
<ul>
<li>箭头函数不能用于构造函数，普通函数可以。所以只要new一下就可以知道是否是箭头函数。</li>
<li>普通函数this指向可以被call/apply/bind修改，箭头函数的this指向在定义的时候就已经确定了。</li>
<li>普通函数有具名函数和匿名函数，箭头函数只有匿名函数</li>
</ul>
</li>
<li><p><strong>引起内存泄露的原因</strong></p>
<ul>
<li>意外的全局变量，在函数内部如果不使用关键字定义变量，会使这个变量默认挂载在全局中。</li>
<li>没有及时清除的定时器，定时器在使用的时候会返回一个唯一标识，如果不计时清除的话，定时器会一直存在</li>
<li>事件监听器，举例子在图片懒加载中使用到了<code>IntercetionObserver</code>这个监听器，如果不及时清除监视器的话，每次被监视的DOM经过窗口边缘都会执行回调。</li>
<li>闭包，闭包会保存函数外部的变量，使用完闭包之后要清除</li>
<li>缓存，浏览器允许我们缓存一些数据到内存中，但是我们不能无休止的加入</li>
</ul>
</li>
<li><p><strong>try/catch能否捕捉到timeout内部的异常？</strong></p>
<p> 一般情况下是不能的，因为try/catch能捕捉的异常只限于同步的，且在try/catch线程执行期间内的异常才能捕获。</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//异步线程，是在同步任务执行完毕之后才执行的，所以不会被捕获</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;捕获错误！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>   当然，也不是一定不行，如果我们用async/await改造函数为同步的就可以解决了。</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;捕获错误！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>   引申：</p>
<p>   用async/await+promise+timeout可以改造一个同步的休眠器</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(delay)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始执行&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">5000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;继续&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure></li>
<li><p><strong>浏览器从输入url到渲染页面的全过程</strong></p>
<p>现代浏览器会去解析你的输入，如果不是url则会默认使用搜索引擎查询这个输入，这里只讨论正确url的情况。</p>
<p>现代浏览器从输入url到渲染整个页面的过程可以分为三个部分：</p>
<ol>
<li>DNS解析URL过程</li>
<li>浏览器发送请求到与服务器交互的过程</li>
<li>浏览器对接收到的页面进行渲染的过程</li>
</ol>
<p><strong>一、DNS解析URL过程</strong></p>
<p>我们都知道，域名其实不是一个服务器的真正地址，更像是一个方便人类查找和记忆的代号。根据计算机网络原理，服务器的地址是一串32位（ipv4）或者128位（ipv6）的二进制代码组成的ip地址。我们输入的域名并不能让浏览器找到服务器的位置，而是需要解析域名，查找其对应的ip地址。这就是DNS解析。</p>
<p>DNS解析是一个渐进的过程，它会先访问浏览器缓存，本机host，本地DNS服务器查找。没有的话就会去网络上从顶级域名服务器，根域名服务器等一直递归查询。</p>
<p><strong>二、浏览器与服务器交互的过程</strong></p>
<ol>
<li>浏览器先与服务器建立TCP链接，通过三次握手建立链接。</li>
<li>浏览器发送一个get请求到服务器请求url对应的网页。</li>
<li>服务器接收到http请求之后，如果有这个页面，就返回报文</li>
<li>浏览器接收到页面后开始渲染</li>
</ol>
<p><strong>三、浏览器页面渲染的过程（扩展，服务器端渲染，预渲染，浏览器渲染）</strong></p>
<ol>
<li>浏览器将html节点解析为DOM树</li>
<li>将css解析成CSS OM树</li>
<li>将DOM树和CSS OM树构造成render树</li>
<li>JavaScript根据得到的render树计算所有节点在屏幕中的位置，进行布局</li>
<li>遍历render树并调用硬件API绘制所有节点（重绘）</li>
</ol>
</li>
<li><p><strong>display:none,opacity:0和visibility:hidden的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>display:none</th>
<th>opacity:0</th>
<th>visibility:hidden</th>
</tr>
</thead>
<tbody><tr>
<td>文件流</td>
<td>不出出现在文件流上</td>
<td>不可见，但占据空间</td>
<td>不可见，但占据空间</td>
</tr>
<tr>
<td>子元素</td>
<td>子元素不出现</td>
<td>子元素不出现</td>
<td>设置visibility:visible子元素可见</td>
</tr>
<tr>
<td>点击事件</td>
<td>无法触发</td>
<td>可以触发</td>
<td>自身不可触发，子元素可以通过冒泡触发</td>
</tr>
</tbody></table>
</li>
<li><p><strong>display、float、position的关系</strong></p>
<p>优先级而言：<code>display:none&gt;position绝对定位&gt;float&gt;position相对定位</code></p>
</li>
<li><p><strong>清除浮动的几种方式</strong></p>
<ul>
<li><p>在需要清除浮动的元素结尾处加空标签，为这个空标签添加样式<code>clear:both</code>。</p>
<p>优点：简单易上手，</p>
<p>缺点：比较麻烦，结构不好</p>
</li>
<li><p>父级定义<code>overflow:hidden</code>， 可以通过触发BFC的方式，实现清楚浮动效果。</p>
<p>优点：简洁明了</p>
<p>缺点：内容增多的时候不会自动换行，无法显示溢出的元素。</p>
</li>
<li><p>使用<code>:after</code>和<code>:before</code>或者<code>zoom（IE）</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span>:after &#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：主流网站都在用，兼容性好</p>
</li>
</ul>
</li>
<li><p><strong>display：inline-block什么时候不会显示间隙</strong></p>
<ul>
<li>移除空格</li>
<li>使用margin负值</li>
<li>font-size:0</li>
<li>letter-spacing</li>
<li>word-spacing</li>
</ul>
</li>
<li><p><strong>流体布局（左右固定中间可大可小）</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-right</span>: <span class="number">220px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: wheat;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>路由全局守卫的三个参数</strong></p>
<p>全局守卫有前置守卫和后置守卫，是vueRouter对象的两个钩子函数，分别是<code>befroeEach</code>和<code>afterEach</code></p>
<p>前置守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//  to: 目标路由</span></span><br><span class="line">    <span class="comment">//  from: 当前路由</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// next() 跳转  一定要调用</span></span><br><span class="line">    next(<span class="literal">false</span>);<span class="comment">//不让走</span></span><br><span class="line">    next(<span class="literal">true</span>);<span class="comment">//继续前行</span></span><br><span class="line">    next(<span class="string">&#x27;/login&#x27;</span>)<span class="comment">//走哪</span></span><br><span class="line">    next(&#123;<span class="attr">path</span>:<span class="string">&#x27;/detail/2&#x27;</span>,<span class="attr">params</span>:&#123;&#125;,<span class="attr">query</span>:&#123;&#125;&#125;)<span class="comment">//带点货</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>后置守卫</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//全局后置守卫业务</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>频繁使用eventbus的后果</strong></p>
<p>$on事件是不会自动销毁的，需要我们手动销毁，如果我们一直触发又不进行销毁，就会造成内存泄露。</p>
</li>
<li><p><strong>keep-alive解释</strong></p>
<p>keep-alive是Vue中内置的组件，用来缓存不活动动态组件的。</p>
</li>
<li><p><strong>Vue设置全局变量和全局函数</strong></p>
<ol>
<li><p>使用export default/module.exports</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BASEURL = <span class="string">&quot;http://localhost:3333/&quot;</span></span><br><span class="line"><span class="keyword">const</span> URL = &#123;</span><br><span class="line">    <span class="attr">getCategory</span>:BASEURL+<span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    <span class="attr">getGoodsInfo</span>:BASEURL+<span class="string">&#x27;getGoodsInfo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> URL</span><br><span class="line">在入口文件中引入</span><br><span class="line"><span class="keyword">import</span> url <span class="keyword">from</span> <span class="string">&#x27;./api/api&#x27;</span></span><br><span class="line">Vue.prototype.URL=url;</span><br></pre></td></tr></table></figure></li>
<li><p>挂载在全局Vue实例上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue2</span></span><br><span class="line">Vue.prototype.$store = <span class="keyword">new</span> Store()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Store()</span><br><span class="line">Vue.use(store)</span><br></pre></td></tr></table></figure></li>
<li><p>Vuex状态管理</p>
</li>
</ol>
</li>
<li><p><strong>解释Vue单项数据流</strong></p>
<p>Vue中数据的流动是单项的，只能从父组件流向子组件，例如子组件可以通过props获得父组件的数据，但是子组件是不允许直接修改父组件的数据的，只能通过复制一份，或者$emit等方式通知父组件修改。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经摘抄</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>首屏加载优化</title>
    <url>/2022/04/10/%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="首屏加载优化"><a href="#首屏加载优化" class="headerlink" title="首屏加载优化"></a>首屏加载优化</h1><p>首屏加载优化是前端开发中必须重视的一环，首屏加载时间太长会破坏用户体验，严重的甚至会导致客户的流失，所以要尽可能用各种方法去优化前端首屏加载的时间。</p>
<h2 id="通用优化方法"><a href="#通用优化方法" class="headerlink" title="通用优化方法"></a>通用优化方法</h2><ol>
<li><p>图片资源的压缩，使用雪碧图将一个页面所用到的图标用一张大图代替。</p>
</li>
<li><p>图片的懒加载，在首屏中一开始用户无法看见的地方的图片可以不优先加载，等到用户浏览这个地方的时候再加载。</p>
<p>详情见手写<a href="https://stoneocean.top/2022/04/06/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/">图片懒加载</a></p>
</li>
<li><p>使用fastly加速，负载均衡，将一部分资源转移到fastly服务器上，减轻主服务器的压力。</p>
<p>例如：</p>
<ul>
<li><p>在index中引入fastly服务器中的依赖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 首屏优化，使用fastly引入外部文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- vue主要的js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://fastly.bootcss.com/vue/2.6.11/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- element-ui的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  组件库引入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://fastly.bootcss.com/element-ui/2.15.2/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://fastly.bootcss.com/vue-router/3.5.1/vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://fastly.bootcss.com/axios/0.21.1/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在vue.config中引入外部文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">configureWebpack:&#123;</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;vue&#x27;</span>:<span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue-router&#x27;</span>:<span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;axios&#x27;</span>:<span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;element-ui&#x27;</span>:<span class="string">&#x27;Element&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>main.js不用导入elementui，因为是全局引入，需要的直接使用就行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import ElementUI from &quot;element-ui&quot;;</span></span><br><span class="line"><span class="comment">// import &quot;element-ui/lib/theme-chalk/index.css&quot;;</span></span><br><span class="line"><span class="comment">// Vue.use(ElementUI);</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用服务器渲染或者预渲染</p>
<p>服务器端渲染（SSR）、客户端渲染和预渲染的区别：</p>
<ul>
<li>服务器端渲染：在服务器端完成所有客户请求并直接返回一个已经可用的渲染完毕的html页面（早期常用）</li>
<li>客户端渲染：客户请求后拿到一个空的html，再根据代码去渲染DOM和CSSOM。渲染压力分配到了客户端上，服务器的压力变小。缺点是首屏加载时间比较慢。</li>
<li>预渲染：可以看成是服务器端渲染和客户端渲染的结合。客户第一次请求的时候，会由服务器直接返回一个可用的html首页，后续客户请求的时候再使用客户端渲染的方式进行。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/c1fc061c88584d10a3bf1a01e033d371.png" alt="c1fc061c88584d10a3bf1a01e033d371"></p>
</li>
</ol>
<h2 id="对于Vue的优化方法"><a href="#对于Vue的优化方法" class="headerlink" title="对于Vue的优化方法"></a>对于Vue的优化方法</h2><ol>
<li>由于vue使用的是webpack框架进行资源打包，我们可以将打包后的资源使用Gzip进行压缩，使得依赖文件体积更小。</li>
<li>路由懒加载，路由在需要用到的时候再进行加载。组件懒加载同理。</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记01JSX基本语法</title>
    <url>/2022/05/18/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001JSX%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>在React中运用了一种特殊的语法叫做JSX（JavaScript+XML），是一个看起来很像XML的JavaScript语法扩展。在React中可以选择JSX或者JavaScript语法进行编写，但是多数人推荐使用JSX。</p>
<p>JSX跟XML很像，但还是有所不同，下面介绍一些简单的JSX语法规则。</p>
<ol>
<li>定义虚拟DOM的时候不要写引号，这不是个字符串</li>
<li>标签中引入js表达式的时候要用<code>&#123;&#125;</code></li>
<li>样式类名指定不要用class，因为在ES6中class被保留位创建类的关键字</li>
<li>内联样式要用<code>style=&#123;&#123;key:value&#125;&#125;</code>的形式去写</li>
<li>根标签只能有一个</li>
<li>标签首字母<ul>
<li>如果小写字母开头，则react转化位html</li>
<li>如果大写开头，则转化为react组件</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建虚拟DOM</span><br><span class="line">const VDOM = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2 className=&quot;title&quot; id=&#123;myId.toLowerCase()&#125;&gt;</span><br><span class="line">            &lt;span style=&#123;&#123; color: &#x27;white&#x27;, fontSize: &#x27;30px&#x27; &#125;&#125;&gt;&#123;myContext.toLowerCase()&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">        &lt;h2 className=&quot;title&quot; id=&#123;myId.toUpperCase()&#125;&gt;</span><br><span class="line">            &lt;span style=&#123;&#123; color: &#x27;white&#x27;, fontSize: &#x27;30px&#x27; &#125;&#125;&gt;&#123;myContext.toLowerCase()&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">// 2.渲染虚拟DOM到页面</span><br><span class="line">ReactDOM.render(VDOM, document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure>

<h2 id="JSX小练习：使用JSX遍历一个动态表格"><a href="#JSX小练习：使用JSX遍历一个动态表格" class="headerlink" title="JSX小练习：使用JSX遍历一个动态表格"></a>JSX小练习：使用JSX遍历一个动态表格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 准备好一个容器 --&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入react核心库 --&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 引入react-dom,用于支持react操作DOM --&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 引入babel，用于将jsx转为js --&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    const arr = [&#x27;Vue&#x27;, &#x27;React&#x27;, &#x27;Angular&#x27;]</span><br><span class="line">    //1.创建虚拟DOM</span><br><span class="line">    const VDOM = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;框架列表&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;arr.map((m, i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;m&#125;&lt;/li&gt;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">    // 2.渲染虚拟DOM到页面</span><br><span class="line">    ReactDOM.render(VDOM, document.getElementById(&#x27;test&#x27;))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记03props</title>
    <url>/2022/05/18/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003props/</url>
    <content><![CDATA[<h2 id="组件三大属性之props"><a href="#组件三大属性之props" class="headerlink" title="组件三大属性之props"></a>组件三大属性之props</h2><p>props是React中用于传递数据的一个概念。当我们需要向组件传入外部的值的时候就需要使用props进行传值。</p>
<h2 id="props基本用法"><a href="#props基本用法" class="headerlink" title="props基本用法"></a>props基本用法</h2><p>在我们需要传入值的组件的render函数中函数标签中传入值，在组件类内部使用<code>this.props</code>进行访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建类式组件</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; first, second, thrid &#125; = this.props</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;&#123;first&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;second&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;thrid&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//渲染组件到页面上</span><br><span class="line">ReactDOM.render(&lt;Demo first=&quot;Vue&quot; second=&quot;React&quot; thrid=&quot;Angular&quot; /&gt;, document.getElementById(&#x27;test&#x27;))</span><br><span class="line">ReactDOM.render(&lt;Demo first=&quot;Vuex&quot; second=&quot;Vue-router&quot; thrid=&quot;axios&quot; /&gt;, document.getElementById(&#x27;test1&#x27;))</span><br><span class="line">ReactDOM.render(&lt;Demo first=&quot;State&quot; second=&quot;Props&quot; thrid=&quot;promise&quot; /&gt;, document.getElementById(&#x27;test2&#x27;))</span><br></pre></td></tr></table></figure>

<h2 id="批量传入props"><a href="#批量传入props" class="headerlink" title="批量传入props"></a>批量传入props</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//简写批量传递参数</span><br><span class="line">const p = &#123; first: &#x27;Vue&#x27;, second: &#x27;React&#x27;, thrid: &#x27;Angular&#x27; &#125;</span><br><span class="line">//前提，所有参数一一对应，这里的&#123;..p&#125;和用于浅复制的&#123;..p&#125;不一样</span><br><span class="line">//这里的花括号指的是允许在花括号中使用js表达式，实际上的js语句是...p</span><br><span class="line">//用于浅复制的花括号指的是新建一个对象</span><br><span class="line">ReactDOM.render(&lt;Demo &#123;...p&#125; /&gt;, document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure>

<h2 id="对Props的传值进行约束"><a href="#对Props的传值进行约束" class="headerlink" title="对Props的传值进行约束"></a>对Props的传值进行约束</h2><p>在一些情况下，我们希望传入的值是一个固定类型的值，或者我们希望一个变量是有默认值的，这个时候我们就需要对Props进行约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//props属性类型限制</span><br><span class="line">Demo.propTypes = &#123;</span><br><span class="line">    first: PropTypes.string.isRequired,</span><br><span class="line">    second: PropTypes.number,</span><br><span class="line">&#125;</span><br><span class="line">//props默认值设置</span><br><span class="line">Demo.defaultProps = &#123;</span><br><span class="line">    first: &#x27;dada&#x27;，</span><br><span class="line">    second: 66</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Props简写形式"><a href="#Props简写形式" class="headerlink" title="Props简写形式"></a>Props简写形式</h2><p>就是将对Props的约束放到类内部去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建类式组件</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">    //props属性类型限制</span><br><span class="line">    static propTypes = &#123;</span><br><span class="line">        first: PropTypes.string.isRequired,</span><br><span class="line">        second: PropTypes.string,</span><br><span class="line">    &#125;</span><br><span class="line">    //props默认值设置</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        first: &#x27;dada&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        // 注意：props是只读的</span><br><span class="line">        const &#123; first, second, thrid &#125; = this.props</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;&#123;first&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;second&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;thrid&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式组件中使用Props"><a href="#函数式组件中使用Props" class="headerlink" title="函数式组件中使用Props"></a>函数式组件中使用Props</h2><p>在函数式组件中，无法使用<code>state</code>和<code>refs</code>属性，但是可以使用<code>Props</code>属性，这得益于函数能够接收参数这个特点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //创建类式组件</span><br><span class="line">function Demo(props) &#123;</span><br><span class="line">    const &#123; first, second, thrid &#125; = props</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&#123;first&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&#123;second&#125;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&#123;thrid&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记04refs</title>
    <url>/2022/05/19/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004refs/</url>
    <content><![CDATA[<h1 id="组件三大属性值refs"><a href="#组件三大属性值refs" class="headerlink" title="组件三大属性值refs"></a>组件三大属性值refs</h1><p>在React中refs是一个用于获取DOM节点的机制。</p>
<p>想象这样一个场景，你需要从后台获取数据，然后再渲染到页面上，这个时候你需要一个DOM节点进行渲染，怎么获取一个特定的DOM节点呢，答案是使用refs。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="字符串形式refs（不推荐）"><a href="#字符串形式refs（不推荐）" class="headerlink" title="字符串形式refs（不推荐）"></a>字符串形式refs（不推荐）</h3><p>通过直接在JSX中的标签使用<code>ref=&#39;name&#39;</code>的形式可以轻松将DOM节点收纳至组件实例对象的refs属性上，这种方法十分简便，但可能导致性能上的问题，官方也不推荐使用，并表示可能在未来的版本中弃用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建类式组件</span><br><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">    showData = () =&gt; &#123;</span><br><span class="line">        const &#123; text1 &#125; = this.refs</span><br><span class="line">        alert(text1.value)</span><br><span class="line">    &#125;</span><br><span class="line">    showData2 = () =&gt; &#123;</span><br><span class="line">        const &#123; text2 &#125; = this.refs</span><br><span class="line">        alert(text2.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input ref=&quot;text1&quot; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧数据&lt;/button&gt;</span><br><span class="line">                &lt;br /&gt;</span><br><span class="line">                &lt;br /&gt;</span><br><span class="line">                &lt;input ref=&quot;text2&quot; onBlur=&#123;this.showData2&#125; type=&quot;text&quot; placeholder=&quot;失去焦点提示数据&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//挂载在页面上</span><br><span class="line">ReactDOM.render(&lt;Demo /&gt;, document.getElementById(&#x27;test&#x27;))</span><br></pre></td></tr></table></figure>

<h2 id="回调形式refs"><a href="#回调形式refs" class="headerlink" title="回调形式refs"></a>回调形式refs</h2><p>通过在JSX标签种指定一个回调函数来为ref命名也可以达到目的。</p>
<h5 id="内联形式回调"><a href="#内联形式回调" class="headerlink" title="内联形式回调"></a>内联形式回调</h5><p>可以直接在标签中使用内联函数来回调，不过这样有一点问题，因为render函数在更新的时候是先创建一个新的DOM，再把原来的DOM删除，为了不影响使用，react在每一次创建时都先传入一个null保证实例正常，这会导致每次组件更新ref实际上被调用了两次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input ref=&#123;a =&gt; &#123; console.log(1); return this.text1 = a &#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="外部函数形式回调"><a href="#外部函数形式回调" class="headerlink" title="外部函数形式回调"></a>外部函数形式回调</h5><p>可以直接将函数定义到外部，在JSX中引用，这样就可以解决内联形式的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">saveInput = a =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    return this.text1 = a</span><br><span class="line">&#125;</span><br><span class="line">&lt;input ref=&#123;this.saveInput&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="CreateRef形式refs"><a href="#CreateRef形式refs" class="headerlink" title="CreateRef形式refs"></a>CreateRef形式refs</h2><p>React提供了一个专有API<code>React.createRef()</code>用于创建一个<strong>仅收纳一个ref</strong>的容器，我们可以使用这个容器去收纳一个DOM节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Demo extends React.Component &#123;</span><br><span class="line">    //React.createRef调用后可以返回一个容器，该容器可以存储被ref所表示的节点</span><br><span class="line">    //注意，此容器是&#x27;专人专用&#x27;的</span><br><span class="line">    myRef = React.createRef()</span><br><span class="line">    showData = () =&gt; &#123;</span><br><span class="line">        const value = this.myRef.current.value</span><br><span class="line">        alert(value)</span><br><span class="line">    &#125;</span><br><span class="line">    showData2 = () =&gt; &#123;</span><br><span class="line">        // const &#123; text2 &#125; = this.refs</span><br><span class="line">        // alert(text2.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧数据&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记05生命周期</title>
    <url>/2022/05/19/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="React生命周期详解（新）"><a href="#React生命周期详解（新）" class="headerlink" title="React生命周期详解（新）"></a>React生命周期详解（新）</h1><p>React16之后有三个生命周期被废弃：</p>
<ul>
<li><code>componentWillMount</code></li>
<li><code>componentWillReceviceProps</code></li>
<li><code>componentWillUpdate</code></li>
</ul>
<p>因为这些生命周期方法容易被误解和滥用</p>
<p><strong>React16.8+的生命周期分为三个阶段，分别是挂载阶段、更新阶段、卸载阶段</strong></p>
<h2 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h2><ul>
<li><p><code>constructor</code>：构造函数，最先被执行，我们通常在构造函数里初始化state对象或者给自定义方法绑定this</p>
</li>
<li><p><code>getDerivedStateFromProps</code>：<code>static getDerivedStateFromProps(nextProps,prevState)</code>,这是一个静态方法，当我们接受到新的属性想要去修改state的时候，可以使用<code>getDerivedStateFromProps</code></p>
</li>
<li><p><code>render</code>：render函数是一个纯函数，只返回需要渲染的东西，不应该包括其他的业务逻辑，可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</p>
</li>
<li><p><code>componentDidMount</code>：组件挂载之后调用，类似于Vue中的mounted，这个时候可以获取DOM节点并操作，比如对canvas，svg等操作，服务器请求，订阅都可以写在这个里面，但是记得在<code>componentWillUnmount</code>中取消订阅。</p>
</li>
</ul>
<h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><ul>
<li><p><code>getDerivedStateFromProps</code>：这个方法在整个改在阶段都可能会调用</p>
</li>
<li><p><code>shouldComponentUpdate</code>：<code>shouldComponentUpdate(nextProps,nextState)</code>,有两个参数，分别是组件更新前已经发生变化的新props和新state，同时接收一个返回值，用来表示此次组件是否需要更新。</p>
</li>
<li><p><code>render</code>:更新阶段也会触发render生命周期</p>
</li>
<li><p><code>getSnapshotBeforeUpdate</code>：<code>getSnapshotBeforeUpdate(prevProps, prevState)</code>这个方法在render之后，<code>componentDidUpdate</code>之后调用。返回值会作为第三个参数会传给<code>componentDidUpdate</code>,可以为空。必须与<code>componentDidUpdate</code>搭配使用。</p>
</li>
<li><p><code>componentDidUpdate</code>：<code>componentDidUpdate(preProps,prevState,snapShot)</code>,第三个参数是<code>getSnapshotBeforeUpdate</code>返回的，如果触发某些回调函数时需要用到DOM元素的状态，则将对比或计算的过程迁移至<code>getSnapshotBeforeUpdate</code>,然后在<code>componentDidUpdate</code>中统一触发回调或更新状态。</p>
</li>
</ul>
<h2 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h2><ul>
<li><code>componentWillUnmount</code>：当组件被卸载或者销毁了就会调用，我们可以在这个生命周期里面去清除一些定时器，取消订阅等等收尾工作</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记07代理的配置</title>
    <url>/2022/05/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007%E4%BB%A3%E7%90%86%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="React之代理配置"><a href="#React之代理配置" class="headerlink" title="React之代理配置"></a>React之代理配置</h1><p>在由webpack驱动的react项目中，我们如果遇到跨域的方法一般都由后端解决，例如cors，websocket，jsonp。由于webpack本身就启动了一个web服务器，我们可以利用react脚手架中的web服务器为我们转发请求从而在前端实现跨域。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>浏览器去请求后端的时候存在一种跨域限制，即前后端的url是不同协议，不同域名，不同端口的情况都属于跨域，这种情况下浏览器将阻止响应。</p>
<p>代理是解决跨域的一种方式，它的原理是利用服务之间的请求是不受浏览器跨域影响的。先开启一台跟前端项目相同域名、协议、端口的服务器，而提供web服务的服务器本身刚好就符合这个条件，前端的请求先是到达web服务器，再由服务器转发到目标服务器，从而完成通信</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86.png" alt="代理原理"></p>
<h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>在配置文件<code>package.json</code>中直接配置代理，然后重启项目</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>:<span class="string">&quot;http://localhost:8081&quot;</span></span><br></pre></td></tr></table></figure>

<p>原理：这是webpack中为开发者留下的一个简单版的代理配置选项，如果用户发起请求，就会由webpack服务器代理到目标服务器，由于服务器之间没有跨域限制，所以可以完成跨域。</p>
<p>优点：配置简单</p>
<p>缺点：不能配置多个代理，同时会将所有请求都进行转发</p>
<h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>需要在<code>src</code>文件加下添加一个<code>setUpProxy.js</code>文件，名称固定，webpack打包的时候会自动解析这个文件。</p>
<p>配置格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">    app.use(</span><br><span class="line">        proxy(<span class="string">&#x27;/api1&#x27;</span>, &#123;					<span class="comment">//遇见这个前缀的请求，就会触发代理</span></span><br><span class="line">            <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">//代理转发的目标地址</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>, 			<span class="comment">//控制服务器收到的响应头中Host字段的值 </span></span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;	<span class="comment">//重写请求路径</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：可以根据不同需求配置多个代理，灵活控制请求</p>
<p>缺点：配置繁琐</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记06路由</title>
    <url>/2022/05/20/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B006%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="React之路由"><a href="#React之路由" class="headerlink" title="React之路由"></a>React之路由</h1><p>React中官方推荐使用<code>react-router-dom</code>作为路由插件。</p>
<h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p>在SPA（单页面应用）中，最重要的一个部分就是实现路由，即在不刷新页面的情况下进行跳转。路由就是一个用于实现这个目的工具。路由利用浏览器BOM自带的API<code>histroy</code>实现控制页面url的变化，同时监听url的变化，产生变化的时候进行对应的组件调用，这就是路由。</p>
<h2 id="React-router-dom的基本使用"><a href="#React-router-dom的基本使用" class="headerlink" title="React-router-dom的基本使用"></a>React-router-dom的基本使用</h2><ol>
<li><p>引入<code>react-router-dom</code></p>
</li>
<li><p>明确好界面中的导航区和展示区</p>
</li>
<li><p>导航区的a标签改为<code>Link</code>标签，用于触发路由跳转</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Link className=<span class="string">&#x27;list-group-item&#x27;</span> to=<span class="string">&#x27;/about&#x27;</span>&gt;About&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>展示区写Route标签进行路径的匹配</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> component=&#123;Home&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>记得要在app根组件的外侧包裹一个路由器组件<code>&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;</code>,用于监听全局路由</p>
</li>
</ol>
<h2 id="路由组件和普通组件的不同之处"><a href="#路由组件和普通组件的不同之处" class="headerlink" title="路由组件和普通组件的不同之处"></a>路由组件和普通组件的不同之处</h2><ul>
<li>写法不同<ul>
<li>普通组件的使用：<code>&lt;Demo /&gt;</code></li>
<li>路由组件的使用：<code>&lt;Route path=&#39;/home&#39; component=&#123;Home&#125; /&gt;</code></li>
</ul>
</li>
<li>存放位置不同<ul>
<li>普通组件存放在<code>components</code></li>
<li>路由组件存放在<code>pages</code></li>
</ul>
</li>
<li>接收到的props不同<ul>
<li>普通组件：写组件标签的时候传递了什么就收到什么</li>
<li>路由组件：接受到三个固定的属性</li>
</ul>
</li>
</ul>
<h2 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h2><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><ul>
<li><p>路由链接（携带参数）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//about后面的两个就是参数</span></span><br><span class="line">&lt;Link className=<span class="string">&#x27;list-group-item&#x27;</span> to=<span class="string">&#x27;/home/tom/18&#x27;</span>&gt;About&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注册路由（声明接收）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home/:name/:age&#x27;</span> component=&#123;Home&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接收参数（使用<code>props.match,params</code>在路由组件内接收参数）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;name,age&#125; = <span class="built_in">this</span>.props.match.params</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="search参数"><a href="#search参数" class="headerlink" title="search参数"></a>search参数</h3><ul>
<li><p>路由链接（携带参数）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Link className=<span class="string">&#x27;list-group-item&#x27;</span> to=<span class="string">&#x27;/home?name=tom&amp;age=18&#x27;</span>&gt;About&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注册路由（无需声明接收）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> component=&#123;Home&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接收参数（使用<code>props.match,params</code>在路由组件内接收参数）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;search&#125; = <span class="built_in">this</span>.props.location</span><br></pre></td></tr></table></figure></li>
<li><p>注意：获取到的search是urlencoded编码的字符串，需要借助querystring解析</p>
</li>
</ul>
<h3 id="state参数"><a href="#state参数" class="headerlink" title="state参数"></a>state参数</h3><ul>
<li><p>路由链接（携带参数）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//about后面的两个就是参数</span></span><br><span class="line">&lt;Link className=<span class="string">&#x27;list-group-item&#x27;</span> to=&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,<span class="attr">state</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&gt;</span><br><span class="line">    About</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注册路由（无需声明接收）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> component=&#123;Home&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接收参数（使用<code>props.match,params</code>在路由组件内接收参数）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;name,age&#125; = <span class="built_in">this</span>.props.location.state </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关于路由"><a href="#关于路由" class="headerlink" title="关于路由"></a>关于路由</h2><h3 id="NavLink与封装NavLink"><a href="#NavLink与封装NavLink" class="headerlink" title="NavLink与封装NavLink"></a>NavLink与封装NavLink</h3><ol>
<li>NavLink可以实现路由链接的高亮，通过activeClassname指定样式名称</li>
<li>标签体内容是一个特殊的标签属性</li>
<li>通过this.props.children可以获取标签体内容</li>
</ol>
<h3 id="路由严格匹配和模糊匹配"><a href="#路由严格匹配和模糊匹配" class="headerlink" title="路由严格匹配和模糊匹配"></a>路由严格匹配和模糊匹配</h3><ol>
<li><p>默认使用的是模糊匹配（简单记：“输入的路径”必须要包含要匹配的路径，且顺序要一致）</p>
</li>
<li><p>开启严格匹配</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> exact=&#123;<span class="literal">true</span>&#125; component=&#123;Home&#125; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>严格匹配不要随意开启，否则可能影响二级路由匹配</p>
</li>
</ol>
<h3 id="Redirect（默认路由）的使用"><a href="#Redirect（默认路由）的使用" class="headerlink" title="Redirect（默认路由）的使用"></a>Redirect（默认路由）的使用</h3><ol>
<li><p>一般写在所有路由注册的最下方，当所有路由都无法匹配的时候，跳转到Redirect所指定的路由</p>
</li>
<li><p>具体编码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#x27;/home&#x27;</span>/&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ol>
<li>注册子路由的时候要写上父级路由的path前缀</li>
<li>路由的匹配是按照注册路由的顺序进行的</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记08Redux</title>
    <url>/2022/05/21/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008Redux/</url>
    <content><![CDATA[<h1 id="React之Redux"><a href="#React之Redux" class="headerlink" title="React之Redux"></a>React之Redux</h1><p>随着单页面应用的兴起，JavaScript需要管理非常多的状态。在Vue框架中，有一个官方支持的状态管理工具Vuex，而在React中也有一个官方支持的状态管理工具——Redux。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li>Store</li>
<li>State</li>
<li>Reducer</li>
<li>Action</li>
</ul>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store是保存全局数据的地方，你可以把它看成一个容器（带有推送功能的数据仓库）。就像Vuex单一状态树的概念，整个应用只能由一个store。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure>

<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>如果想要得到某个时间点的数据，就需要对Store生成快照。这个时点的数据集合，就叫做当前时刻的State。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure>

<p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>就像Vuex一样，reduce不允许直接修改state，用户只能查看state，如果 需要修改，就必须使用Action进行提交修改事件，让redux本身去决定何时修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;change_input&#x27;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Learn Redux&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过多的Action在组件中，会显得代码过于臃肿，不利于阅读和维护。可以新建一个<code>actionCreator.js</code>文件，用来<strong>统一管理action</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// action的统一管理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeInputAction = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;change_input&#x27;</span>,</span><br><span class="line">    value,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addItemAction = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;add_item&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> delItemAction = <span class="function"><span class="params">index</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;del_item&#x27;</span>,</span><br><span class="line">    index,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>每个函数都用来返回一个action，这个函数就叫 <strong>Action Creator</strong>。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Store收到Action后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始状态，作为 State 的默认值</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state)); <span class="comment">// 深拷贝,不能直接修改state里的数据</span></span><br><span class="line">    <span class="keyword">if</span> (action.type === <span class="string">&#x27;change_input&#x27;</span>) &#123;</span><br><span class="line">        newState.value = action.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (action.type === <span class="string">&#x27;add_item&#x27;</span>) &#123;</span><br><span class="line">        newState.list.push(newState.value);</span><br><span class="line">        newState.value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (action.type === <span class="string">&#x27;del_item&#x27;</span>) &#123;</span><br><span class="line">        newState.list.splice(action.index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (action.type === <span class="string">&#x27;init_list&#x27;</span>) &#123;</span><br><span class="line">        newState.list = action.list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;src/store/reducer.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>electron初探</title>
    <url>/2022/05/26/electron%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="electron初探"><a href="#electron初探" class="headerlink" title="electron初探"></a>electron初探</h1><p>在冲浪的时候无意间看到的一个框架，据说能把web端应用编译成win、linux、mac端桌面应用，大名鼎鼎的vscode也是基于这个框架的。牛。</p>
<p>于是小试一下，结果发现还是有一点坑，</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这篇博客已经说明了大部分配置。<a href="https://blog.csdn.net/gesila2/article/details/121215230">https://blog.csdn.net/gesila2/article/details/121215230</a></p>
<p>我再说明我遇到的问题，</p>
<ol>
<li><p>路由配置：electron不支持history路由模式，只能使用hash路由模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//electron配置</span></span><br><span class="line"><span class="attr">history</span>: createWebHashHistory(process.env.BASE_URL ? process.env.BASE_URL : <span class="literal">null</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>文件地址配置：electron与web应用的区别是，它不依靠服务器运行，所以文件索引地址应该是绝对地址文件，而不是web服务器中的相对地址。</p>
</li>
<li><p>关于依赖：electron只认生产环境依赖<code>devDependencies</code>，所以要把依赖放到生产环境依赖中</p>
</li>
</ol>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>打包后的体积有一点大，我只不过是一个小小demo就189mb了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>electron就是给web应用套了个壳，让web运行在一个虚拟机上面，虽然还有很多不足，但是也挺牛掰的，再说一句，vscode永远滴神。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣前端页面抖动bug</title>
    <url>/2022/05/26/%E5%8A%9B%E6%89%A3%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%8A%96%E5%8A%A8bug/</url>
    <content><![CDATA[<h1 id="力扣页面捉虫"><a href="#力扣页面捉虫" class="headerlink" title="力扣页面捉虫"></a>力扣页面捉虫</h1><p>作为一个菜鸟大三，今天在力扣上面看面经，结果给我发现一个无伤大雅的小bug。当我在看讨论区大佬的面经的时候，正想着给大佬点一个赞，结果发现我无论如何也看不清点赞按钮，难道是我学得太过深入导致眼花了？揉了揉眼睛，发现事情并没有那么简单。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E5%8A%A8%E7%94%BB.gif" alt="动画"></p>
<p>我们把页面滑动到帖子结束，讨论区开始的地方，经过细微的调试，就能复现这个bug。</p>
<p>我定着这个抖动的框陷入了沉思，作为一个合格的菜鸟，我第一时间就按下了f12，选中了这个节点。果然class在疯狂的变换。我又换了火狐浏览器，发现bug依旧。如果不是浏览器的问题，那就是代码本身有问题吗？</p>
<h2 id="分析bug原理"><a href="#分析bug原理" class="headerlink" title="分析bug原理"></a>分析bug原理</h2><p>首先，在页面处于这个帖子本身的时候，也就是高于这个点赞评论框的时候，这个框是吸附在浏览器窗口底部的。<img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E6%88%AA%E5%9B%BE1.png" alt="截图1"></p>
<p>其次，当页面处于这个帖子的评论区的时候，也就是低于点赞评论框，这个点赞评论框就是位于帖子底部的。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E6%88%AA%E5%9B%BE2.png" alt="截图2"></p>
<p>那么我们滑动窗口的时候，在某个时刻，就触发了样式的改变，所以很可能是使用了DOM监听器去监听帖子底部到页面顶端的距离，去判断这个框是吸附在底部还是正常表现。</p>
<p>这怎么看着这么眼熟，这不就是图片懒加载的原理吗。于是尝试复现这个bug。</p>
<h2 id="复现bug"><a href="#复现bug" class="headerlink" title="复现bug"></a>复现bug</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>尝试抖动复现<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> _p = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    _p.innerText = <span class="string">&quot;尝试抖动复现&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> cloneDOM = _p.cloneNode(<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        temp += cloneDOM.outerHTML</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> _h1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;h1&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    _h1.insertAdjacentHTML(<span class="string">&quot;beforebegin&quot;</span>, temp)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// console.log(entry.boundingClientRect.top)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">if</span> (entry.isIntersecting) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                _h1.style.position = <span class="string">&#x27;static&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                _h1.style.position = <span class="string">&#x27;relative&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">                _h1.style.top = <span class="string">&#x27;-50px&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    observer.observe(_h1);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E5%8A%A8%E7%94%BB1.gif" alt="动画1"></p>
<p>结果还真复现了一个差不多的，那么差不多可以得出结论了，就是监听器不断监听dom节点的位置，发现这个框应该改变样式，但是<strong>改变样式之后又因为高度变化导致监听器重新判断</strong>，给出了应该把样式该回去的判断，于是样式就开始上下横跳。</p>
<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E6%8A%96%E5%8A%A8%E5%8E%9F%E7%90%86.png" alt="抖动原理"></p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/%E6%8A%96%E5%8A%A8%E5%8E%9F%E7%90%86%20(1).png" alt="抖动原理(1)"></p>
<p>既然问题明朗了有什么解决办法呢？</p>
<p>我觉得有一个办法就是防抖(物理)，就是把监听器判定的高度调低一点，让它在这个临界区中只保持一种状态就好。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL/TLS原理</title>
    <url>/2022/06/02/SSL-TLS%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="SSL-TLS原理"><a href="#SSL-TLS原理" class="headerlink" title="SSL/TLS原理"></a>SSL/TLS原理</h1><p>使用SSL/TLS加密的HTTP协议HTTPS是时下最流行的网页加密技术。主要任务是提供<strong>私密性，信息完整性和身份认证</strong>。SSL是一个不依赖于平台和运用程序的协议，位于TCP/IP协议与各种应用层协议之间，为数据通信提高安全支持。</p>
<h2 id="SSL-TLS位置"><a href="#SSL-TLS位置" class="headerlink" title="SSL/TLS位置"></a>SSL/TLS位置</h2><p>SSL/TLS是位于应用层和TCP层之间的协议，一旦启用SSL/TLS协议，数据就先传递给SSL/TLS层再传递给TCP层。</p>
<table>
<thead>
<tr>
<th align="center">HTTP/FTP（应用层）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SSL/TLS（加密协议）</td>
</tr>
<tr>
<td align="center">TCP（传输层）</td>
</tr>
</tbody></table>
<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密就是加密方和解密方都使用同一个密钥进行加密/解密。这种方法比较简单，性能也比较好，但是缺点就是密钥不能泄露，一旦泄露对话就不安全了。SSL/TLS的最终目的就是安全的在网络中发送对称加密密钥。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密就是加密方和解密方使用不同密钥。通常有一个密钥称为公钥，就是公布到网络中，任何人都可以访问，还有一个私钥。这种方式性能不如对称加密，但是更安全，可以用来安全交换对称加密密钥。</p>
<p>非对称加密的基石是加密算法（RSA），它的特点就是有两个key。key1和key2，分别对应D（解密）运算和E（加密）运算。对于一个信息，无论是先进行E运算再进行D运算还是先进行D运算再进行E运算，得到的结果是一样的，都能得出原来的结果，并且中间产物（秘文）无法使用其他手段破解得到原始值（目前来说）。</p>
<h3 id="证书颁发机构（CA）"><a href="#证书颁发机构（CA）" class="headerlink" title="证书颁发机构（CA）"></a>证书颁发机构（CA）</h3><p>在SSL/TLS通信中要对双方的身份进行验证，才能安全的进行通信，为了防止第三方伪造，我们需要一个可以信任的第三方通过颁发数字证书的方式对双方的身份进行验证。这就是CA。原理是通过CA自己内部的私钥对通信方的身份做一次加密，再加上未签名的身份信息，构成了数字证书。要验证身份的地方只要用公钥解密信息对比身份信息，只要一致就说明可以信任。</p>
<h2 id="SSL-TLS原理-1"><a href="#SSL-TLS原理-1" class="headerlink" title="SSL/TLS原理"></a>SSL/TLS原理</h2><p>SSL/TLS的目的就是让不确定的通信双方最终能够建立对称加密方式的可信任的通信。</p>
<p>原理图如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/ssl.png" alt="ssltls"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器完整生命周期</title>
    <url>/2022/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="浏览器完整生命周期"><a href="#浏览器完整生命周期" class="headerlink" title="浏览器完整生命周期"></a>浏览器完整生命周期</h1><p>浏览器是前端开发最重要的工具之一，那么浏览器从输入到页面加载中间到底经历了什么</p>
<h2 id="浏览器内部逻辑分析"><a href="#浏览器内部逻辑分析" class="headerlink" title="浏览器内部逻辑分析"></a>浏览器内部逻辑分析</h2><p>在现代浏览器中我们在输入框如果输入不正确的url地址，浏览器会自动跳转到默认搜索引擎搜索你输入的内容。如果你输入的url没有错，则进行页面的跳转。</p>
<h2 id="网络请求角度分析"><a href="#网络请求角度分析" class="headerlink" title="网络请求角度分析"></a>网络请求角度分析</h2><p>我们通过chrome的开发者工具抓取network请求包，分析第一个请求的时序。</p>
<p><img src="https://fastly.jsdelivr.net/gh/GiorunoGiovanna/Blog-Drawingbed/drawingbed/image-20220605091710369.png" alt="image-20220605091710369"></p>
<p>发现有如下顺序，</p>
<ol>
<li>预处理</li>
<li>DNS解析</li>
<li>建立链接（SSL）</li>
<li>发起HTTP请求</li>
<li>等待响应</li>
<li>缓存处理（此处没有，但是一般对于某些大文件，第二次加载的时候会使用，等会解析）</li>
<li>接收数据</li>
</ol>
<h3 id="DNS解析详细过程"><a href="#DNS解析详细过程" class="headerlink" title="DNS解析详细过程"></a>DNS解析详细过程</h3><p>我们都知道，域名其实不是一个服务器的真正地址，更像是一个方便人类查找和记忆的代号。根据计算机网络原理，服务器的地址是一串32位（ipv4）或者128位（ipv6）的二进制代码组成的ip地址。我们输入的域名并不能让浏览器找到服务器的位置，而是需要解析域名，查找其对应的ip地址。这就是DNS解析。</p>
<p>DNS解析是一个渐进的过程，它会先访问浏览器缓存–&gt;本机host–&gt;本地DNS服务器查找–&gt;去网络上从顶级域名服务器–&gt;根域名服务器等一直递归查询。</p>
<h3 id="建立链接（TLS-SSL）详细过程"><a href="#建立链接（TLS-SSL）详细过程" class="headerlink" title="建立链接（TLS/SSL）详细过程"></a>建立链接（TLS/SSL）详细过程</h3><p>首次与服务器建立链接的时候需要建立一个TCP链接（3次握手），然后根据服务器所使用的协议（http/https）来判断是否建立SSL链接。</p>
<p>SSL链接是一种用于保密传输内容的协议，它是工作在应用层（HTTP）和传输层(TCP)之间的，通过可信任的第三方CA进行一次非对称加密传输拿到等等建立链接后所使用的对称加密密钥。具体可见<a href="https://stoneocean.top/2022/06/02/SSL-TLS%E5%8E%9F%E7%90%86/">此处</a>。</p>
<h3 id="缓存处理详细过程"><a href="#缓存处理详细过程" class="headerlink" title="缓存处理详细过程"></a>缓存处理详细过程</h3><p>缓存是一种用于避免重复传输不必要的文件的手段，例如我们第一次访问网站的时候加载了一个图片，第二次访问的时候没有必要又从服务器上请求数据，直接使用缓存在本地的图片就可以了。</p>
<p>缓存分为强缓存和协商缓存。</p>
<p>强缓存的资源会携带一个Expires或者cache-control，只要在缓存有效时间内，就直接从本地取数据</p>
<p>协商缓存分为两种，一种是Etag文件唯一标识符，每次请求此资源时候带上Etag，当服务器的文件发生改变的时候，Etag更新与请求的Etag不一致则重新传输，一致则还是使用本地缓存。另一种的last-modified最后修改时间，于etag同理。具体可见<a href="https://stoneocean.top/2022/04/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">此处</a>。</p>
<h2 id="浏览器渲染角度分析"><a href="#浏览器渲染角度分析" class="headerlink" title="浏览器渲染角度分析"></a>浏览器渲染角度分析</h2><p>当浏览器接收到html文件后，尽管html文件中的其他资源可能还没有传输完成，浏览器依然会开始解析html。解析的过程是从上而下，顺序解析。HTML对应DOM树生成，CSS对应CSSOM树生成，最终合并生成render-tree。再根据布局计算，最后GPU进行绘制。</p>
<p>PS：构建DOM树期间，如果遇到JS，阻塞DOM树以及CSSOM树的构建，优先加载JS文件，加载完毕，再继续构建DOM树及CSSOM树。因为js中可能操作了html，会导致DOM树的改变。</p>
<p>渲染步骤如下：</p>
<ol>
<li>根据HTML解析出DOM树</li>
<li>根据CSS解析出CSSOM树</li>
<li>结合DOM树和CSSOM树生成渲染树</li>
<li>布局计算</li>
<li>根据计算好的信息绘制页面</li>
</ol>
<h3 id="根据HTML构建DOM树"><a href="#根据HTML构建DOM树" class="headerlink" title="根据HTML构建DOM树"></a>根据HTML构建DOM树</h3><p>浏览器拿到服务器提供的HTML后，会先根据顶部定义的类型进行对应的解析方式，HTML的解析会被交给内部的GUI渲染线程处理。</p>
<p>渲染线程中的HTML解释器会从上到下解析HTML内容。</p>
<p>如果遇到的节点是js代码节点，则会调用JS引擎对js代码进行解释执行，此时由于JS引擎和GUI线程是互斥的，GUI渲染线程会挂起直到js引擎解析完毕。</p>
<p>如果遇到的是其他资源（图片，css），会调用网络模块来加载，不会阻塞GUI线程的执行。</p>
<p>如果遇到的是JS资源URL（非异步的），则会阻塞GUI渲染线程，直到js资源加载并解析执行完毕后再执行。</p>
<h3 id="根据CSS构建CSSOM树"><a href="#根据CSS构建CSSOM树" class="headerlink" title="根据CSS构建CSSOM树"></a>根据CSS构建CSSOM树</h3><p>CSS解释器会将CSS翻译成CSSOM树，这个过程和DOM解析类似。由于下一个阶段是render树构建，因此需要等待到DOM树和CSSOM树都构建完成之后才会推进</p>
<h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>将CSSOM树种对应的样式交到DOM树对应的节点上，形成一颗完备的渲染树</p>
<h3 id="布局（reflow）"><a href="#布局（reflow）" class="headerlink" title="布局（reflow）"></a>布局（reflow）</h3><p>渲染树同时包含了屏幕上的所有可见内容以及其详细信息，再这个阶段浏览器会详细计算每一个节点再视口内的确切位置和大小，这就是布局阶段，也被称为reflow（回流）。</p>
<h3 id="绘制（repain）"><a href="#绘制（repain）" class="headerlink" title="绘制（repain）"></a>绘制（repain）</h3><p>这个阶段浏览器已经知道了各个节点的大小位置等等信息，可以将这些信息转化成屏幕上的实际像素。</p>
<h3 id="合成（Composite）"><a href="#合成（Composite）" class="headerlink" title="合成（Composite）"></a>合成（Composite）</h3><p>把前面的所有信息发送给GPU，GPU将各层合成，显示在屏幕上。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TS-challenge01</title>
    <url>/2022/06/23/TS-challenge01/</url>
    <content><![CDATA[<h1 id="TS-challenge"><a href="#TS-challenge" class="headerlink" title="TS-challenge"></a>TS-challenge</h1><p>这是一个在github上的开源<a href="https://github.com/type-challenges/type-challenges">项目</a>，可以用来练习TS的语法。</p>
<h2 id="04-pick"><a href="#04-pick" class="headerlink" title="04-pick"></a>04-pick</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    <span class="comment">//通过in遍历得到T（数组）中的每一个元素，再让它等于本身</span></span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="07-redaonly"><a href="#07-redaonly" class="headerlink" title="07-redaonly"></a>07-redaonly</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">    <span class="comment">//通过keyof可以遍历得到T（对象）中的键（key）</span></span><br><span class="line">    <span class="keyword">readonly</span> [p <span class="keyword">in</span> keyof T]: T[p]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-tuple-to-object"><a href="#11-tuple-to-object" class="headerlink" title="11-tuple to object"></a>11-tuple to object</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过extends关键字可以限定T（数组）中取出元素的类型</span></span><br><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> (<span class="built_in">string</span> | <span class="built_in">number</span> | symbol )[]&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-first"><a href="#14-first" class="headerlink" title="14-first"></a>14-first</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extends可以类比为js中==，这句话的意思就是看看T的类型是否是空的数组</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [] ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//在TS中可以使用[“key”]的方式指定对象的某个属性</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&quot;length&quot;</span>] <span class="keyword">extends</span> <span class="number">0</span> ? <span class="built_in">never</span> : T[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="number">0</span>] <span class="keyword">extends</span> T[<span class="built_in">number</span>] ? T[<span class="number">0</span>] : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在TS中也可以使用解构赋值，但是要为解构的元素使用infer关键字</span></span><br><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer first, ...infer other] ? first : <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<h2 id="18-tuple-length"><a href="#18-tuple-length" class="headerlink" title="18-tuple-length"></a>18-tuple-length</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在TS中可以使用[“key”]的方式指定对象的某个属性</span></span><br><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&quot;length&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="43-exclude"><a href="#43-exclude" class="headerlink" title="43-exclude"></a>43-exclude</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extends也可以判断类型是否被后面的类型包含</span></span><br><span class="line"><span class="keyword">type</span> MyExclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二分查找</title>
    <url>/2022/06/15/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>使用二分查找的要求是确定数据上下界，并且数据是有顺序的</strong>。具体思路就是从数组的中间元素开始，如果中间的元素恰好是目标值，则搜索结束，如果目标值大于或小于中间元素，则在大于或小于的那一半重新二分。</p>
<h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 二分</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,end = nums.length-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((start+end)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x===<span class="number">1</span>)&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = x;</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid**<span class="number">2</span>===x)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid**<span class="number">2</span>&gt;x)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        mid2 = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(mid===mid2)&#123;<span class="keyword">return</span> mid&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
