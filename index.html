<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/GiorunoGiovana.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/GiorunoGiovana.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/GiorunoGiovana.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/GiorunoGiovana.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/GiorunoGiovana.github.io/css/main.css">


<link rel="stylesheet" href="/GiorunoGiovana.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"giorunogiovanna.github.io","root":"/GiorunoGiovana.github.io/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录自己的学习路程，以及一些有趣的事物">
<meta property="og:type" content="website">
<meta property="og:title" content="Joker&#39;s Blog">
<meta property="og:url" content="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/index.html">
<meta property="og:site_name" content="Joker&#39;s Blog">
<meta property="og:description" content="记录自己的学习路程，以及一些有趣的事物">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Joker">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Joker's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/GiorunoGiovana.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Joker's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Joker的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/GiorunoGiovana.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/GiorunoGiovana.github.io/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/GiorunoGiovana.github.io/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/GiorunoGiovana.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

    <a target="_blank" rel="noopener" href="https://github.com/GiorunoGiovanna" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/25/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/25/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8/" class="post-title-link" itemprop="url">css学习笔记01快速上手、选择器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-25 16:39:07 / 修改时间：16:42:56" itemprop="dateCreated datePublished" datetime="2021-12-25T16:39:07+08:00">2021-12-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1、css优势："><a href="#1、css优势：" class="headerlink" title="1、css优势："></a>1、css优势：</h2><ul>
<li>内容和表现分离</li>
<li>可以实现复用，网页结构表现统一</li>
<li>样式十分丰富</li>
<li>建议使用独立于html的css文件</li>
<li>利用SEO，容易被搜索引擎收录</li>
</ul>
<h2 id="2、css的3中导入方式："><a href="#2、css的3中导入方式：" class="headerlink" title="2、css的3中导入方式："></a>2、css的3中导入方式：</h2><ol>
<li><p>内联样式</p>
<ul>
<li>写在本网页中的style标签中</li>
</ul>
</li>
<li><p>外联样式</p>
<ul>
<li>写在外部文件中，通过link标签引入（推荐，因为便于维护和管理）</li>
</ul>
</li>
<li><p>行内样式</p>
<ul>
<li>写在html标签的内部，用style=“”写</li>
</ul>
<p>优先级排序</p>
<p>行内&gt;内联&gt;外联</p>
</li>
<li><p>拓展：外联样式的两种写法</p>
<ol>
<li><p>连接式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 连接式 --&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/index.css&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>导入式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入式 --&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">		<span class="keyword">@import</span> url(<span class="string">&quot;./css/index.css&quot;</span>);</span></span></span><br><span class="line"><span class="css"><span class="xml">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>两者区别</p>
<ul>
<li>link标签是html标签，只能放在html中使用。</li>
<li>@import在html中使用的时候外面要加style标签，但是也可以直接在css文件中使用用以引入其他css文件</li>
<li>本质上区别不大，推荐使用link</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="3、选择器"><a href="#3、选择器" class="headerlink" title="3、选择器"></a>3、选择器</h2><blockquote>
<p>作用：选择页面中的某一个元素</p>
</blockquote>
<ol>
<li>标签选择器</li>
<li>类选择器 class（可多对一）</li>
<li>id选择器（仅一对一，权重高）</li>
</ol>
<p>优先级：id&gt;class&lt;标签</p>
<h2 id="3-1、层次选择器"><a href="#3-1、层次选择器" class="headerlink" title="3.1、层次选择器"></a>3.1、层次选择器</h2><ol>
<li><p>后代选择器： 在某个元素后面</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*后代选择器 */</span></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>子选择器，一代，儿子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子选择器 */</span></span><br><span class="line"><span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>相邻兄弟选择器（只有一个，而且是向下相邻）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 相邻兄弟选择器 */</span></span><br><span class="line"><span class="selector-class">.p1</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通用兄弟选择器（下面所有统一层次的选择器）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通用选择器 */</span></span><br><span class="line"><span class="selector-class">.p1</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: chartreuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-2、结构伪类选择器"><a href="#3-2、结构伪类选择器" class="headerlink" title="3.2、结构伪类选择器"></a>3.2、结构伪类选择器</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ul的第一个子元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ul的最后一个子元素 */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中p1 </span></span><br><span class="line"><span class="comment">选择当前p元素的父级元素，选中父级元素的第nth个，并且是当前元素的同类元素才生效*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#008000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择当前p元素的父级元素，选中父级元素的第nth个子类同类元素*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类，鼠标悬停 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3、属性选择器"><a href="#3-3、属性选择器" class="headerlink" title="3.3、属性选择器"></a>3.3、属性选择器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">			<span class="selector-class">.demo</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">				<span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">				<span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">				<span class="attribute">color</span>: aliceblue;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="css">				<span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">				<span class="attribute">margin</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">				<span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">50px</span> Arial;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 存在id的元素，把他选中 a[]&#123;&#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">				属性名，属性名 = 属性值(正则)</span></span></span><br><span class="line"><span class="comment"><span class="css">				= 为绝对等于</span></span></span><br><span class="line"><span class="comment"><span class="css">				*= 为包含此元素 </span></span></span><br><span class="line"><span class="comment"><span class="css">				^= 为以此开头的</span></span></span><br><span class="line"><span class="comment"><span class="css">				￥= 为以此结尾的</span></span></span><br><span class="line"><span class="comment"><span class="css">							*/</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[id]</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">color</span>: <span class="number">#0000FF</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[id=first]</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[class*=<span class="string">&quot;links&quot;</span>]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#FFE4C4</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="comment">/* 选中herf中以http开头的元素 */</span></span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[href^=http]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: <span class="number">#FF0000</span>;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">a</span><span class="selector-attr">[href$=pdf]</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">			&#125;</span></span><br><span class="line"><span class="css">		</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item first&quot;</span> <span class="attr">id</span>=<span class="string">&quot;first&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item active&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;test&quot;</span> <span class="attr">id</span>=<span class="string">&quot;second&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.html&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.png&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;images/123.jpg&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/a.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.pdf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abc.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item&quot;</span>&gt;</span>9<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;abcd.doc&quot;</span> <span class="attr">class</span>=<span class="string">&quot;links item last&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>= 为绝对等于</li>
<li>*= 为包含此元素 </li>
<li>^= 为以此开头的</li>
<li>￥= 为以此结尾的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/23/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/23/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">js学习笔记14网络请求</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-23 10:15:20" itemprop="dateCreated datePublished" datetime="2021-12-23T10:15:20+08:00">2021-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:37:06" itemprop="dateModified" datetime="2021-12-25T14:37:06+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p>Fetch API能够执行XHR对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等陷害Web工具中使用。不同之处在于XHR可以选择同步或异步，但是Fetch API只能选择异步。</p>
<ul>
<li><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>fetch()方法是暴露在全局作用域中的</li>
</ul>
</li>
<li><h4 id="分派请求"><a href="#分派请求" class="headerlink" title="分派请求"></a>分派请求</h4><ul>
<li>fetch()只有一个必须参数input，作为请求URL，这个方法返回一个promise，这个对象是API的封装，可以通过他获取响应的资源。<ul>
<li>在只有一个参数的情况下，默认执行get方法</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="读取响应"><a href="#读取响应" class="headerlink" title="读取响应"></a>读取响应</h4><ul>
<li>读取响应内容的最简单方式是取得纯文本格式的内容，这要用到text()方法。这个方法返回一个promise，会决议为取得资源的完整内容。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://api.it120.cc/MartinGarrixForTest/mock/data/getMsg&#x27;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><h4 id="处理状态码和请求失败"><a href="#处理状态码和请求失败" class="headerlink" title="处理状态码和请求失败"></a>处理状态码和请求失败</h4><ul>
<li>Fetch API支持通过Response的状态码和状态文本属性检查响应状态。<ul>
<li>由于无论返回的响应式多少，只要返回了响应，那么promise都会决议为resolved状态，这在逻辑上是合理的，所以我们还要在已决议的promise中再去判断状态码，从而执行不同的操作。</li>
<li>注意，如果服务器未响应导致浏览器超时，不符合的跨域请求都会导致fetch（）失败，从而导致promise决议为rejected。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h4><ol>
<li>body<ul>
<li>用于指定使用请求体的内容</li>
</ul>
</li>
<li>credentials<ul>
<li>用于指定在外发请求中包含cookie</li>
</ul>
</li>
<li>method<ul>
<li>用于指定HTTP请求方法</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h4><ul>
<li>顾名思义，Request对象就是获取资源请求接口</li>
<li>创建Request对象<ol>
<li>可以通过构造函数初始化Requset对象，为此需要传入一个input，一般是URL</li>
<li>已接受第二个参数，和fetch()一样</li>
<li>复制request对象，使用clone方法复制，这样不会请求标记为已使用。</li>
<li>在fetch()中使用Request对象，在调用fetch()时，可以传入一创建好的Request实例。</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h4><ul>
<li>headers对象时所有外法请求和入栈响应头部的容器。每个外发的Request实例都包含一个空的Header实例，可以通过Request.prototype.headers访问，每一个入栈的Respone实例也一样。</li>
<li>Headers对象与Map的相似之处<ul>
<li>都有get，set，has和delete</li>
</ul>
</li>
<li>Headers的独特之处<ul>
<li>可以使用键值对的形式初始化Headers对象，Map不行。</li>
</ul>
</li>
<li>头部护卫<ul>
<li>不是所有头部都可以被客户端修改</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="常见的Fetch请求模式"><a href="#常见的Fetch请求模式" class="headerlink" title="常见的Fetch请求模式"></a>常见的Fetch请求模式</h4><ul>
<li><p>发送JSON数据</p>
</li>
<li><p>在请求体中发送参数</p>
<ul>
<li>因为请求体支持任意字符串值，所以可以通过它发送请求参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> param = <span class="string">&#x27;username=admin&amp;pwd=admin&amp;deviceId=1&amp;deviceName=1&#x27;</span></span><br><span class="line"><span class="keyword">let</span> paramHearders = <span class="keyword">new</span> Headers(&#123;</span><br><span class="line">		<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">	&#125;)</span><br><span class="line">fetch(<span class="string">&#x27;https://api.it120.cc/MartinGarrixForTest/user/username/login&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">	<span class="attr">body</span>:param,</span><br><span class="line">	<span class="attr">headers</span>:paramHearders</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	res.text().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>发送文件</p>
<ul>
<li>因为请求体支持FormData实现，所以fetch()也可以序列化并发送文件字段中的文字件。</li>
</ul>
</li>
<li><p>加载blob文件（重点！！）</p>
<ul>
<li>Fetch API也能提供Blob类型的响应，而blob又可以兼容多种浏览器API</li>
</ul>
</li>
<li><p>发送跨域请求</p>
<ul>
<li>从不同的源请求资源，响应要包含CORS头部才能保证浏览器收到响应。没有这些头部，跨域请求会失败。</li>
</ul>
</li>
<li><p>中断请求</p>
<ul>
<li>调用AbortController.abort()会中断所有网络传输。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><ul>
<li><p>Web Socket的目标是通过一个长时间链接实现与服务器全双工、双向的通信（持久化推送消息）。在JavaScript中创建WebSocket时，一个HTTP请求会发送到服务器以初始化链接。服务器响应后，链接使用HTTP的Upgrade头部从HTTP协议切换到web Socket协议。这意味着web Socket不能通过标准的HTTP服务器实现，而必须使用支持该协议的服务器。</p>
</li>
<li><p>因为WebSocket使用自定义协议，所以URL方案稍有变化：不能再使用http://或者https://,而要使用ws://或wss://。前者是不安全链接，后者是安全链接</p>
</li>
<li><p>发送和接收数据，使用send（）方法并传入一个字符串、ArrayBuffer或Blob</p>
</li>
<li><p>API</p>
<ul>
<li>要创建一个新的Web Socket，就要实例化一个WebSocket对象并传入提供链接的URL</li>
<li>注意：必须个WebSocket构造函数传入一个绝对URL。同源策略不适用于Web Socket。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>定义web socket协议的时间比定义JavaScript API时间药厂。Web Socket得到了所有主流浏览器的支持。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>使用自定义协议而非HTTP协议的好处是，客户端与服务器之间可以发送十分少量的数据，不会对HTTP造成负担。</li>
<li>非常适合带宽和延迟比较明显的移动端。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013JSON/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013JSON/" class="post-title-link" itemprop="url">js学习笔记13JSON</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-11 09:54:13" itemprop="dateCreated datePublished" datetime="2021-12-11T09:54:13+08:00">2021-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:37:02" itemprop="dateModified" datetime="2021-12-25T14:37:02+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><ol>
<li>理解JSON最关键的一点就是要把它当成一种数据格式而不是编程语言</li>
<li>语法<ol>
<li>JSON语法支持三种类型的值<ul>
<li>简单值（字符串，数值，布尔值，null，都可以在JSON中出现，undefined不可以）</li>
<li>对象</li>
<li>数组</li>
</ul>
</li>
<li>JSON没有变量、函数或对象实例的概念。JSON的所有记号都只为标识结构化数据，虽然它借用了JavaScript的语法。</li>
</ol>
</li>
<li>解析与序列化<ul>
<li>JSON可以直接被解析为可用的JavaScript对象，与解析为DOM文档的XML相比，这个优势非常明显。为此，JavaScript开发者可以非常方便第使用JSON数据。</li>
</ul>
</li>
<li>序列化选项<ul>
<li>stringify()<ul>
<li>过滤结果<ul>
<li>如果第二个参数是一个数组，那么JSON.stringify()返回的结果只会包含该数组中列出的对象属性</li>
<li>如果第二个参数是一个函数，提供的函数接受两个参数：属性名(key)和属性值(value)，可以根据这个key决定要对应属性做什么。<ul>
<li>函数过滤器会应用到要序列化对象所包含的全部对象。</li>
</ul>
</li>
</ul>
</li>
<li>字符串缩进<ul>
<li>第三个参数可以控制缩进和空格<ul>
<li>是数值是，表示缩进空格数</li>
<li>是字符串时，表示要填充到每一行开头的字符串</li>
<li>无论时那种，最大不超过10个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>简单值<ul>
<li>JavaScript字符串与JSON字符串的主要区别就是JSON字符串必须使用双引号（单引号会导致语法错误）</li>
</ul>
</li>
<li>对象<ul>
<li>有两处不同<ul>
<li>JSON没有变量声明（JSON没有变量）</li>
<li>最后没有分号（不需要，因为不是JavaScript语句）</li>
</ul>
</li>
<li>同样，用引号将属性名包围起来才是有效的JSON。</li>
</ul>
</li>
<li>数组<ul>
<li>和对象差不多</li>
</ul>
</li>
<li>JSON对象<ol>
<li>因为JSON时JavaScript语法的子集，所以eval()可以解析、解释并将其作为JavaScript对象和数组返回。</li>
<li>JSON对象<ul>
<li>Stringify()<ul>
<li>将JavaScript序列化为JSON字符串</li>
</ul>
</li>
<li>parse()<ul>
<li>将JSON解析为原生JavaScript值</li>
</ul>
</li>
</ul>
</li>
<li>扩展<ul>
<li>JSON.Stringify(JSON.parse(str))可以实现深复制对象。</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/11/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">js学习笔记12异步编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-11 08:12:54" itemprop="dateCreated datePublished" datetime="2021-12-11T08:12:54+08:00">2021-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:36:58" itemprop="dateModified" datetime="2021-12-25T14:36:58+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Promise-期约"><a href="#Promise-期约" class="headerlink" title="Promise(期约)"></a>Promise(期约)</h1><ol>
<li><h4 id="promise基础"><a href="#promise基础" class="headerlink" title="promise基础"></a>promise基础</h4><ul>
<li>可以通过new 操作符来实例化一个promise对象。创建新期约的时候需要传入执行器（executor）函数作为参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p)	<span class="comment">//Promise&lt;pending&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><h4 id="期约状态机"><a href="#期约状态机" class="headerlink" title="期约状态机"></a>期约状态机</h4><ol>
<li>Peomise是一个有状态的对象，可能处于三种状态<ul>
<li>待定（pedding）</li>
<li>兑现（fulfilled），有时也叫解决，（resolved）</li>
<li>拒绝（rejected）</li>
</ul>
</li>
<li>待定（pending）是promise的初始状态，可以转换为另外两种状态，并且一旦转换就不可逆。</li>
<li>另外，promise的状态也不能不被外部的JavaScript代码修改，也不能被外界读取（私有）。</li>
</ol>
</li>
<li><h4 id="解决值、拒绝理由及期约用例"><a href="#解决值、拒绝理由及期约用例" class="headerlink" title="解决值、拒绝理由及期约用例"></a>解决值、拒绝理由及期约用例</h4><ul>
<li>promise的用途是，抽象的标识一个异步操作，并且通知这个操作是否完成</li>
<li>一些情况下，promise封装的异步操作会实际生成某个值，而程序期待promise状态改变的时候可以访问这个值。例如，如果请求范围为200-299的状态码，让promise状态转化为resolved，并且内部可以接受到一个JSON字符串。拒绝同理，只是接受的变成一个拒绝理由。</li>
<li>为了支持这种用例，promise每次转换状态，就会有一个私有的内部值或理由。二者都是可选的，并且默认为undefined。</li>
</ul>
</li>
<li><h4 id="同步-异步执行的二元性"><a href="#同步-异步执行的二元性" class="headerlink" title="同步/异步执行的二元性"></a>同步/异步执行的二元性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)	<span class="comment">//Error:foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Uncaught (in Promise) Error:bar</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的例子报错的原因是：try。。。catch捕获的是哦同步执行时抛出的错误，因此第一个错误可以捕获，但是第二个Promise中抛出的异常是以异步模式进行的，因此没有捕获。</li>
<li>这个例子中可以看出promise的真正异步特性:他们时同步对象（在同步中执行使用），但是也是异步执行的媒介</li>
<li>代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体的说，就是promise方法。</li>
</ul>
</li>
<li><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><ul>
<li>通过调用一个Promise.resolve()方法，可以实例化一个已处于解决状态的promise。</li>
<li>使用这个方法实际上可以把任何值转化为一个promise</li>
<li>这是一个幂等的方法，即嵌套调用多少次结果都一样</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p===<span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)))		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，这样会把抛出的错误都包装到已解决的promise中。</li>
</ul>
</li>
<li><h4 id="Promise-rejected"><a href="#Promise-rejected" class="headerlink" title="Promise.rejected()"></a>Promise.rejected()</h4><ul>
<li>和resolved类似，但是不是幂等的，给他传入一个resolve会把这个promise包装成拒绝理由。</li>
</ul>
</li>
<li><h4 id="通过执行函数控制promise状态"><a href="#通过执行函数控制promise状态" class="headerlink" title="通过执行函数控制promise状态"></a>通过执行函数控制promise状态</h4><ul>
<li>由于promise状态是私有的，所以只能在内部进行操作。内部操作在promise的执行器函数中完成。</li>
<li>执行器的两个职责<ul>
<li>初始化promise的异步行为</li>
<li>控制状态的最终转换<ul>
<li>转换是通过调用它的两个函数参数实现的<ul>
<li>reslove()</li>
<li>reject()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>执行器函数是同步执行的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">&#x27;executor&#x27;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,<span class="string">&#x27;promise initialized&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//executor</span></span><br><span class="line"><span class="comment">//promise initialized</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加setTimeout可以推迟切换状态：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve,<span class="number">1000</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="built_in">console</span>.log,<span class="number">0</span>,p)</span><br></pre></td></tr></table></figure>

<ul>
<li>再次强调，promise的状态只能改变一次，且不可逆。任何在状态改变后视图再次改变状态的操作都会无效。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">js学习笔记11函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-10 10:16:50" itemprop="dateCreated datePublished" datetime="2021-12-10T10:16:50+08:00">2021-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:36:52" itemprop="dateModified" datetime="2021-12-25T14:36:52+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定余函数本身紧密绑定</li>
<li>创建函数的方式和区别<ul>
<li>函数表达式 var foo = function() {…}<ul>
<li>只有在JavaScript语句执行到这句话的之后才会创建函数。在这之前调用函数会报错。（没有提升）</li>
</ul>
</li>
<li>函数声明 function foo() {…}<ul>
<li>在JavaScript编译的时候函数声明会被提前，也就是说可以先调用函数再在下面声明函数</li>
</ul>
</li>
</ul>
</li>
<li>箭头函数<ul>
<li>箭头函数是使用胖箭头(=&gt;)语法定义函数表达式的能力。</li>
<li>标准写法是 let a = (x) =&gt; {…}</li>
<li>如果函数只有一条语句的话，可以不要大括号，但是函数会默认将这一句话当成返回值；只有一个参数的时候也可以没有前一个括号</li>
</ul>
</li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ol>
<li><p>闭包是指哪些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparison</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> val1 = obj1[name]</span><br><span class="line">		<span class="keyword">let</span> val2 = obj2[name]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(val1&gt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val1&lt;val2)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compare  = createComparison(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> result = compare(&#123;<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;pa&quot;</span>&#125;)	<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这个例子中的val1和val2引用了来自函数外的变量，在这个内部的匿名函数被返回并在其他的地方使用后，它仍然引用着那个变量。这是因为内部函数的作用域包含createComparison()函数的作用域。</li>
</ul>
</li>
<li><p>在调用一个函数的时候，会为这个函数创建一个执行上下文，并创建一个作用域链。然后用arguments和其他命名参数来初始化这个函数的活动独享。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域一直向外串起了所有包含函数的活动对象，直到全局上下文才终止。</p>
</li>
<li><p>函数执行的时候，每个执行上下文都会有一个包含其中变量的对象。全局上下文中的叫变量对象，他会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，指在函数执行期间存在。</p>
<ul>
<li>函数内部的代码在访问变量时，就会使用给定的名称从作用域中查找变量。函数执行完毕后，局部活动对象会被摧毁。只剩下全局作用域。但是在闭包中就不一样了。</li>
</ul>
</li>
<li><p>注意：因为闭包会保留他们包含的函数作用域，因此会比其他函数更占用内存，所以要谨慎使用。</p>
</li>
<li><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到子自己的作用域链中。导致在外部函数被销毁时外部函数的活动对象由于仍然被引用，所以不能销毁。就产生了闭包。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/10/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">js学习笔记10代理与反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-10 09:54:38" itemprop="dateCreated datePublished" datetime="2021-12-10T09:54:38+08:00">2021-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:36:47" itemprop="dateModified" datetime="2021-12-25T14:36:47+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><ol>
<li><h4 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h4><ul>
<li>代理是目标对象的抽象。目标对象既可以直接被操作，也可以通过代理来操作。但是直接操作会绕过代理施予的行为。</li>
</ul>
</li>
<li><h4 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h4><ul>
<li>在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</li>
</ul>
</li>
<li><h4 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h4><ul>
<li>使用代理的主要原因是可以定义捕获器。每个处理程序对象都可以包含多个捕获器，每个捕获器对应一种基本操作，可以直接或间接在代理对象上调用。</li>
<li>每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前像调用捕获器函数，从而实现拦截并修改相应的行为。</li>
<li>例如，可以定一一个get()捕获器，JavaScript操作以某种形式调用get()时触发。所有这些操作只要发生在代理对象上，就会触发get()捕获器</li>
<li>注意，只有在代理对象上，就会触发。</li>
</ul>
</li>
<li><h4 id="捕获器参数和反射API"><a href="#捕获器参数和反射API" class="headerlink" title="捕获器参数和反射API"></a>捕获器参数和反射API</h4><ul>
<li>所有捕获器都可以访问响应的参数面积与这些参数可以重建被捕获的方法的原始行为。</li>
<li>通过调用全局Reflect对象上（封装了原始行为）的同名方法来轻松重建。</li>
</ul>
</li>
<li><h4 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h4><ul>
<li>代理可以捕获13种不同的基本操作</li>
</ul>
</li>
<li><h4 id="代理的问题和不足"><a href="#代理的问题和不足" class="headerlink" title="代理的问题和不足"></a>代理的问题和不足</h4></li>
<li><h4 id="使用反射API"><a href="#使用反射API" class="headerlink" title="使用反射API"></a>使用反射API</h4><ul>
<li>某些情况下应该优先使用反射API，这些是有一些理由的。</li>
<li>反射API与对象API<ul>
<li>反射API并不限于捕获处理程序</li>
<li>大多数反射API方法在Object类型上对应的方法</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h4><ul>
<li>有时候可能需要中断代理对象与目标对象的联系。对于使用new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一致存在。</li>
<li>Proxy也暴露了revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数是幂等的，调用多少次结构都是一样的。</li>
</ul>
</li>
<li><h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><ul>
<li>目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时会报错。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B009%E7%B1%BB/" class="post-title-link" itemprop="url">js学习笔记09类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-09 14:32:57" itemprop="dateCreated datePublished" datetime="2021-12-09T14:32:57+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:36:43" itemprop="dateModified" datetime="2021-12-25T14:36:43+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li><h5 id="ES6支持单继承。使用extends关键字，就可以继承任何拥有-Construct-和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）"><a href="#ES6支持单继承。使用extends关键字，就可以继承任何拥有-Construct-和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）" class="headerlink" title="ES6支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）"></a>ES6支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（向后兼容）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Bus);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Vehicle);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承普通构造函数	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Person</span> ()</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">let</span> <span class="title">e</span> </span>= <span class="keyword">new</span> Engineer ()</span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Engineer)	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person)	<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><h5 id="派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类："><a href="#派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类：" class="headerlink" title="派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类："></a>派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用响应方法的实例或者类：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">identifyPrototype</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(id,<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">identifyClass</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(id,<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vehicle()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bus()</span><br><span class="line"></span><br><span class="line">b.identifyPrototype(<span class="string">&#x27;bus&#x27;</span>)</span><br><span class="line">v.identifyPrototype(<span class="string">&#x27;vehicle&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Bus.identifyClass(<span class="string">&#x27;bus&#x27;</span>)</span><br><span class="line">Vehicle. identifyClass(<span class="string">&#x27;vehicle&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><ol>
<li><h5 id="定义类有两种方式"><a href="#定义类有两种方式" class="headerlink" title="定义类有两种方式"></a>定义类有两种方式</h5><ol>
<li>类声明<ul>
<li>class Person {} 类声明不能提升</li>
</ul>
</li>
<li>类表达式<ul>
<li>const a = class {}</li>
</ul>
</li>
<li>函数收到作用域限制，类收到块作用域限制。</li>
</ol>
</li>
<li><h5 id="JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）"><a href="#JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）" class="headerlink" title="JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）"></a>JavaScript中那么多的继承方式只是用来模拟类的行为（ES5）</h5><ul>
<li>ES6引入了class关键字具有正式定义类的能力。类（class）是ES6中新的基础性语法糖结构。虽然这个类表面上支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。</li>
</ul>
</li>
<li><h5 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h5><ul>
<li>类可以包含构造函数方法、实例方法、获取函数、设置函数、静态类的方法。但是不是必须的，空类也是有效的。</li>
<li>类表达式的名称是可选的。在把类表达式赋值给变量之后，可以通过name属性访问类表达式的名称字符串。但是不能在类表达式作用域外部访问这个标识符。</li>
</ul>
</li>
</ol>
<h1 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h1><p>constructor关键字用于在类定义块内部创建类的构造函数。构造函数的定义不是必须的。</p>
<ol>
<li><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><ul>
<li>使用new操作符实例化Person的操作等于使用new调用其构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使用new和类意味着应该使用constructor函数进行实例化。</li>
<li>使用new调用类的构造函数会执行如下操作。(类实例化时传入的参数会用作构造函数的参数，如过不需要参数，则类名后面的括号也是可选的)<ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象的内部[[prototypr]]指针被赋值为constructor构造函数的prototypr属性。</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ol>
</li>
<li>默认情况下，类构造函数会在执行之后返回this对象。构造函数返回的对象会被用作实例化对象，如果没有什么引用新创建的对象，那么这个对象就会被销毁。不过，如果返回的不是this对象，而是其他对象，那么这个对象不会通过instanceof操作符检测出跟类有关联，因为这个对象的原型指针没有被修改。</li>
<li>类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符，否则会报错。普通构造函数直接调用，则会以全局对象作为this。</li>
</ul>
</li>
<li><h5 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h5><ol>
<li>ECMAScript中没有正式的类这个类型，从各个方面来看，类就是一种特殊的函数</li>
<li>在类上下文中，类本身在使用new调用时就会被当作构造函数。重点在于，类定义中的constructor方法不会被当成构造函数，在对他使用instanceof操作符时会返回false。但是，如果在创建实例时直接将类构造函数方程普通构造函数来使用，那么instanceof操作符的返回值会反转。</li>
<li>可以向其他对象或者函数引用一样把类作为参数传递，也可以立即实例化。</li>
</ol>
</li>
</ol>
<h1 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h1><ol>
<li><h5 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h5><ol>
<li>每次通过new调用类识别符，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加自有属性。至于添加怎么样的属性，没有限制。另外，在构造函数执行完毕之后，仍然可以给实例添加新的成员。</li>
<li>所有成员都不会在原型上共享</li>
</ol>
</li>
<li><h5 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h5><ol>
<li>为了在实例间共享方法，类定义语法把类块中定义的方法作为原型方法。</li>
<li>可以把方法定义在类构造函数中或者类块中，但是不能在类块中给原型添加原始值或对象作为成员数据。</li>
<li>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键。</li>
<li>类定义也支持获取和设置访问器。语法与行为跟普通对象一样。</li>
</ol>
</li>
<li><h5 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h5><ol>
<li>类定义语法支持在原型和类本身上定义生成器的方法</li>
<li>因为支持生成器方法，所以可以通过添加一个默认的迭代器，八十例变成可迭代对象。</li>
<li>也可以只返回迭代器实例。</li>
</ol>
</li>
<li><h5 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h5><ul>
<li>虽然类定义不显示支持在原型或类上添加成员数据，但在类定义外部，可以手动添加。</li>
</ul>
</li>
<li><h5 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h5><ol>
<li>可以在类上定义静态方法。这些方法通常用于执行不特定与实例的操作，也不要求存在类的实例。</li>
<li>类静态成员每一个类上只能有一个</li>
<li>静态类成员在类定义中使用static关键字作为前缀。在静态成员中，this引用类自身。其他所有约定和原型成员一样。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/09/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B008%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">js学习笔记08继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-09 10:15:42" itemprop="dateCreated datePublished" datetime="2021-12-09T10:15:42+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:36:40" itemprop="dateModified" datetime="2021-12-25T14:36:40+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>很多面向对象语言都支持两种继承：接口继承和实现继承。JavaScript只支持实现继承，而且是通过原型链方式继承的。这里介绍JavaScript中实现继承的6中方式。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原型链继承的基本思想是通过原型继承多个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.far=<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.getFar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.far</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.child=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()	<span class="comment">//原型继承father实例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">alert(a.getFar())	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>本质：</p>
<ul>
<li>通过重写子类型的原型对象实现继承</li>
<li>注：原型对象中包含constructor属性一般指回子类型函数本身，重写子类型的原型对象会导致constructor属性丢失。</li>
<li>最终原型链为：a-&gt;child-&gt;father-&gt;Object（所有函数的默认原型）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>父级的实例属性会被子级共享</li>
<li>子级不能向父级传递参数</li>
</ul>
</li>
<li><p>原型与继承的关系</p>
<ol>
<li><p>使用instanceof操作符确定</p>
<ul>
<li><p>如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用isPrototypeOf()方法。</p>
<ul>
<li><p>只要原型链包含这个原型，就会返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>原型链的问题</p>
<ol>
<li>原型中包含的引用值会在所有实例间共享。在使用原型实现继承时，原型实际上变成了另一个类型实例。</li>
<li>重写子类型对象后，constructor属性会丢失。</li>
</ol>
</li>
<li><p>关于方法</p>
<ol>
<li>子类有些时候需要覆盖父类的方法，或者增设父类没有的方法。为此，有些方法必须在原型复制后再添加到原型上。</li>
<li>如果以对象字面量的方式创建原型会破坏原型链，因为这相当于重写了原型链。</li>
</ol>
</li>
</ol>
<h2 id="借用构造函数继承（经典继承）"><a href="#借用构造函数继承（经典继承）" class="headerlink" title="借用构造函数继承（经典继承）"></a>借用构造函数继承（经典继承）</h2><p>为了解决原型链继承中共享的问题，基本思路是：在子类构造函数中调用父类构造函数。因为函数就是特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新建的对象为上下文执行构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过call/apply方法，在子类型构造函数内部调用超类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">child</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;aa&quot;</span></span><br><span class="line">	<span class="comment">//打印来自子级的参数</span></span><br><span class="line">	<span class="built_in">console</span>.log(child.name)	<span class="comment">//jojo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	father.apply(<span class="built_in">this</span>,[&#123;<span class="attr">name</span>:<span class="string">&quot;jojo&quot;</span>&#125;])	<span class="comment">//继承，可以传参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">alert(a.name)		<span class="comment">//aa</span></span><br></pre></td></tr></table></figure>

<ol>
<li>优点：<ul>
<li>解决了原型链继承中所有属性都会暴露和子级不能向父级传参的问题。</li>
<li>可以在子类构造函数中向父级构造函数传参</li>
</ul>
</li>
<li>缺点：<ul>
<li>必须在构造函数中定义方法，因此函数不能复用</li>
<li>父级的方法对于子级不可见</li>
</ul>
</li>
</ol>
<h1 id="组合继承-伪经典继承"><a href="#组合继承-伪经典继承" class="headerlink" title="组合继承(伪经典继承)"></a>组合继承(伪经典继承)</h1><p>JavaScript中最常见的继承模式，使用instanceof操作符和isPrototype()方法可用于识别基于组合继承的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//借用构造函数继承实例属性，原型链继承来继承原型上的方法和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&quot;jianhuo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">father.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">funciton <span class="function"><span class="title">child</span>(<span class="params"></span>)</span>&#123;		<span class="comment">//借用构造函数继承属性</span></span><br><span class="line">	father.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">child.prototype = <span class="keyword">new</span> father()	<span class="comment">//原型链继承，注意！重写原型导致constructors属性丢失</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> child()</span><br><span class="line">a.sayName()</span><br></pre></td></tr></table></figure>

<ol>
<li>本质：<ul>
<li>使用原型链继承来继承原型上的属性和方法，用组合继承来继承实例属性。这样既可以把方法定义在原型上实现复用，又可以让每个实例都有自己的属性。</li>
</ul>
</li>
<li>优点：<ul>
<li>综合了原型链和借用构造继承的优点</li>
</ul>
</li>
<li>缺点：<ul>
<li>必会调用两次超类型构造函数，一次在创建子类型的原型时，另一次在子类型构造函数内部。</li>
</ul>
</li>
</ol>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种实现方法</span></span><br><span class="line"><span class="comment">//1.自定义函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ob</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	f.prototype.name = <span class="string">&quot;jianhuo&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> f()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ob()</span><br><span class="line"><span class="built_in">console</span>.log(a.name)	<span class="comment">//jianhuo</span></span><br><span class="line"><span class="comment">//2.使用Object.create方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">		<span class="attr">value</span>:<span class="string">&quot;gun&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">alert(a.name)</span><br></pre></td></tr></table></figure>

<ol>
<li>本质：<ul>
<li>ob()式对传入的对象执行了一次浅复制。</li>
</ul>
</li>
<li>优点：<ul>
<li>原型式继承非常适合不需要单独创建构造函数，但是任然需要在对象间共享信息的场合。</li>
</ul>
</li>
<li>缺点：<ul>
<li>和原型链继承一样，属性中包含的引用值会始终在相关的对象间共享。</li>
</ul>
</li>
</ol>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(name)</span><br><span class="line">	clone.sayGood=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wiw = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;jianhuo&quot;</span>,</span><br><span class="line">	<span class="attr">act</span>:<span class="string">&quot;pa&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> final = father(wiw)	<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line">final.sayGood()</span><br></pre></td></tr></table></figure>

<ol>
<li>本质:<ul>
<li>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</li>
</ul>
</li>
<li>优点：<ul>
<li>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。</li>
</ul>
</li>
<li>缺点:<ul>
<li>通过寄生式继承给对象添加函数会导致函数难以重用。</li>
</ul>
</li>
</ol>
<h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>可以算是应用类型继承的最佳模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	father.call(<span class="built_in">this</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(father.prototype)</span><br><span class="line">a.constructor = child	<span class="comment">//重新赋值constructor</span></span><br><span class="line">child.prototype = a</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> child(<span class="string">&quot;jianhuo&quot;</span>)</span><br><span class="line">b.sayName()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>本质：</p>
<ul>
<li><p>这个函数实现了接受两个参数：子类构造函数和父类构造函数。</p>
<ul>
<li>在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype对象设置constructor属性，解决由于重写原型导致的默认constructor丢失问题。最后将新创建的对象赋值给子类型原型。</li>
</ul>
</li>
<li><p>寄生式组合继承通过借用构造函数继承属性，但是用混合式原型链继承方法。基本思路就是不通过调用父类构造函数给子类函数原型赋值，而是取得一个父类的副本。</p>
<ul>
<li>说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/08/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/08/Vue%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B006/" class="post-title-link" itemprop="url">Vue源码学习笔记06</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-08 10:31:19" itemprop="dateCreated datePublished" datetime="2021-12-08T10:31:19+08:00">2021-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:37:46" itemprop="dateModified" datetime="2021-12-25T14:37:46+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/Vue%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Vue源码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>vue-router是Vue框架的另一个强大工具。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
<h1 id="哈希路由"><a href="#哈希路由" class="headerlink" title="哈希路由"></a>哈希路由</h1><p>单页应用路由，我们有一些url，想把他们映射到组件。即使组件和这些url有一一对应的关系，并能够实现跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;url&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;a @click=&quot;routeTo(&#x27;#foo&#x27;)&quot; href=&quot;#foo&quot;&gt;foo&lt;/a&gt;</span><br><span class="line">  &lt;a @click=&quot;routeTo(&#x27;#bar&#x27;)&quot; href=&quot;#bar&quot;&gt;bar&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	//一个基于哈希的路由解决方案</span><br><span class="line">	/*</span><br><span class="line">		浏览器有两种方式进行路由，可以使用哈希，也可以使用HTML5 History API。</span><br><span class="line">		从某种意义上说，Html5 History APi更好，它支持弹出状态，你的URL看起来会更好，但是他需要某种服务器配置</span><br><span class="line">		为了更方便的展示，这里使用哈希方式访问。</span><br><span class="line">	*/</span><br><span class="line">window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;</span><br><span class="line">  app.url = window.location.hash.slice(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    url: &#x27;foo&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    foo: &#123; template: `&lt;div&gt;foo&lt;/div&gt;`&#125;,</span><br><span class="line">    bar: &#123; template: `&lt;div&gt;bar&lt;/div&gt;`&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    routeTo (route) &#123;</span><br><span class="line">      window.location.hash = route</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h1><p>完成了基础路由跳转的实现，那么我们能不能把基础路由和组件的对应关系维护起来，形成一张表，这样当我们需要跳转的时候查询路由表再跳转对应组件就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;matchedComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;a href=&quot;#foo&quot;&gt;foo&lt;/a&gt;</span><br><span class="line">  &lt;a href=&quot;#bar&quot;&gt;bar&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// &#x27;#/foo&#x27; -&gt; Foo</span><br><span class="line">// &#x27;#/bar&#x27; -&gt; Bar</span><br><span class="line">// &#x27;#/404&#x27; -&gt; NotFound</span><br><span class="line"></span><br><span class="line">const Foo = &#123; template: `&lt;div&gt;foo&lt;/div&gt;` &#125;</span><br><span class="line">const Bar = &#123; template: `&lt;div&gt;bar&lt;/div&gt;` &#125;</span><br><span class="line">const NotFound = &#123; template: `&lt;div&gt;not found!&lt;/div&gt;` &#125;</span><br><span class="line"></span><br><span class="line">//路由表，维护组件和路径的对应关系</span><br><span class="line">const routeTable = &#123;</span><br><span class="line">  foo: Foo,</span><br><span class="line">  bar: Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;</span><br><span class="line">  app.url = window.location.hash.slice(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    url: &#x27;foo&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  //两种视图实现方式,render渲染函数和html模板</span><br><span class="line">  render (h) &#123;</span><br><span class="line">	  return h(&#x27;div&#x27;, [</span><br><span class="line">		  h(routeTable[this.url] || NotFound),</span><br><span class="line">		  h(&#x27;a&#x27;,&#123; attrs:&#123; href:&#x27;#foo&#x27;&#125;&#125;, &#x27;foo&#x27;),</span><br><span class="line">		  &#x27; | &#x27;,</span><br><span class="line">		  h(&#x27;a&#x27;,&#123; attrs:&#123; href:&#x27;#bar&#x27;&#125;&#125;, &#x27;bar&#x27;)</span><br><span class="line">	  ])</span><br><span class="line">  &#125;</span><br><span class="line">  // computed: &#123;</span><br><span class="line">  //   matchedComponent () &#123;</span><br><span class="line">  //     return routeTable[this.url] || NotFound</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="正则匹配动态路由"><a href="#正则匹配动态路由" class="headerlink" title="正则匹配动态路由"></a>正则匹配动态路由</h2><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><p>使用path-to-regexp工具库中的pathToRegexp函数处理url中的地址和参数</p>
<h3 id="动态路由的匹配"><a href="#动态路由的匹配" class="headerlink" title="动态路由的匹配"></a>动态路由的匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// &#x27;#/foo/123&#x27; -&gt; foo with id: 123</span><br><span class="line">// &#x27;#/bar&#x27; -&gt; Bar</span><br><span class="line">// &#x27;#/404&#x27; -&gt; NotFound</span><br><span class="line"></span><br><span class="line">// path-to-regexp usage:</span><br><span class="line">// const regex = pathToRegexp(pattern)</span><br><span class="line">// const match = regex.exec(path)</span><br><span class="line"></span><br><span class="line">//根据路由展现的组件</span><br><span class="line">const Foo = &#123;</span><br><span class="line">  props: [&#x27;id&#x27;],</span><br><span class="line">  template: `&lt;div&gt;foo with id: &#123;&#123; id &#125;&#125;&lt;/div&gt;`</span><br><span class="line">&#125;</span><br><span class="line">const Bar = &#123; template: `&lt;div&gt;bar&lt;/div&gt;` &#125;</span><br><span class="line">const NotFound = &#123; template: `&lt;div&gt;not found!&lt;/div&gt;` &#125;</span><br><span class="line"></span><br><span class="line">//正则捕获的路由表</span><br><span class="line">const routeTable = &#123;</span><br><span class="line">  &#x27;/foo/:id&#x27;: Foo,</span><br><span class="line">  &#x27;/bar&#x27;: Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译完成后的数组，就是经过正则匹配后的数组</span><br><span class="line">const compiledRoutes = []</span><br><span class="line">//取出路由表中的所有匹配规则</span><br><span class="line">Object.keys(routeTable).forEach(key =&gt; &#123;</span><br><span class="line">  const dynamicSegments = []</span><br><span class="line">  //工具库函数pathToRegexp，用于处理url中的地址和参数</span><br><span class="line">  const regex = pathToRegexp(key, dynamicSegments)</span><br><span class="line">  const component = routeTable[key]</span><br><span class="line">  compiledRoutes.push(&#123;</span><br><span class="line">	//对应规则映射组件</span><br><span class="line">    component,</span><br><span class="line">	//匹配规则</span><br><span class="line">    regex,</span><br><span class="line">	//解析动态匹配部分</span><br><span class="line">    dynamicSegments</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;</span><br><span class="line">  app.url = window.location.hash.slice(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    url: window.location.hash.slice(1)</span><br><span class="line">  &#125;,</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    const path = &#x27;/&#x27; + this.url</span><br><span class="line"></span><br><span class="line">    let componentToRender</span><br><span class="line">    let props = &#123;&#125;</span><br><span class="line">	//检查是否有匹配上的路由</span><br><span class="line">    compiledRoutes.some(route =&gt; &#123;</span><br><span class="line">      const match = route.regex.exec(path)</span><br><span class="line">      componentToRender = NotFound</span><br><span class="line">	  //判断匹配是否成功</span><br><span class="line">      if (match) &#123;</span><br><span class="line">        componentToRender = route.component</span><br><span class="line">        route.dynamicSegments.forEach((segment, index) =&gt; &#123;</span><br><span class="line">          props[segment.name] = match[index + 1]</span><br><span class="line">        &#125;)</span><br><span class="line">        return true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return h(&#x27;div&#x27;, [</span><br><span class="line">      h(componentToRender, &#123; props &#125;),</span><br><span class="line">      h(&#x27;a&#x27;, &#123; attrs: &#123; href: &#x27;#foo/123&#x27; &#125;&#125;, &#x27;foo 123&#x27;),</span><br><span class="line">      &#x27; | &#x27;,</span><br><span class="line">      h(&#x27;a&#x27;, &#123; attrs: &#123; href: &#x27;#foo/234&#x27; &#125;&#125;, &#x27;foo 234&#x27;),</span><br><span class="line">      &#x27; | &#x27;,</span><br><span class="line">      h(&#x27;a&#x27;, &#123; attrs: &#123; href: &#x27;#bar&#x27; &#125;&#125;, &#x27;bar&#x27;),</span><br><span class="line">      &#x27; | &#x27;,</span><br><span class="line">      h(&#x27;a&#x27;, &#123; attrs: &#123; href: &#x27;#garbage&#x27; &#125;&#125;, &#x27;garbage&#x27;)</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://giorunogiovanna.github.io/GiorunoGiovana.github.io/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/GiorunoGiovana.github.io/images/avatar.jpeg">
      <meta itemprop="name" content="Joker">
      <meta itemprop="description" content="记录自己的学习路程，以及一些有趣的事物">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Joker's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/GiorunoGiovana.github.io/2021/12/07/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B007%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">js学习笔记07对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-07 21:51:01" itemprop="dateCreated datePublished" datetime="2021-12-07T21:51:01+08:00">2021-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 14:36:36" itemprop="dateModified" datetime="2021-12-25T14:36:36+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/GiorunoGiovana.github.io/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><ol>
<li><h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><ol>
<li><h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><ol>
<li>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。</li>
<li>要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接受3个参数（要个其添加属性的对象，属性的名称和一个描述对象）<ol>
<li>最后一个参数，即描述符对象上的属性可以包含:configurable、enumerable、wirtable和value</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ol>
<li>访问器属性不包含数据值，包含一个获取(getter)函数和一个(setter)函数，不过这两个函数不是必须的。</li>
<li>在读取访问器属性时，会调用获取函数，这个函数的责任是返回一个有效的值。再写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。（Vue响应式原理）</li>
</ol>
</li>
<li><h5 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h5><ol>
<li>Object.defineProperties()可以通过多个描述符一次性定义多个属性。它接受两个参数（要为之添加或修改属性的对象和另一个描述符对象，其属性与一一对应）</li>
</ol>
</li>
<li><h5 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h5><ol>
<li>使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。<ol>
<li>这个方法接受两个参数:属性所在的对象和要去的其描述符的属性名。返回值是一个对象，包含访问器属性</li>
</ol>
</li>
<li>ES7新增了Object.getOwnPropertyDescriptors()静态方法<ol>
<li>接受一个对象，并返回这个对象每个属性的特性</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><ol>
<li>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个复制动作。可以简写<ol>
<li>解构赋值不一定与对象属性匹配，赋值的时候可以忽略某些属性，如果引用的属性不存在，则该变量的值为undefined，也可以定义默认值，适用于属性不存在的情况。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><ol>
<li><h5 id="属性值的简写"><a href="#属性值的简写" class="headerlink" title="属性值的简写"></a>属性值的简写</h5><ol>
<li>简写的属性名只要使用变量名就会自动被解释为同名的属性键</li>
</ol>
</li>
<li><h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><ol>
<li>如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能再对象字面量中直接动态命名属性<ol>
<li>中括号包围的对象属性键告诉运行时将其作为JavaScript表达式而不是字符串来求值。</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><ol>
<li><p>再给对象定义方法时，通常要写一个方法名、冒号，然后再引用一个匿名函数表达式。</p>
<ol>
<li>新的简写方法可以直接声明函数，例如sayName(){…}，与可计算属性键相互兼容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const methodKey = &quot;foo&quot;</span><br><span class="line">let person = &#123;</span><br><span class="line">	[methodKey](name)&#123;</span><br><span class="line">		alert(&quot;aaa &quot;+name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName(&quot;john&quot;)		//aaa john</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h4><ol>
<li>ES6新增了Object.assign()方法用于合并对象。接受一个目标对象和一个多源对象作为参数，然后将每个源对象中可枚举和自由属性赋值到目标函数。<ol>
<li>这是一种浅拷贝，如果多个源对象有相同的属性，则使用最后一个。此外，从源对象访问器属性中取得的值，比如获取函数，会作为一个静态值赋值给目标对象。如果赋值期间出错，则操作会终止并退出，同时抛出错误。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>前提：使用Object构造函数创建多个有相同接口的对象会比较麻烦。ES6开始正式支持类和继承。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单来说，就是把创建Object对象的过程封装到函数中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function 	createPerson（name,age,job）&#123;</span><br><span class="line">	let 0 = new Object</span><br><span class="line">	o.name = name</span><br><span class="line">	o.age = age</span><br><span class="line">	o.job = job</span><br><span class="line">	o.sayName = function()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">	return o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = cretePerson(&quot;jianhuo&quot;,19,&quot;geiyepa&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><ol>
<li><h5 id="跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。"><a href="#跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。" class="headerlink" title="跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。"></a>跟工厂模式相比，有三个区别。比起工厂模式，构造的实例都被认为是Object实例。</h5><ol>
<li>没有显示地创建对象</li>
<li>属性和方法直接赋值给this</li>
<li>没有return</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function 	createPerson（name,age,job）&#123;</span><br><span class="line">	this.name = name</span><br><span class="line">	this.age = age</span><br><span class="line">	this.job = job</span><br><span class="line">	this.sayName = function()&#123;</span><br><span class="line">		console.log(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = cretePerson(&quot;jianhuo&quot;,19,&quot;geiyepa&quot;)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的"><a href="#按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的" class="headerlink" title="按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的"></a>按照惯例，构造函数名称的首字母都是要大写的，非构造函数名称的首字母都是要小写的</h5></li>
<li><h5 id="要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作"><a href="#要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作" class="headerlink" title="要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作"></a>要创建Person实例，要使用new操作符，以这种方式调用构造函数会执行以下操作</h5><ol>
<li>在内存中创建一个新对象</li>
<li>在这个新对象的内部的[[Prototype]]特性被赋值为构造函数的prototype属性</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则返回创建的新对象</li>
</ol>
</li>
<li><h5 id="构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数"><a href="#构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数" class="headerlink" title="构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数"></a>构造函数不一定要写成函数声明形式。赋值给变量的函数表达式也可以标识构造函数</h5></li>
<li><h5 id="如果不想传参数，那么new的时候后面的括号可以不加。"><a href="#如果不想传参数，那么new的时候后面的括号可以不加。" class="headerlink" title="如果不想传参数，那么new的时候后面的括号可以不加。"></a>如果不想传参数，那么new的时候后面的括号可以不加。</h5></li>
<li><h5 id="构造函数也是函数，和普通函数的唯一区别是调用方式的不同。"><a href="#构造函数也是函数，和普通函数的唯一区别是调用方式的不同。" class="headerlink" title="构造函数也是函数，和普通函数的唯一区别是调用方式的不同。"></a>构造函数也是函数，和普通函数的唯一区别是调用方式的不同。</h5><ol>
<li>使用new操作符调用就是构造函数，不使用new操作符调用就是普通函数</li>
</ol>
</li>
<li><h5 id="构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。"><a href="#构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。" class="headerlink" title="构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。"></a>构造函数的主要问题是，其定义的方法会再每个实例上都创建一遍。</h5><ol>
<li>要解决这个问题，可以把函数定义转移到构造函数外面。</li>
</ol>
</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ol>
<li><h4 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h4><ol>
<li>可以看成JavaScript版的继承</li>
<li>只要创建函数，就会为其创建一个prototype属性（指向原型对象）</li>
<li>默认情况下，所有原型对象自动获得一个名为constructor的属性，只会函数本身。</li>
</ol>
</li>
<li><h4 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h4><ol>
<li>再通过对象访问属性是，会按照这个属性的名称开始搜索。顺着原型链一直向上查找，直到object’原型，也就是null。</li>
<li>这就是原型用于多个对象实例间共享属性和方法的原理。</li>
<li>虽然可以通过实例读取原型对象的值，但是不可以通过实例重写这些值。</li>
<li>如果在实例上添加一个与原型对象中同名的属性，那就会再实例上创建这个属性，这个属性会遮住原型对象上的对应属性。（优先级比原型链上的同名属性高）<ol>
<li>即时实例上的属性设置为null，依然会屏蔽，但是使用delete操作符删除属性可以回复。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h4><ol>
<li>有两种方式使用in操作符<ol>
<li>使用for。。。in循环</li>
<li>单独使用<ol>
<li>in操作符会在可以通过对象访问到指定属性时候返回true（包括原型链上的同名属性）</li>
</ol>
</li>
<li>如果想列出所有实例属性，无论是否可以枚举，都可以使用Object.getOwnPropertyNames()</li>
<li>使用Object.keys()可以获取实例上的属性</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h4><ol>
<li>for-in循环和Object,keys()枚举顺序是不确定的。</li>
<li>Object.getOwnPropertyNames(), Object.getOwnPropertySymbols和Object.assign()的枚举顺序是确定的。</li>
</ol>
</li>
<li><p>每个函数都会创建一个prototype属性，包含应该有特定应用类型的实例共享的属性和方法。实际上这个对象就是通过调用构造函数创建对象的原型。</p>
<ol>
<li>使用原型对象的好处是，再它上面定义的属性和方法可以被对象实例共享。原来再构造函数中直接赋给对象实例的值，可以直接赋值给他们的原型。</li>
</ol>
</li>
<li><p>与构造函数模式不同，使用这种原型模式定义的属性和方法是有所有实例共享的。</p>
</li>
</ol>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><ol>
<li><h4 id="迭代对象属性是一个JavaScript存在已久的难题。"><a href="#迭代对象属性是一个JavaScript存在已久的难题。" class="headerlink" title="迭代对象属性是一个JavaScript存在已久的难题。"></a>迭代对象属性是一个JavaScript存在已久的难题。</h4></li>
<li><p>ES7新增了两个静态的方法，用于将对象内容转换为序列化的——更重要的是可迭代的格式。</p>
<ol>
<li>Object.values()接受一个对象，返回对象值的数组</li>
<li>Object,entires()接受一个对象，返回对象键值对的数组，如[[“aaa”,”bbb”],[“bbb”,”ccc”]]</li>
<li>非字符串会被转化为字符输出，符号属性（symbol）会被忽略</li>
</ol>
</li>
<li><h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><ol>
<li>因为从原型上搜索值的过程是动态的，所以即时实例在修改原型前就已经存在，任何时候对原型的修改也会在实例上反映出来<ol>
<li>主要原因是实例和原型的松散联系，实例和原型之间的链接就是简单的指针，而不是保存副本。</li>
<li>虽然随时都能给原型添加属性和方法，并能够立即反映到所有对象实例上，但是这跟重写整个原型是不一样的。实例的[[prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用仍然时最初的原型。</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h4><ol>
<li>弱化了想构造函数传递初始化参数的能力，会导致所有实例默认取得相同的属性值。</li>
<li>原型上所有属性都是在实例中共享的。如果这个属性是对象，那么某个实例上对于对象的修改会影响所有实例。</li>
</ol>
</li>
<li><h4 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h4><ol>
<li>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。</li>
</ol>
</li>
<li><h4 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h4><ol>
<li>为了减少代码冗余，也为了美观，直接通过一个包含所有属性和方法的对象字面量来重写原型。</li>
<li>但是这样重写原型会导致constructor属性丢失，从而默认指向Object构造函数<ol>
<li>解决办法一：<ol>
<li>重写时候添加一句constructor:xxx重新指定但是这种方法设置的constructor属性是可枚举的，而默认的此属性是不可枚举的。</li>
</ol>
</li>
<li>解决办法二：<ol>
<li>使用Object.defineProPerty()方法定义constructor属性</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name:&quot;jianhuo&quot;,</span><br><span class="line">	age:21,</span><br><span class="line">	job:&quot;geiyepa&quot;,</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(&quot;gunyuandian&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name:&quot;jianhuo&quot;,</span><br><span class="line">	age:21,</span><br><span class="line">	job:&quot;geiyepa&quot;,</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(&quot;gunyuandian&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//回复constructor属性</span><br><span class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;, &#123;</span><br><span class="line">	enumerable:false,</span><br><span class="line">	value:Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/GiorunoGiovana.github.io/page/2/">2</a><a class="page-number" href="/GiorunoGiovana.github.io/page/3/">3</a><a class="extend next" rel="next" href="/GiorunoGiovana.github.io/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Joker"
      src="/GiorunoGiovana.github.io/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Joker</p>
  <div class="site-description" itemprop="description">记录自己的学习路程，以及一些有趣的事物</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/GiorunoGiovana.github.io/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/GiorunoGiovana.github.io/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/GiorunoGiovana.github.io/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GiorunoGiovanna" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GiorunoGiovanna" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:971615621@qq.com" title="E-Mail → mailto:971615621@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/joker_21" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;joker_21" rel="noopener" target="_blank">CSDN</a>
        </li>
    </ul>
  </div>

        
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1383864027&auto=1&height=66"></iframe>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Joker</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/GiorunoGiovana.github.io/lib/anime.min.js"></script>
  <script src="/GiorunoGiovana.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/GiorunoGiovana.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/GiorunoGiovana.github.io/js/utils.js"></script>

<script src="/GiorunoGiovana.github.io/js/motion.js"></script>


<script src="/GiorunoGiovana.github.io/js/schemes/pisces.js"></script>


<script src="/GiorunoGiovana.github.io/js/next-boot.js"></script>




  




  
<script src="/GiorunoGiovana.github.io/js/local-search.js"></script>













  

  

<script src="/GiorunoGiovana.github.io/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/GiorunoGiovana.github.io/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
